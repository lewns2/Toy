# 함수형 프로그래밍 개요

## 정의

함수형 프로그래밍(Functional Programming)은 프로그래밍 패러다임 중 하나로, 계산을 수학적 함수의 평가로 본다는 개념에 기반을 두고 있습니다.

함수형 프로그래밍은 대표적으로 Haskell, Scala, Clojure 등의 언어에서 사용되고 있으며, 최근에는 JavaScript, Python, Ruby 등의 언어에서도 함수형 프로그래밍 기법을 활용하는 추세입니다.

## 목표

깔끔하고 예측 가능하며 테스트하기 쉽고 안전한 코드를 만들기 위해서,

부수 효과(Side-effect)가 있는 함수와 그렇지 않은 순수 함수(Pure Function)를 구분하고,

데이터의 제어 흐름과 연산을 추상화하여,

문제를 최대한 작게 만들고 이를 조립하여 문제를 해결합니다.

## 특징

함수형 프로그래밍에서는 상태를 변경하는 것이 아니라, 함수 호출에 의한 계산을 통해 원하는 결과를 얻습니다. 이러한 방식으로 프로그래밍을 하면 프로그램의 동작이 예측 가능하고, 병렬 처리와 분산 처리가 쉬워지는 장점이 있습니다. 또한, 함수형 프로그래밍에서는 코드의 재사용성과 유지보수가 용이하다는 특징이 있습니다.

함수형 프로그래밍에서는 함수가 일급 객체(First-class Citizen)로 취급됩니다. 즉, 함수를 다른 함수의 인자로 전달하거나, 함수의 반환값으로 사용할 수 있습니다. 이러한 기능을 활용하면, 함수를 조합하여 더 복잡한 동작을 하는 함수를 만들 수 있습니다.

### 선언적 프로그래밍

함수형 프로그래밍은 큰 틀에서 선언적 프로그래밍 패러다임에 속합니다.

내부적으로 코드를 어떻게 구현했는지, 데이터는 어떻게 흘러가는 밝히지 않은 채 연산/작업을 표현하는 것을 말합니다.

프로그래밍 패러다임

- 명령형 프로그래밍 : 무엇(What)을 할 것인지 나타내기보다 어떻게(How)할 건지를 설명하는 방식

  - 절차지향 프로그래밍
  - 객체지향 프로그래밍

- 선언형 프로그래밍 : 어떻게 할건지(How)를 나타내기보다 무엇(What)을 할 건지를 설명하는 방식
  - 함수형 프로그래밍

### 순수함수

순수함수란 부수 효과가 없는 함수를 의미합니다.

조건

- 동일한 인자를 넣을 경우 항상 같은 값을 반환해야 한다.
  - 함수의 인자가 아닌 외부 변수를 사용하지 않아야 한다. (단, 상수의 경우 변하지 않으므로 허용된다.)
  - 함수 내부에서 호출 때마다 달라지는 값이 없어야 한다. (ex. `Math.random()`)
- 함수 스코프 밖에서 어떠한 변경도 일으키지 않는다.
  - 외부 변수의 값을 변경해서는 안된다.
  - try ~ catch 와 같은 에러 처리 로직을 사용하지 않아야 한다.

장점

- 순수함수는 항상 같은 값을 반환하기 때문에 동작을 예측하고 테스트하기 용이합니다.
- `순수함수 + 순수함수 = 순수함수`이므로 로직이 복잡해지더라도 이를 조립(합성)하여 해결할 수 있습니다.

### 일급 객체

함수형 프로그래밍에서는 함수를 일급 객체로 취급합니다.

일급 객체는 다음과 같은 것들이 가능한 객체를 말합니다.

- 변수나 데이터 구조 안에 담을 수 있다.
- 파라미터로 전달할 수 있다.
- 반환값으로 사용할 수 있다.

이를 통해 함수를 파라미터로 넘기거나, 함수를 반환하는 등의 작업이 가능합니다.

참고로,

- 콜백 함수 : 다른 함수의 인자(파라미터)로써 넘겨지는 함수
- 고차 함수 : 함수를 인자로 받거나 결과로 반환하는 함수

### 참조 투명성

참조 투명성은 순수함수를 정의하는 좀 더 공식적인 방법으로, 순수함수의 본연의 특징을 말합니다.

참조 투명성이란 다음과 같습니다.

- 동일한 인자에 대해 항상 동일한 결과를 반환해야 한다.
- 참조 투명성을 통해 기존의 값은 변경되지 않고 유지된다.

### 불변성

불변하다라는 의미는 한번 생성된 후에는 절대 바뀌지 않는 것을 뜻합니다.

## 주목받고 있는 함수형 프로그래밍

### 클래스형 컴포넌트에서 함수형 컴포넌트로!(this의 제거)

리액트의 과거에는 클래스형 컴포넌트를 주로 사용했지만, 2019년 v16.8부터 함수형 컴포넌트에 리액트 훅을 지원하면서부터 함수형 컴포넌트와 훅을 함께 사용할 것을 권장하고 있습니다.

클래스형과 함수형 컴포넌트의 역할은 동일하지만, 함수형 컴포넌트는 클래스형 컴포넌트보다 선언하기 편하고, 메모리 자원을 덜 사용한다는 장점이 있습니다. 과거에도 함수형 컴포넌트가 있었지만, state와 라이프사이클 API를 사용할 수 없다는 단점을 리액트 훅이 도입되면서 해결되었습니다.

**예시) state의 변경**

1. 클래스형 컴포넌트

```java
class MyComponent extends React.Component {
  constructor(props) {
    super(props)
    this.state = {someState:0};
  }

  methodOne(event) {
		this.setState({ someState: this.state.someState + 1})
  }

  render() {
    return (
      // 이러면 에러가 난다.
      <button onClick={this.methodOne}>Click me!</button>

      // bind를 해야 되는데 왜 이런지 알려주려면 상당한 부가설명이 필요하다.
      <button onClick={this.methodOne.bind(this)}>Click me!</button>
    ) ;
  }
}
```

1. 함수형 컴포넌트

```java
const MyComponent = (props) => {
  const [value, setValue] = useState(0)

  const methodOne = (event) => setValue(value + 1)

  return (
    <button onClick={methodOne}>Click me!</button>
  ) ;
}
```

### Java8에서 함수형 프로그래밍 도입

Java는 객체지향 프로그래밍 언어입니다. 그러나 Java는 함수형 프로그래밍과 비동기 논블로킹의 기능 도입을 위해 Java8부터 `Optional`과 `람다식`, NodeJS처럼 `비동기 논블로킹 방식`을 도입하게 됩니다.

**예시 1)** **Java8의 StreamAPI**

```java
List<Integer> values = Arrays.asList(7, 5, 123, 5, 42, 95, 68, 30, 42);

List<Integer> result = values.stream()
    .filter(number -> number < 50)
    .distinct()
    .sorted(Integer::compare)
    .collect(Collectors.toList());
```

**예시 2) Optional : 값이 존재할 수도, 존재하지 않을 수도 있는 값을 포장한 객체**

Java는 `Optional`을 도입하여 “참조 값이 `Null`일 수도 있음”을 알려주고 이를 통해 `NullPointerException`을 방지합니다.

자바로 개발을 하다보면 `NullPointerException`을 자주 마주하게 됩니다. 자바는 객체지향 프로그래밍의 참조형 자료에 `Null(존재하지 않는 값)`이라는 개념을 허용하고 있기 때문에 발생하는 문제입니다.

어떻게 `Null`을 다루면 좋을 지에 대한 고민 중 해결책을 함수형 언어에서 찾았습니다. 함수형 언어는 존재하지 않을 수도 있는 값에 대한 별도의 타입을 가지고 있습니다.

### 동시성 프로그래밍에 강점

함수형 프로그래밍은 부수효과가 발생하지 않는 “참조 투명성”을 가졌기에 멀티코어 프로세스에서 교착상태에 빠지지 않는다는 장점이 있습니다. 이러한 특징으로 동시성 프로그래밍에서 강력한 프로그래밍 패러다임으로 작용합니다.

## 결론

함수형 프로그래밍은,

외부에서 관찰 가능한 부수 효과가 제거된 **불변** 프로그램을 작성하기 위해 **순수함수**를 **선언적**으로 평가하는 것입니다.
