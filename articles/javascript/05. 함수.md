# 모던 자바스크립트 Deep Dive Ch.12

**함수**

자바스크립트에서 가장 중요한 개념이다.

핵심 개념인 **스코프, 실행컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메서드, this, 프로토타입, 모듈화** 등이 모두 함수와 깊은 관련이 있기 때문이다.

**함수 사용의 이유**

코드의 중복을 억제하고 재사용을 높이기 때문에 유지보수의 편의성과 실수를 줄여 코드의 신뢰성을 높일 수 있다.

**자바스크립트에서 함수는 호출 가능한 객체 타입의 값(정확히는 일급 객체)**

> 일급 객체 : 값의 성질을 갖는 객체

이는 다른 프로그래밍 언어와 구별되는 자바스크립트의 중요한 특징이다. (일반 객체는 호출할 수 없다.)

따라서 숫자, 객체 리터럴로 생성하는 것처럼 함수 리터럴로 생성할 수 있다.

```jsx
var f = function add(x, y) {
  return x + y;
};
```

**함수를 정의하는 4가지 방법**

1. 함수 선언문 : `function add(x, y) {return x + y;}`
2. 함수 표현식 : `var add = function (x, y) {return x + y;}`
3. Function 생성자 함수 : `var add = new Function(’x’, ‘y’, ‘return x+y’);`
4. 화살표 함수(ES6) `var add = (x, y) ⇒ x + y;`

자바스크립트 엔진은 함수 선언문을 해석해 함수 객체를 생성한다. 이때 생성된 함수를 호출하기 위해 식별자가 필요한데 이를 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.

**즉, 함수 호출은 함수 이름이 아닌 함수 객체를 가리키는 식별자로 호출한다.**

```jsx
var add = function add(x, y) {
  return x + y;
};

console.log(add(2, 5));

// var add => 식별자
// function add => 함수 이름
// console.log에서 호출한 함수는 식별자를 호출한다.
```

**함수 생성 시점과 함수 호이스팅**

함수 호이스팅

자바스크립트 엔진은 모든 선언문을 런타임(코드가 한 줄씩 순차적으로 실행되는 시점) 이전에 먼저 실행된다.

그러므로 함수선언문도 마찬가지로 런타임 이전에 함수 객체가 먼저 생성된다. 그리고 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다.

함수 표현식은 변수 선언문과 변수 할당문을 한 번에 기술한 축약 표현과 동일하게 동작한다.

따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅이 발생한다.

왜냐하면 변수에 함수 객체를 할당하는 방식으로 쓰이기 때문이다.

**함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시한다. 그러므로 함수 선언문 대신 함수 표현식 사용을 권장한다.**

**자바스크립트 함수의 문제점**

- 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
- 동적 타입 언어이므로, 매개변수의 타입을 사전에 지정할 수 없다.

이러한 문제점들로 인해 부적절한 호출을 사전에 방지할 수 없고 런타임에 발생하는 에러를 통해 확인 가능하다.

따라서 타입스크립트와 같은 정적 타입을 선언하여 사전에 방지하는 것도 하나의 방법이다.

- 자바스크립트의 함수는 객체이다.

객체는 언제든 변할 수 있으며, 참조에 의한 전달 방식으로 동작한다.

그래서 함수가 외부 상태에 의한 변경이 가능하므로, 상태 변화를 추적하기 어렵다. 이는 코드 복잡성을 증가시키고 가독성을 해친다.

순수 함수

함수형 프로그래밍에서 어떤 외부 상태에 의존하지도 않고 변경하지도 않는 함수를 순수 함수라 한다.

즉, 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수이다.

함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임이다.
