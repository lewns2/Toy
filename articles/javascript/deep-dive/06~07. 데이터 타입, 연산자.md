## 데이터 타입

---

데이터 타입은 값의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다.

자바스크립트(ES6)는 7개의 데이터 타입을 제공한다.

크게 원시 타입과 객체 타입으로 분류하며

원시 타입에는

- 숫자, 문자열, 불리언, undefined, null, 심벌 타입이 있다.

객체 타입에는

- 객체, 함수, 배열 등이 있다.

### 숫자 타입

C나 자바의 경우, 정수와 실수를 구분하는 다양한 타입을 제공하는 반면 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다. 즉, 모든 수를 실수로 처리한다.

또, 자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다.

```jsx
var integer = 10;
var double = 10.12;
var negative = -20;
var octal = 023;
var hex = 0x41;

console.log(octal); // 19
console.log(hex); // 65
```

모든 수를 실수로 처리하기 때문에, 정수로 표현될지라도 사실은 실수라는 것을 의미한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5e3dc9fd-9792-4b51-b7d0-b2770aafb7e0/Untitled.png)

```jsx
0.5 + 0.1 == 0.6; // true
0.1 + 0.2 == 0.3; // false
```

### 문자열 타입

텍스트 데이터를 나타내는 데 사용하며, 문자열은 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합으로 전 세계 대부분의 문자를 표현할 수 있다.

문자열은 작은따옴표(’’), 큰따옴표(””), 백틱(``)으로 텍스트를 감싼다. 자바스크립트에서 가장 일반적인 표기법은 작은 따옴표를 사용하는 것이다.

다른 타입의 값과 달리 문자열은 따옴표로 감싸는 이유는 키워드나 식별자 같은 토큰과 구분하기 위해서다.

만약 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 키워드나 식별자 같은 토큰으로 인식한다.

```jsx
/* 따옴표로 감싸지 않은 hello는 식별자로 인식한다. */
var string = hello; //  Uncaught ReferenceError: hello is not defined
```

C - 문자열 타입을 제공하지 않고 문자의 배열로 문자열을 표현한다.

JAVA - 문자열을 객체로 표현한다.

JavaScript - 문자열을 원시 타입으로 취급하며, 변경 불가능한 값이다.

**템플릿 리터럴**

ES6부터 템플릿 리터럴이라고 하는 새로운 문자열 표기법이 도입되었다.

템플릿 리터럴은 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공한다.

템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리된다.

템플릿 리터럴은 백틱(``)을 사용해 표현한다.

1. 멀티라인 문자열

일반 문자열 내에서는 줄바꿈(개행)이 허용되지 않는다. 이와 달리 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 허용되며, 모든 공백도 있는 그대로 적용된다.

```jsx
// ~ES5
var template1 = "Hello\nWorld";

// ES6
var template2 = `Hello
World`;

console.log(template1);
console.log(template2);
```

1. 표현식 삽입

문자열은 문자열 연산자 ‘+’를 사용해 연결할 수 있다.

템플릿 리터럴 내에서는 표현식 삽입을 통해 간단히 문자열을 삽입할 수 있다.

```jsx
var first = "First";
var last = "Last";

// ~ES5
console.log("My name is " + first + " " + last + ".");

// ES6
console.log(`My name is ${first} ${last}.`);

// 결과 : My name is First Last.
```

### 불리언 타입

불리언 타입의 값은 논리적 참, 거짓을 나타내는 true와 false뿐이다.

### undefined 타입

undefined 타입의 값은 undefined가 유일하다.

var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화된다. 다시 말해, 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 빈 상태(대부분 비어 있지 않고 쓰레기 값이 들어 있다.)로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기화한다. 따라서 변수를 선언한 이후 값을 할당하지 않은 변수를 참조하면 undefined가 반환된다. (오류를 반환하지 않는다!)

undefined는 개발자가 의도적으로 할당된 값이 아니기에 “초기화되지 않은 변수”라는 것을 간파할 수 있다.

이 때문에, undefined를 개발자가 의도적으로 변수에 할당하는 것은 본래 취지와 어긋날뿐더러 혼란을 줄 수 있으므로 권장되지 않는다. 이러한 경우는 null을 할당하는 것이 바람직하다.

### null 타입

자바스크립트는 대소문자를 구별하므로 null은 Null, NULL 등과 다르다.

프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다. 이는 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미이며 값에 대한 참조를 명시적으로 제거하는 것을 의미한다. 자바스크립트 엔진은 누구도 참조하지 않은 메모리 공간에 대해 가비지 콜렉션을 수행할 것이다.

### 심벌 타입

심벌은 ES6에서 추가된 7번째 타입으로, 변경 불가능한 원시 타입의 값이다. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다. 따라서 주로 이름이 충돌한 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.

심벌 이외의 원시 값은 리터럴을 통해 생성하지만 심벌은 Symbol 함수를 호출해 생성한다. 이때 생성된 심벌값은 외부에 노출되지 않으며, 다른 값과 중복되지 않는 유일무이한 값이다.

```jsx
const symbolA = Symbol("symbol");
const symbolB = Symbol("symbol");

console.log(symbolA === symbolB); // false
```

**용례**

1. 자바스크립에서 enum 사용하기

enum처럼 값에는 의미가 없고, 상수 이름 자체에 의미가 있는 경우가 있다. 상수 값은 변경될 수 있으며 다른 변수 값과 중복될 수 있다는 문제가 있다. 변경/중복될 가능성이 있는 무의미한 상수 대신 중복될 가능성이 없는 유일무이한 심볼 값을 사용할 수 있다.

자바스크립트에서 enum을 사용하려면 객체 변경을 방지하기 위해 객체를 동결하는 Object.freeze 메서드와 심볼 값을 사용한다.

```jsx
const Direction = Object.freeze({
  UP: Symbol("up"),
  DOWN: Symbol("down"),
  LEFT: Symbol("left"),
  RIGHT: Symbol("right"),
});
```

### 객체 타입

자바스크립트의 데이터 타입은 크게 원시 타입과 객체 타입으로 분류한다고 했다. 그 이유는 무엇일까?

크게 세가지 측면에서 다르다.

1. 불변성
   - 원시 타입의 값은 변경 불가능한 값, 객체(참조) 타입의 값은 변경 가능한 값이다.
2. 메모리 저장
   - 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 객체를 변수에 할당하면 참조 값이 저장된다.
3. Call by…(Pass by)
   - 원시 값을 갖는 변수를 다른 변수에 할당하면 원본의 원시 값이 복사되어 전달된다. (pass by value)
   - 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복자되어 전달된다. (pass by reference)

### 데이터 타입의 필요성

1. 데이터 타입에 의한 메모리 공간의 확보와 참조

값은 메모리에 저장하고 참조할 수 있어야 한다. 메모리에 값을 저장하려면 먼저 확보해야 할 메모리 공간의 크기를 결정해야 한다. 다시 말해, 몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는 지 알아야 한다.

1. 데이터 타입에 의한 값의 해석

모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장된다. 이때 데이터 타입에 따라 다르게 해석될 수 있다.

예를 들어, 메모리에 저장된 값이 0100 0001인 경우 숫자로 해석하면 65, 문자열로 해석하면 ‘A’다.

정리하자면,

1. 값을 저장할 때 → 메모리 공간 크기 결정
2. 값을 참조할 때 → 한 번에 읽어 들어야 할 메모리 공간 크기를 결정
3. 메모리에서 읽어 들인 2진수를 어떻게 해석할 지 결정하기 위해.

### 동적 타이핑

- **자바스크립트는 동적 타입 언어이다.**

변수는 선언이 아닌 값의 할당에 의해 타입이 결정된다. (자바스크립트엔진이 타입을 추론한다.) 또, 재할당에 의해 언제든 타입이 변경될 수 있다.

예를 들어, C에서는 int num과 같이 num에 int형 만의 값이 올 수 있지만, 자바스크립트는 var foo를 선언한 뒤, foo에 넣는 값에 따라 타입이 변한다.

이런 동적 타입은 유연하고 편리함과 동시에 코드의 신뢰성이 떨어진다.

왜냐하면, 복잡한 프로그램에서 변화하는 변수 값을 추적하기 어렵고, 개발자의 의도와 상관없이 암묵적으로 타입이 자동으로 변환될 가능성이 있기 때문이다.

그렇기 때문에, 이러한 동적 타입 언어를 다룰 때 개발자는 아래와 같은 사항들을 지키며 코드를 작성해야한다.

- 변수의 꼭 필요한 경우에 한해 제한적 사용
- 전역 변수 사용을 최대한 지양하고, 변수의 범위(스코프)를 최대한 좁게 만든다.
- 변수보다는 상수(const)를 통해 값의 변경의 억제
- 변수 이름을 목적이나 의미가 나타나게 네이밍

## 연산자

---

연산자는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 값을 만든다.

### 산술 연산자

산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.

산술 연산이 불가능한 경우, NaN을 반환한다.

이항 산술 연산자

- 예시 : +, - (계산), \*, /, %

단항 산술 연산자

- 예시 : ++, —, +, - (부호 반전)

문자열 연결 연산자

- 예시 : +

### 할당 연산자

할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.

예시 : =, +=, -=, \*=, /=, %=

### 비교 연산자

좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.

동등 비교 연산자

- 예시 : ==, !=

동등 비교 연산자(==)는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.

```jsx
5 == "5"; // true
```

동등 비교 연산자는 결과를 예측하기 어렵고 실수하기 쉬우므로 사용하지 않는 편이 좋다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/daa80f4c-0a12-4dbf-8e60-79c9713410c8/Untitled.png)

```jsx
0 == "0"; // true
0 == []; // true
"0" == []; // false
```

일치 비교 연산자

- 예시 : ===, !==

좌항가 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다. 즉, 암묵적 타입 변환을 하지 않고 값을 비교한다. 따라서 일치 비교 연산자는 예측하기 쉽다.

대소 관계 비교 연산자

대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.

예시 : >, <, >=, <=

### 삼항 조건 연산자

조건식의 평가 결과에 따라 반환할 값을 결정한다.

```jsx
/* 불리언 타입으로 평가될 표현식 ? 참인 경우의 값 : 거짓인 경우의 값 */
조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값
```

if…else 문과의 차이점

삼항 조건 연산자 표현식은 값처럼 사용할 수 있지만, if…else문은 값처럼 사용할 수 없다.

```jsx
var x = 10;
var res = if (x%2) {res = '홀수';} else {res = '짝수';};  // X
var res = x % 2 ? '홀수' : '짝수';
```

### 논리 연산자

우항과 좌항의 피연산자를 논리 연산한다.

예시 : ||, &&, !

드 모르간의 법칙

```jsx
!(x || y) === (!x && !y);
!(x && y) === (!x || !y);
```

### 쉼표 연산자

왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 피연산자의 평가 결과를 반환한다.

```jsx
var x, y, z;
(x = 1), (y = 2), (z = 3); // 3
```

### 그룹 연산자

소괄호로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다.

### typeof 연산자

typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.

7가지 문자열 ‘string’, ‘number’, ‘boolean’, ‘undefined’, ‘object’, ‘function’ 중 하나를 반환한다.

typeof 연산자로 null 값을 연산해보면 ‘null’이 아닌 ‘object’를 반환한다. 이것은 자바스크립트의 첫 번째 버전의 버그다. 하지만 기존 코드에 영향을 줄 수 있기 때문에 아직까지 수정되지 못하고 있다.

따라서 값이 null 타입인지 확인할 때에는 암묵적 타입 변환이 발생하지 않는 일치 연산자(===)를 사용해야 한다.

### 지수 연산자

ES7에서 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭제곱하여 숫자 값을 반환한다.

```jsx
2 ** 3; // 8
```

### 그 외의 연산자

- ?. : 옵셔널 체이닝 연산자
- ?? : null 병합 연산자
- delete : 프로퍼티 삭제
- new : 생성자 함수를 호출할 때 사용하여 인스턴스를 생성
- instanceof : 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별
- in : 프로퍼티 존재 확인

### 연산자 우선순위

[MDN 연선자 우선순위](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
