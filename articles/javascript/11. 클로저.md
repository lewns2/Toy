# 클로저

## 정의

**클로저는 함수와 그 함수가 선언된 렉시컬 환경의 조합이다.**

### 요약

자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다. 이러한 특징으로 인해 **중첩 함수가 이미 생명 주기가 종료한 외부 함수의 변수를 참조**하는 일이 발생한다.

이 중첩 함수를 **클로저**라고 부른다.

### 선수 지식

- 자바스크립트가 어떻게 변수의 유효범위를 지정하는 지를 먼저 이해해야 한다.

## 렉시컬 스코프

렉시컬 스코프를 이해하기 위해 “렉시컬”과 “스코프”에 대해 알아보자.

**스코프(유효 범위)**

- 식별자가 유효한 범위를 말한다.
- 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 자신을 참조할 수 있는 유효 범위가 결정된다.

**렉시컬 환경**

- 코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 말한다.

즉, 렉시컬 스코프는 함수를 어디에 선언하였는지에 따라 상위 스코프를 결정한다는 의미이다.

### 01. 함수의 선언된 위치에 따라 상위 스코프를 결정한다.

**예제)**

```jsx
/* 렉시컬 스코프 : 함수는 선언된 위치에 따라 상위 스코프를 결정한다. */
var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

`foo()` 호출

- 과정
  - `bar()` 호출 ⇒ `console.log(x)` ⇒ x의 값이 `지역 변수 x = 10`을 만나 10이 나올것 같지만 1이 출력된다.
  - `bar() 함수`는 선언된 위치에서 상위 스코프를 결정하므로 x=1이란 변수를 가지게 된다.

`bar()` 호출

- 과정
  - `console.log(x)` ⇒ 위의 `foo()` 호출에 의해 x의 값이 변해서 10이 나올거 같지만 1이 출력된다.
  - 마찬가지로, `bar()` 함수는 선언된 위치에서 상위 스코프를 결정하므로 x=1를 가지게 된다.

**즉, 지역 변수 x = 10은 여기서 아무런 의미가 없는 코드이다.**

### 02. 중첩 함수는 외부 범위에서 선언한 변수에도 접근할 수 있다.

---

**예제)**

```jsx
/* 중첩된 함수는 외부 범위에서 선언한 변수에도 접근할 수 있다. */
function foo() {
  var color = "blue";

  function bar() {
    console.log(color);
  }
  bar();
}
foo();
```

`foo()` → 지역 변수 `color`와 함수 `bar()` 를 생성한다.

`bar()` → 지역 변수가 없다. 하지만 외부 함수에서 생성된 변수인 `name`에 접근할 수 있다.

**만약, `bar()` 가 자신만의 `color` 변수를 가지고 있었다면, `color` 대신 `this.color`을 사용했을 것이다.**

**이처럼 중첩된 함수는 외부 범위에서 선언한 변수에도 접근할 수 있다.**

### Q. 그럼 자바스크립트의 모든 함수는 클로저인가?

개념적으로는 자바스크립트의 모든 함수가 위의 특징들을 만족하므로 클로저이지만, 실제로 우리는 자바스크립트의 모든 함수를 전부 클로저라고 부르지 않는다.

위 예시의 경우, `bar`는 `foo` 안에서 정의되고 실행되었을 뿐, `foo` 밖으로 나오지 않았기 때문이다.

그럼 무엇을 클로저라고 부를까?

## 엄격하게 클로저 살펴보기

다음 코드는 우리가 실제로 부르는 클로저를 나타내고 있다.

**예제)**

```jsx
/* 클로저 예시 */
var color = "red";

function foo() {
  var color = "blue";

  function bar() {
    console.log(color);
  }
  return bar;
}

var baz = foo();
baz();
```

**과정**

1. `bar`는 `color`를 찾아 출력하는 함수로 정의되었다.
2. **`bar`는 `outer environment` 참조로 `foo`의 `environment`를 저장하였다.**
3. **`bar`를 global의 `baz`란 이름으로 데려왔다.**
4. **global에서 `baz(=bar)`를 호출했다.**
5. `bar`는 자신의 스코프에서 color를 찾는다.
6. 없다. 자신의 `outer environment`(= `foo environment`) 참조를 찾아간다.
7. **outer environment인 foo의 스코프를 뒤진다. color를 찾았다. 값은 blue이다.**
8. 때문에 당연히 blue가 출력된다.

**이건 왜 클로저일까?**

중요한 부분은 2~4번, 그리고 7번이다.

- `bar`는 자신이 생성된 렉시컬 스코프에서 벗어나 `global`에서 `baz`라는 이름으로 호출이 되었다.
  - `baz` = `bar` (중첩 함수가 외부에 끌려나온 것이다.)
- 스코프 탐색은 현재 실행 스택과 관련 없는 `foo`를 거쳐 갔다.

`baz`를 `bar`로 초기화할 때는 이미 `bar`의 `outer lexical environment`를 `foo`로 결정한 이후이다.

때문에 `bar`의 생성과 직접적인 관련이 없는 global에서 아무리 호출하더라도 여전히 `foo`에서 color를 찾는 것이다. **이런 `bar`(또는 `baz`)와 같은 함수를 우리는 클로저라고 부른다.**

추가로, `foo`의 렉시컬 환경 인스턴스는 `foo();` 수행이 끝난 이후 GC(가비지 컬렉터)가 회수해야 하는데 사실은 그렇지 않다. `bar`는 여전히 바깥 렉시컬 환경인 `foo`의 렉시컬 환경을 계속 참조하고 있고, 이 `bar`는 `baz`가 여전히 참조하고 있기 때문이다. **(`baz`(=`bar`) → `foo`)**

## 클로저 활용 사례

클로저는 자신이 생성될 때의 렉시컬 환경을 기억해야 하므로 메모리 차원에서 손해를 볼 수 있다.

하지만 클로저는 자바스크립트의 강력한 기능으로 이를 적극적으로 사용해야 한다.

### 1. 접근 권한 제어 및 상태 유지

클로저가 가장 유용하게 사용되는 상황은 **전역 변수를 사용하지 않고도 현재 상태를 기억하고 변경된 최신 상태를 유지**하는 것이다.

먼저, 자바스크립트는 변수 자체에 접근 권한을 직접 부여할 수 있는 접근 제한자가 없다. (ex. `public`, `private`, `protected`)

클로저를 이용하면 함수 차원에서 `public`과 `private`을 구분할 수 있다. 즉, `캡슐화`를 할 수 있다.

값에 1을 더하는 함수를 만든다고 생각해보자.

- 값은 이전 상태를 기억해야한다.
- 변수는 전역 변수에 선언하지 않는다.

우선 조건은 생각하지 않고 구현해보자.

**단순하게 구현하기**

```jsx
/* 전역 변수의 사용 */
var x = 10;

function addNum() {
  return ++x;
}

console.log(addNum()); // 11
console.log(addNum()); // 12
```

변수 `x`를 전역으로 선언하였고, `addNum` 함수는 `x`를 1씩 증가시킨다.

`addNum` 함수가 외부의 상태(`x`)를 변경하는 것이 마음에 들지 않는다. (`순수 함수`가 아니다.)

**순수 함수로 바꾸기**

```jsx
/* 순수 함수 */

var x = 10;

// x의 변화에 관여하지 않는다.
function addNum(num) {
  return ++num;
}
// ES6
// var addNum = (num) => ++num;

console.log(addNum(x)); // 11
console.log(addNum(x)); // 11

// 12를 만들기 위해서는
console.log(addNum(addNum(x))); // 12
```

`addNum` 함수가 순수함수가 되니, 자연스레 외부의 상태를 변경하지 않는다.

그러다보니 `x`의 변화에 관여하지 않으므로, `x`의 상태는 이전 상태를 유지할 수 없어 12를 만들기 위해 함수를 연속적으로 호출하는 방법밖에 없다.

**클로저 활용하기**

**클로저를 활용하면 `x`를 전역 변수로 두지 않아도 되며, 이전 상태를 유지할 수 있다.**

```jsx
/* 클로저 : 전역 변수를 사용하지 않고 상태를 유지한다. */
function addNum() {
  var x = 10;

  function res() {
    return ++x;
  }
  return res;
}

var test = addNum();
console.log(test()); // 11
console.log(test()); // 12
```

지역 변수 `x`를 외부에서도 읽을 수 있게 되었다.

이처럼 외부에 제공하고자 하는 정보(`public`)은 return 하고, 내부에서만 사용할 정보(`private`)는 return 하지 않는 것으로 접근 권한 제어가 가능하다.

### 2. 콜백 함수 내부에서 외부 데이터 사용

### 3. 부분 적용 함수

부분 적용 함수는 n개의 인자를 받는 함수에 미리 m개의 인자만 넘겨 기억 시켜둔 후, 나중에 나머지 인자를 넘겨 원래 함수의 실행 결과를 얻을 수 있도록 하는 함수이다.

```jsx
const partial = function () {
  var originalPartialArgs = arguments;
  var func = originalPartialArgs[0];
  if (typeof func !== "function") {
    throw new Error("첫 번째 인자가 함수가 아닙니다.");
  }

  return function () {
    var partialArgs = Array.prototype.slice.call(originalPartialArgs, 1);
    var restArgs = Array.prototype.slice.call(arguments);
    return func.apply(this, partialArgs.concat(restArgs));
  };
};

const add = function () {
  let res = 0;
  for (let i = 0; i < arguments.length; i++) {
    res += arguments[i];
  }
  return res;
};

const addResult = partial(add, 1, 2, 3, 4, 5);
// 재실행 시, 원본 함수를 무조건 실행한다.
console.log(addResult(6, 7, 8, 9, 10));
```

대표적인 예시로 디바운스(debounce)가 있다.

디바운스

- 여러번 발생하는 이벤트에서 가장 마지막 이벤트만 을 실행되도록 만드는 개념.

```jsx
const debounce = (eventName, func, wait) => {
  let timerId = null;

  return function (event) {
    let self = this;
    clearTimeout(timerId);
    timerId = setTimeout(func.bind(self, event), wait);
  };
};

var wheelHandler = function (e) {
  console.log("휠 처리");
};

/* 디바운싱 적용 X */
// document.body.addEventListener("mousewheel", (e) => {
//   moveHandler(e);
// });

/* 디바운싱 적용 O */
// document.body.addEventListener(
//   "mousewheel",
//   debounce("wheel", moveHandler, 500)
// );
```

### 4. 커링 함수

커링 함수란 여러 개의 인자를 받는 함수를 하나의 인자만 받는 함수로 나눠서 순차적으로 호출될 수 있게 체인 형태로 구성한 것을 말한다.

클로저의 특징 중 하나인 이전 상태를 유지한다는 것을 이용하는 것을 볼 수 있다.

```jsx
function multiply(x) {
  return function (y) {
    return function (z) {
      return x * y * z;
    };
  };
}

var resA = multiply(3); // 실행 결과를 기억
var resB = resA(2); // 실행 결과를 기억
var resC = resB(4); // 모든 인자가 다 들어왔으므로 a*b*c가 리턴된다.

// 모든 인자가 들어와야 결과가 출력된다.
console.log(resA); // [Function (anonymous)]
console.log(resB); // [Function (anonymous)]
console.log(resC); // 24
```

```jsx
const multiply = (a) => (b) => (c) => a * b * c;

var resA = multiply(3); // 실행 결과를 기억
var resB = resA(2); // 실행 결과를 기억
var resC = resB(4); // 모든 인자가 다 들어왔으므로 a*b*c가 리턴된다.

// 모든 인자가 들어와야 결과가 출력된다.
console.log(resA); // [Function (anonymous)]
console.log(resB); // [Function (anonymous)]
console.log(resC); // 24
```

### 번외. React.useState()에서 클로저 사용

주의! 단순한 개념적 모델이다.

```jsx
const useState = (initValue) => {
  let currentState = initValue;

  const state = () => currentState; // 함수

  const setState = (newValue) => {
    currentState = newValue;
  };

  return [state, setState];
};

const [num, setNum] = useState(10);
console.log(num()); // 10
setNum(100);
console.log(num()); // 100
```
