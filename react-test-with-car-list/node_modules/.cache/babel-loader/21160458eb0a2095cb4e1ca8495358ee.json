{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BatchInterceptor = void 0;\n\nvar Interceptor_1 = require(\"./Interceptor\");\n/**\n * A batch interceptor that exposes a single interface\n * to apply and operate with multiple interceptors at once.\n */\n\n\nvar BatchInterceptor =\n/** @class */\nfunction (_super) {\n  __extends(BatchInterceptor, _super);\n\n  function BatchInterceptor(options) {\n    var _this = this;\n\n    BatchInterceptor.symbol = Symbol(options.name);\n    _this = _super.call(this, BatchInterceptor.symbol) || this;\n    _this.interceptors = options.interceptors;\n    return _this;\n  }\n\n  BatchInterceptor.prototype.setup = function () {\n    var e_1, _a;\n\n    var log = this.log.extend('setup');\n    log('applying all %d interceptors...', this.interceptors.length);\n\n    var _loop_1 = function (interceptor) {\n      log('applying \"%s\" interceptor...', interceptor.constructor.name);\n      interceptor.apply();\n      log('adding interceptor dispose subscription');\n      this_1.subscriptions.push(function () {\n        return interceptor.dispose();\n      });\n    };\n\n    var this_1 = this;\n\n    try {\n      for (var _b = __values(this.interceptors), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var interceptor = _c.value;\n\n        _loop_1(interceptor);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  BatchInterceptor.prototype.on = function (event, listener) {\n    // Instead of adding a listener to the batch interceptor,\n    // propagate the listener to each of the individual interceptors.\n    this.interceptors.forEach(function (interceptor) {\n      interceptor.on(event, listener);\n    });\n  };\n\n  return BatchInterceptor;\n}(Interceptor_1.Interceptor);\n\nexports.BatchInterceptor = BatchInterceptor;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AAgBA;;;;;;AAIA;AAAA;AAAA;EAGUA;;EAKR,0BAAYC,OAAZ,EAA6D;IAA7D;;IACEC,gBAAgB,CAACC,MAAjB,GAA0BC,MAAM,CAACH,OAAO,CAACI,IAAT,CAAhC;IACAC,0BAAMJ,gBAAgB,CAACC,MAAvB,KAA8B,IAA9B;IACAG,KAAI,CAACC,YAAL,GAAoBN,OAAO,CAACM,YAA5B;;EACD;;EAESL,mCAAV;;;IACE,IAAMM,GAAG,GAAG,KAAKA,GAAL,CAASC,MAAT,CAAgB,OAAhB,CAAZ;IAEAD,GAAG,CAAC,iCAAD,EAAoC,KAAKD,YAAL,CAAkBG,MAAtD,CAAH;;4BAEWC,aAAW;MACpBH,GAAG,CAAC,8BAAD,EAAiCG,WAAW,CAACC,WAAZ,CAAwBP,IAAzD,CAAH;MACAM,WAAW,CAACE,KAAZ;MAEAL,GAAG,CAAC,yCAAD,CAAH;MACAM,OAAKC,aAAL,CAAmBC,IAAnB,CAAwB;QAAM,kBAAW,CAACC,OAAZ;MAAqB,CAAnD;;;;;;MALF,KAA0B,uBAAKV,YAAL,GAAiBW,cAA3C,EAA2C,QAA3C,EAA2CA,cAA3C,EAA2C;QAAtC,IAAMP,WAAW,WAAjB;;gBAAMA;MAMV;;;;;;;;;;;;EACF,CAZS;;EAcHT,gCAAP,UACEiB,KADF,EAEEC,QAFF,EAE2B;IAEzB;IACA;IACA,KAAKb,YAAL,CAAkBc,OAAlB,CAA0B,UAACV,WAAD,EAAY;MACpCA,WAAW,CAACW,EAAZ,CAAeH,KAAf,EAAsBC,QAAtB;IACD,CAFD;EAGD,CATM;;EAUT;AAAC,CAtCD,CAGUG,yBAHV;;AAAaC","names":["__extends","options","BatchInterceptor","symbol","Symbol","name","_this","interceptors","log","extend","length","interceptor","constructor","apply","this_1","subscriptions","push","dispose","_c","event","listener","forEach","on","Interceptor_1","exports"],"sources":["/Users/donghyun/Desktop/lewns2/node_modules/@mswjs/interceptors/src/BatchInterceptor.ts"],"sourcesContent":["import { EventMapType } from 'strict-event-emitter'\nimport { ExtractEventNames, Interceptor } from './Interceptor'\n\nexport interface BatchInterceptorOptions<\n  InterceptorList extends Interceptor<any>[]\n> {\n  name: string\n  interceptors: InterceptorList\n}\n\nexport type ExtractEventMapType<InterceptorList extends Interceptor<any>[]> =\n  InterceptorList extends Array<infer InterceptorType>\n    ? InterceptorType extends Interceptor<infer EventMap>\n      ? EventMap\n      : never\n    : never\n\n/**\n * A batch interceptor that exposes a single interface\n * to apply and operate with multiple interceptors at once.\n */\nexport class BatchInterceptor<\n  InterceptorList extends Interceptor<any>[],\n  EventMap extends EventMapType = ExtractEventMapType<InterceptorList>\n> extends Interceptor<EventMap> {\n  static symbol: Symbol\n\n  private interceptors: InterceptorList\n\n  constructor(options: BatchInterceptorOptions<InterceptorList>) {\n    BatchInterceptor.symbol = Symbol(options.name)\n    super(BatchInterceptor.symbol)\n    this.interceptors = options.interceptors\n  }\n\n  protected setup() {\n    const log = this.log.extend('setup')\n\n    log('applying all %d interceptors...', this.interceptors.length)\n\n    for (const interceptor of this.interceptors) {\n      log('applying \"%s\" interceptor...', interceptor.constructor.name)\n      interceptor.apply()\n\n      log('adding interceptor dispose subscription')\n      this.subscriptions.push(() => interceptor.dispose())\n    }\n  }\n\n  public on<Event extends ExtractEventNames<EventMap>>(\n    event: Event,\n    listener: EventMap[Event]\n  ) {\n    // Instead of adding a listener to the batch interceptor,\n    // propagate the listener to each of the individual interceptors.\n    this.interceptors.forEach((interceptor) => {\n      interceptor.on(event, listener)\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}