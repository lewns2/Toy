{"ast":null,"code":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nvar __objRest = (source, exclude) => {\n  var target = {};\n\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\n\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n\n  return to;\n};\n\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\n\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod); // src/index.ts\n\n\nvar src_exports = {};\n\n__export(src_exports, {\n  GraphQLHandler: () => GraphQLHandler,\n  RESTMethods: () => RESTMethods,\n  RequestHandler: () => RequestHandler,\n  RestHandler: () => RestHandler,\n  cleanUrl: () => cleanUrl,\n  compose: () => compose,\n  context: () => context_exports,\n  createResponseComposition: () => createResponseComposition,\n  defaultContext: () => defaultContext,\n  defaultResponse: () => defaultResponse,\n  graphql: () => graphql,\n  graphqlContext: () => graphqlContext,\n  handleRequest: () => handleRequest,\n  matchRequestUrl: () => matchRequestUrl,\n  parseIsomorphicRequest: () => parseIsomorphicRequest,\n  response: () => response,\n  rest: () => rest,\n  restContext: () => restContext,\n  setupWorker: () => setupWorker\n});\n\nmodule.exports = __toCommonJS(src_exports); // src/context/index.ts\n\nvar context_exports = {};\n\n__export(context_exports, {\n  body: () => body,\n  cookie: () => cookie,\n  data: () => data,\n  delay: () => delay,\n  errors: () => errors,\n  extensions: () => extensions,\n  fetch: () => fetch,\n  json: () => json,\n  set: () => set,\n  status: () => status,\n  text: () => text,\n  xml: () => xml\n}); // src/context/status.ts\n\n\nvar import_codes = __toESM(require(\"statuses/codes.json\"));\n\nvar status = (statusCode, statusText) => {\n  return res => {\n    res.status = statusCode;\n    res.statusText = statusText || import_codes.default[String(statusCode)];\n    return res;\n  };\n}; // src/context/set.ts\n\n\nvar import_headers_polyfill = require(\"headers-polyfill\");\n\nfunction set() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return res => {\n    const [name, value] = args;\n\n    if (typeof name === \"string\") {\n      res.headers.append(name, value);\n    } else {\n      const headers = (0, import_headers_polyfill.objectToHeaders)(name);\n      headers.forEach((value2, name2) => {\n        res.headers.append(name2, value2);\n      });\n    }\n\n    return res;\n  };\n} // src/context/cookie.ts\n\n\nvar cookieUtils = __toESM(require(\"cookie\"));\n\nvar cookie = (name, value, options) => {\n  return res => {\n    const serializedCookie = cookieUtils.serialize(name, value, options);\n    res.headers.set(\"Set-Cookie\", serializedCookie);\n\n    if (typeof document !== \"undefined\") {\n      document.cookie = serializedCookie;\n    }\n\n    return res;\n  };\n}; // src/context/body.ts\n\n\nvar body = value => {\n  return res => {\n    res.body = value;\n    return res;\n  };\n}; // src/utils/internal/jsonParse.ts\n\n\nfunction jsonParse(value) {\n  try {\n    return JSON.parse(value);\n  } catch (error2) {\n    return void 0;\n  }\n} // src/utils/internal/isObject.ts\n\n\nfunction isObject(value) {\n  return value != null && typeof value === \"object\" && !Array.isArray(value);\n} // src/utils/internal/mergeRight.ts\n\n\nfunction mergeRight(left, right) {\n  return Object.entries(right).reduce((result, _ref) => {\n    let [key, rightValue] = _ref;\n    const leftValue = result[key];\n\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue);\n      return result;\n    }\n\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue);\n      return result;\n    }\n\n    result[key] = rightValue;\n    return result;\n  }, Object.assign({}, left));\n} // src/context/json.ts\n\n\nvar json = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"application/json\");\n    res.body = JSON.stringify(body2);\n    return res;\n  };\n}; // src/context/data.ts\n\n\nvar data = payload => {\n  return res => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      data: payload\n    });\n    return json(nextBody)(res);\n  };\n}; // src/context/extensions.ts\n\n\nvar extensions = payload => {\n  return res => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      extensions: payload\n    });\n    return json(nextBody)(res);\n  };\n}; // src/context/delay.ts\n\n\nvar import_is_node_process = require(\"is-node-process\");\n\nvar SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nvar MIN_SERVER_RESPONSE_TIME = 100;\nvar MAX_SERVER_RESPONSE_TIME = 400;\nvar NODE_SERVER_RESPONSE_TIME = 5;\n\nvar getRandomServerResponseTime = () => {\n  if ((0, import_is_node_process.isNodeProcess)()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n\n  return Math.floor(Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME);\n};\n\nvar delay = durationOrMode => {\n  return res => {\n    let delayTime;\n\n    if (typeof durationOrMode === \"string\") {\n      switch (durationOrMode) {\n        case \"infinite\":\n          {\n            delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n            break;\n          }\n\n        case \"real\":\n          {\n            delayTime = getRandomServerResponseTime();\n            break;\n          }\n\n        default:\n          {\n            throw new Error(`Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`);\n          }\n      }\n    } else if (typeof durationOrMode === \"undefined\") {\n      delayTime = getRandomServerResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(`Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`);\n      }\n\n      delayTime = durationOrMode;\n    }\n\n    res.delay = delayTime;\n    return res;\n  };\n}; // src/context/errors.ts\n\n\nvar errors = errorsList => {\n  return res => {\n    if (errorsList == null) {\n      return res;\n    }\n\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      errors: errorsList\n    });\n    return json(nextBody)(res);\n  };\n}; // src/context/fetch.ts\n\n\nvar import_is_node_process2 = require(\"is-node-process\");\n\nvar import_headers_polyfill2 = require(\"headers-polyfill\");\n\nvar useFetch = (0, import_is_node_process2.isNodeProcess)() ? require(\"node-fetch\") : window.fetch;\n\nvar augmentRequestInit = requestInit => {\n  const headers = new import_headers_polyfill2.Headers(requestInit.headers);\n  headers.set(\"x-msw-bypass\", \"true\");\n  return __spreadProps(__spreadValues({}, requestInit), {\n    headers: headers.all()\n  });\n};\n\nvar createFetchRequestParameters = input => {\n  const {\n    body: body2,\n    method\n  } = input;\n\n  const requestParameters = __spreadProps(__spreadValues({}, input), {\n    body: void 0\n  });\n\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    return requestParameters;\n  }\n\n  if (typeof body2 === \"object\" || typeof body2 === \"number\" || typeof body2 === \"boolean\") {\n    requestParameters.body = JSON.stringify(body2);\n  } else {\n    requestParameters.body = body2;\n  }\n\n  return requestParameters;\n};\n\nvar fetch = function (input) {\n  let requestInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof input === \"string\") {\n    return useFetch(input, augmentRequestInit(requestInit));\n  }\n\n  const requestParameters = createFetchRequestParameters(input);\n  const derivedRequestInit = augmentRequestInit(requestParameters);\n  return useFetch(input.url.href, derivedRequestInit);\n}; // src/context/text.ts\n\n\nvar text = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"text/plain\");\n    res.body = body2;\n    return res;\n  };\n}; // src/context/xml.ts\n\n\nvar xml = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"text/xml\");\n    res.body = body2;\n    return res;\n  };\n}; // src/setupWorker/setupWorker.ts\n\n\nvar import_is_node_process3 = require(\"is-node-process\");\n\nvar import_strict_event_emitter = require(\"strict-event-emitter\"); // src/setupWorker/start/createStartHandler.ts\n\n\nvar import_until4 = require(\"@open-draft/until\"); // src/setupWorker/start/utils/getWorkerInstance.ts\n\n\nvar import_until = require(\"@open-draft/until\"); // src/setupWorker/start/utils/getWorkerByRegistration.ts\n\n\nvar getWorkerByRegistration = (registration, absoluteWorkerUrl, findWorker) => {\n  const allStates = [registration.active, registration.installing, registration.waiting];\n  const existingStates = allStates.filter(Boolean);\n  const mockWorker = existingStates.find(worker => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl);\n  });\n  return mockWorker || null;\n}; // src/utils/url/getAbsoluteWorkerUrl.ts\n\n\nfunction getAbsoluteWorkerUrl(relativeUrl) {\n  return new URL(relativeUrl, location.origin).href;\n} // src/utils/internal/devUtils.ts\n\n\nvar import_outvariant = require(\"outvariant\");\n\nvar LIBRARY_PREFIX = \"[MSW]\";\n\nfunction formatMessage(message) {\n  for (var _len2 = arguments.length, positionals = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    positionals[_key2 - 1] = arguments[_key2];\n  }\n\n  const interpolatedMessage = (0, import_outvariant.format)(message, ...positionals);\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`;\n}\n\nfunction warn(message) {\n  for (var _len3 = arguments.length, positionals = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    positionals[_key3 - 1] = arguments[_key3];\n  }\n\n  console.warn(formatMessage(message, ...positionals));\n}\n\nfunction error(message) {\n  for (var _len4 = arguments.length, positionals = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    positionals[_key4 - 1] = arguments[_key4];\n  }\n\n  console.error(formatMessage(message, ...positionals));\n}\n\nvar devUtils = {\n  formatMessage,\n  warn,\n  error\n}; // src/setupWorker/start/utils/getWorkerInstance.ts\n\nvar getWorkerInstance = async function (url) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let findWorker = arguments.length > 2 ? arguments[2] : undefined;\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n  const mockRegistrations = await navigator.serviceWorker.getRegistrations().then(registrations => registrations.filter(registration => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)));\n\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    location.reload();\n  }\n\n  const [existingRegistration] = mockRegistrations;\n\n  if (existingRegistration) {\n    return existingRegistration.update().then(() => {\n      return [getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker), existingRegistration];\n    });\n  }\n\n  const [error2, instance] = await (0, import_until.until)(async () => {\n    const registration = await navigator.serviceWorker.register(url, options);\n    return [getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker), registration];\n  });\n\n  if (error2) {\n    const isWorkerMissing = error2.message.includes(\"(404)\");\n\n    if (isWorkerMissing) {\n      const scopeUrl = new URL((options == null ? void 0 : options.scope) || \"/\", location.href);\n      throw new Error(devUtils.formatMessage(`Failed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`));\n    }\n\n    throw new Error(devUtils.formatMessage(\"Failed to register the Service Worker:\\n\\n%s\", error2.message));\n  }\n\n  return instance;\n}; // src/setupWorker/start/utils/printStartMessage.ts\n\n\nfunction printStartMessage() {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (args.quiet) {\n    return;\n  }\n\n  const message = args.message || \"Mocking enabled.\";\n  console.groupCollapsed(`%c${devUtils.formatMessage(message)}`, \"color:orangered;font-weight:bold;\");\n  console.log(\"%cDocumentation: %chttps://mswjs.io/docs\", \"font-weight:bold\", \"font-weight:normal\");\n  console.log(\"Found an issue? https://github.com/mswjs/msw/issues\");\n\n  if (args.workerUrl) {\n    console.log(\"Worker script URL:\", args.workerUrl);\n  }\n\n  if (args.workerScope) {\n    console.log(\"Worker scope:\", args.workerScope);\n  }\n\n  console.groupEnd();\n} // src/setupWorker/start/utils/enableMocking.ts\n\n\nasync function enableMocking(context, options) {\n  var _a, _b;\n\n  context.workerChannel.send(\"MOCK_ACTIVATE\");\n  await context.events.once(\"MOCKING_ENABLED\");\n\n  if (context.isMockingEnabled) {\n    devUtils.warn(`Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`);\n    return;\n  }\n\n  context.isMockingEnabled = true;\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: (_a = context.registration) == null ? void 0 : _a.scope,\n    workerUrl: (_b = context.worker) == null ? void 0 : _b.scriptURL\n  });\n} // src/utils/createBroadcastChannel.ts\n\n\nvar createBroadcastChannel = event => {\n  const port = event.ports[0];\n  return {\n    send(message) {\n      if (port) {\n        port.postMessage(message);\n      }\n    }\n\n  };\n}; // src/utils/NetworkError.ts\n\n\nvar NetworkError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"NetworkError\";\n  }\n\n}; // src/utils/request/parseWorkerRequest.ts\n\nvar import_headers_polyfill6 = require(\"headers-polyfill\"); // src/handlers/RequestHandler.ts\n\n\nvar import_headers_polyfill4 = require(\"headers-polyfill\"); // src/response.ts\n\n\nvar import_headers_polyfill3 = require(\"headers-polyfill\"); // src/utils/internal/compose.ts\n\n\nfunction compose() {\n  for (var _len5 = arguments.length, fns = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    fns[_key5] = arguments[_key5];\n  }\n\n  return function () {\n    return fns.reduceRight((leftFn, rightFn) => {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, arguments.length <= 0 ? undefined : arguments[0]);\n  };\n} // src/response.ts\n\n\nvar defaultResponse = {\n  status: 200,\n  statusText: \"OK\",\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false\n};\nvar defaultResponseTransformers = [];\n\nfunction createResponseComposition(responseOverrides) {\n  let defaultTransformers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultResponseTransformers;\n  return async function () {\n    const initialResponse = Object.assign({}, defaultResponse, {\n      headers: new import_headers_polyfill3.Headers({\n        \"x-powered-by\": \"msw\"\n      })\n    }, responseOverrides);\n\n    for (var _len6 = arguments.length, transformers = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      transformers[_key6] = arguments[_key6];\n    }\n\n    const resolvedTransformers = [...defaultTransformers, ...transformers].filter(Boolean);\n    const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;\n    return resolvedResponse;\n  };\n}\n\nvar response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({\n    once: true\n  }),\n\n  networkError(message) {\n    throw new NetworkError(message);\n  }\n\n}); // src/utils/internal/getCallFrame.ts\n\nvar SOURCE_FRAME = /\\/msw\\/src\\/(.+)/;\nvar BUILD_FRAME = /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/;\n\nfunction getCallFrame(error2) {\n  const stack = error2.stack;\n\n  if (!stack) {\n    return;\n  }\n\n  const frames = stack.split(\"\\n\").slice(1);\n  const declarationFrame = frames.find(frame => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));\n  });\n\n  if (!declarationFrame) {\n    return;\n  }\n\n  const declarationPath = declarationFrame.replace(/\\s*at [^()]*\\(([^)]+)\\)/, \"$1\").replace(/^@/, \"\");\n  return declarationPath;\n} // src/utils/internal/isIterable.ts\n\n\nfunction isIterable(fn) {\n  if (!fn) {\n    return false;\n  }\n\n  return typeof fn[Symbol.iterator] == \"function\";\n} // src/handlers/RequestHandler.ts\n\n\nvar defaultContext = {\n  status,\n  set,\n  delay,\n  fetch\n};\nvar RequestHandler = class {\n  constructor(options) {\n    this.shouldSkip = false;\n    this.ctx = options.ctx || defaultContext;\n    this.resolver = options.resolver;\n    const callFrame = getCallFrame(new Error());\n    this.info = __spreadProps(__spreadValues({}, options.info), {\n      callFrame\n    });\n  }\n\n  parse(_request, _resolutionContext) {\n    return null;\n  }\n\n  test(request, resolutionContext) {\n    return this.predicate(request, this.parse(request, resolutionContext), resolutionContext);\n  }\n\n  getPublicRequest(request, _parsedResult) {\n    return request;\n  }\n\n  markAsSkipped() {\n    let shouldSkip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.shouldSkip = shouldSkip;\n  }\n\n  async run(request, resolutionContext) {\n    if (this.shouldSkip) {\n      return null;\n    }\n\n    const parsedResult = this.parse(request, resolutionContext);\n    const shouldIntercept = this.predicate(request, parsedResult, resolutionContext);\n\n    if (!shouldIntercept) {\n      return null;\n    }\n\n    const publicRequest = this.getPublicRequest(request, parsedResult);\n    const executeResolver = this.wrapResolver(this.resolver);\n    const mockedResponse = await executeResolver(publicRequest, response, this.ctx);\n    return this.createExecutionResult(parsedResult, publicRequest, mockedResponse);\n  }\n\n  wrapResolver(resolver) {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || (await resolver(req, res, ctx));\n\n      if (isIterable(result)) {\n        const {\n          value,\n          done\n        } = result[Symbol.iterator]().next();\n        const nextResponse = await value;\n\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult;\n        }\n\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result;\n        }\n\n        this.resolverGeneratorResult = nextResponse;\n        return nextResponse;\n      }\n\n      return result;\n    };\n  }\n\n  createExecutionResult(parsedResult, request, response2) {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response2 || null\n    };\n  }\n\n};\n\nfunction passthrough() {\n  return {\n    status: 101,\n    statusText: \"Continue\",\n    headers: new import_headers_polyfill4.Headers(),\n    body: null,\n    passthrough: true,\n    once: false\n  };\n} // src/utils/request/setRequestCookies.ts\n\n\nvar cookieUtils3 = __toESM(require(\"cookie\"));\n\nvar import_cookies = require(\"@mswjs/cookies\"); // src/utils/request/getRequestCookies.ts\n\n\nvar cookieUtils2 = __toESM(require(\"cookie\"));\n\nfunction getAllCookies() {\n  return cookieUtils2.parse(document.cookie);\n}\n\nfunction getRequestCookies(request) {\n  if (typeof document === \"undefined\" || typeof location === \"undefined\") {\n    return {};\n  }\n\n  switch (request.credentials) {\n    case \"same-origin\":\n      {\n        return location.origin === request.url.origin ? getAllCookies() : {};\n      }\n\n    case \"include\":\n      {\n        return getAllCookies();\n      }\n\n    default:\n      {\n        return {};\n      }\n  }\n} // src/utils/request/setRequestCookies.ts\n\n\nfunction setRequestCookies(request) {\n  var _a;\n\n  const requestCookiesString = request.headers.get(\"cookie\");\n  import_cookies.store.hydrate();\n  const cookiesFromStore = Array.from((_a = import_cookies.store.get(__spreadProps(__spreadValues({}, request), {\n    url: request.url.toString()\n  }))) == null ? void 0 : _a.entries()).reduce((cookies, _ref2) => {\n    let [name, {\n      value\n    }] = _ref2;\n    return Object.assign(cookies, {\n      [name.trim()]: value\n    });\n  }, {});\n  const cookiesFromDocument = getRequestCookies(request);\n\n  const forwardedCookies = __spreadValues(__spreadValues({}, cookiesFromDocument), cookiesFromStore);\n\n  for (const [name, value] of Object.entries(forwardedCookies)) {\n    request.headers.append(\"cookie\", `${name}=${value}`);\n  }\n\n  const ownCookies = requestCookiesString ? cookieUtils3.parse(requestCookiesString) : {};\n  request.cookies = __spreadValues(__spreadValues(__spreadValues({}, request.cookies), forwardedCookies), ownCookies);\n} // src/utils/internal/parseMultipartData.ts\n\n\nvar import_headers_polyfill5 = require(\"headers-polyfill\");\n\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n\n  const headers = (0, import_headers_polyfill5.stringToHeaders)(headersString);\n  const contentType = headers.get(\"content-type\") || \"text/plain\";\n  const disposition = headers.get(\"content-disposition\");\n\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n\n  const directives = disposition.split(\";\").reduce((acc, chunk) => {\n    const [name2, ...rest2] = chunk.trim().split(\"=\");\n    acc[name2] = rest2.join(\"=\");\n    return acc;\n  }, {});\n  const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\n\nfunction parseMultipartData(data2, headers) {\n  const contentType = headers == null ? void 0 : headers.get(\"content-type\");\n\n  if (!contentType) {\n    return void 0;\n  }\n\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter(d => d.startsWith(\"boundary=\")).map(s => s.replace(/^boundary=/, \"\"))[0];\n\n  if (!boundary) {\n    return void 0;\n  }\n\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data2.split(boundaryRegExp).filter(chunk => chunk.startsWith(\"\\r\\n\") && chunk.endsWith(\"\\r\\n\")).map(chunk => chunk.trimStart().replace(/\\r\\n$/, \"\"));\n\n  if (!fields.length) {\n    return void 0;\n  }\n\n  const parsedBody = {};\n\n  try {\n    for (const field2 of fields) {\n      const [contentHeaders, ...rest2] = field2.split(\"\\r\\n\\r\\n\");\n      const contentBody = rest2.join(\"\\r\\n\\r\\n\");\n      const {\n        contentType: contentType2,\n        filename,\n        name\n      } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, {\n        type: contentType2\n      });\n      const parsedValue = parsedBody[name];\n\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n\n    return parsedBody;\n  } catch (error2) {\n    return void 0;\n  }\n} // src/utils/request/parseBody.ts\n\n\nfunction parseBody(body2, headers) {\n  var _a;\n\n  if (!body2) {\n    return body2;\n  }\n\n  const contentType = ((_a = headers == null ? void 0 : headers.get(\"content-type\")) == null ? void 0 : _a.toLowerCase()) || \"\";\n  const hasMultipartContent = contentType.startsWith(\"multipart/form-data\");\n\n  if (hasMultipartContent && typeof body2 !== \"object\") {\n    return parseMultipartData(body2.toString(), headers) || body2;\n  }\n\n  const hasJsonContent = contentType.includes(\"json\");\n\n  if (hasJsonContent && typeof body2 !== \"object\") {\n    return jsonParse(body2.toString()) || body2;\n  }\n\n  return body2;\n} // src/utils/internal/isStringEqual.ts\n\n\nfunction isStringEqual(actual, expected) {\n  return actual.toLowerCase() === expected.toLowerCase();\n} // src/utils/request/pruneGetRequestBody.ts\n\n\nfunction pruneGetRequestBody(request) {\n  if (request.method && isStringEqual(request.method, \"GET\") && request.body === \"\") {\n    return void 0;\n  }\n\n  return request.body;\n} // src/utils/request/parseWorkerRequest.ts\n\n\nfunction parseWorkerRequest(rawRequest) {\n  const request = {\n    id: rawRequest.id,\n    cache: rawRequest.cache,\n    credentials: rawRequest.credentials,\n    method: rawRequest.method,\n    url: new URL(rawRequest.url),\n    referrer: rawRequest.referrer,\n    referrerPolicy: rawRequest.referrerPolicy,\n    redirect: rawRequest.redirect,\n    mode: rawRequest.mode,\n    params: {},\n    cookies: {},\n    integrity: rawRequest.integrity,\n    keepalive: rawRequest.keepalive,\n    destination: rawRequest.destination,\n    body: pruneGetRequestBody(rawRequest),\n    bodyUsed: rawRequest.bodyUsed,\n    headers: new import_headers_polyfill6.Headers(rawRequest.headers),\n    passthrough\n  };\n  setRequestCookies(request);\n  request.body = parseBody(request.body, request.headers);\n  return request;\n} // src/utils/handleRequest.ts\n\n\nvar import_until2 = require(\"@open-draft/until\"); // src/utils/getResponse.ts\n\n\nvar getResponse = async (request, handlers, resolutionContext) => {\n  const relevantHandlers = handlers.filter(handler => {\n    return handler.test(request, resolutionContext);\n  });\n\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n\n  const result = await relevantHandlers.reduce(async (executionResult, handler) => {\n    const previousResults = await executionResult;\n\n    if (!!(previousResults == null ? void 0 : previousResults.response)) {\n      return executionResult;\n    }\n\n    const result2 = await handler.run(request, resolutionContext);\n\n    if (result2 === null || result2.handler.shouldSkip) {\n      return null;\n    }\n\n    if (!result2.response) {\n      return {\n        request: result2.request,\n        handler: result2.handler,\n        response: void 0,\n        parsedResult: result2.parsedResult\n      };\n    }\n\n    if (result2.response.once) {\n      handler.markAsSkipped(true);\n    }\n\n    return result2;\n  }, Promise.resolve(null));\n\n  if (!result) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response\n  };\n}; // src/utils/request/onUnhandledRequest.ts\n\n\nvar import_js_levenshtein = __toESM(require(\"js-levenshtein\")); // src/utils/internal/parseGraphQLRequest.ts\n\n\nvar import_graphql = require(\"graphql\"); // src/utils/request/getPublicUrlFromRequest.ts\n\n\nvar getPublicUrlFromRequest = request => {\n  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(request.url.pathname, `${request.url.protocol}//${request.url.host}`).href;\n}; // src/utils/internal/parseGraphQLRequest.ts\n\n\nfunction parseDocumentNode(node) {\n  var _a;\n\n  const operationDef = node.definitions.find(def => {\n    return def.kind === \"OperationDefinition\";\n  });\n  return {\n    operationType: operationDef == null ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value\n  };\n}\n\nfunction parseQuery(query) {\n  try {\n    const ast = (0, import_graphql.parse)(query);\n    return parseDocumentNode(ast);\n  } catch (error2) {\n    return error2;\n  }\n}\n\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = {\n    variables\n  };\n\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`);\n    }\n\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(\".\").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`);\n        }\n\n        target = target[path];\n      }\n\n      target[lastPath] = files[key];\n    }\n  }\n\n  return operations.variables;\n}\n\nfunction getGraphQLInput(request) {\n  var _a, _b;\n\n  switch (request.method) {\n    case \"GET\":\n      {\n        const query = request.url.searchParams.get(\"query\");\n        const variables = request.url.searchParams.get(\"variables\") || \"\";\n        return {\n          query,\n          variables: jsonParse(variables)\n        };\n      }\n\n    case \"POST\":\n      {\n        if ((_a = request.body) == null ? void 0 : _a.query) {\n          const {\n            query,\n            variables\n          } = request.body;\n          return {\n            query,\n            variables\n          };\n        }\n\n        if ((_b = request.body) == null ? void 0 : _b.operations) {\n          const _c = request.body,\n                {\n            operations,\n            map\n          } = _c,\n                files = __objRest(_c, [\"operations\", \"map\"]);\n\n          const parsedOperations = jsonParse(operations) || {};\n\n          if (!parsedOperations.query) {\n            return null;\n          }\n\n          const parsedMap = jsonParse(map || \"\") || {};\n          const variables = parsedOperations.variables ? extractMultipartVariables(parsedOperations.variables, parsedMap, files) : {};\n          return {\n            query: parsedOperations.query,\n            variables\n          };\n        }\n      }\n\n    default:\n      return null;\n  }\n}\n\nfunction parseGraphQLRequest(request) {\n  const input = getGraphQLInput(request);\n\n  if (!input || !input.query) {\n    return void 0;\n  }\n\n  const {\n    query,\n    variables\n  } = input;\n  const parsedResult = parseQuery(query);\n\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    throw new Error(devUtils.formatMessage('Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s', request.method, requestPublicUrl, parsedResult.message));\n  }\n\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables\n  };\n} // src/utils/logging/getStatusCodeColor.ts\n\n\nfunction getStatusCodeColor(status2) {\n  if (status2 < 300) {\n    return \"#69AB32\"\n    /* Success */\n    ;\n  }\n\n  if (status2 < 400) {\n    return \"#F0BB4B\"\n    /* Warning */\n    ;\n  }\n\n  return \"#E95F5D\"\n  /* Danger */\n  ;\n} // src/utils/logging/getTimestamp.ts\n\n\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map(chunk => chunk.slice(0, 2)).map(chunk => chunk.padStart(2, \"0\")).join(\":\");\n} // src/utils/logging/prepareRequest.ts\n\n\nfunction prepareRequest(request) {\n  return __spreadProps(__spreadValues({}, request), {\n    headers: request.headers.all()\n  });\n} // src/utils/logging/prepareResponse.ts\n\n\nvar import_headers_polyfill7 = require(\"headers-polyfill\");\n\nfunction prepareResponse(res) {\n  const responseHeaders = (0, import_headers_polyfill7.objectToHeaders)(res.headers);\n  return __spreadProps(__spreadValues({}, res), {\n    body: parseBody(res.body, responseHeaders)\n  });\n} // src/utils/matching/matchRequestUrl.ts\n\n\nvar import_path_to_regexp = require(\"path-to-regexp\");\n\nvar import_getCleanUrl = require(\"@mswjs/interceptors/lib/utils/getCleanUrl\"); // src/utils/url/cleanUrl.ts\n\n\nvar REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g;\n\nfunction getSearchParams(path) {\n  return new URL(`/${path}`, \"http://localhost\").searchParams;\n}\n\nfunction cleanUrl(path) {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, \"\");\n} // src/utils/url/isAbsoluteUrl.ts\n\n\nfunction isAbsoluteUrl(url) {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n} // src/utils/url/getAbsoluteUrl.ts\n\n\nfunction getAbsoluteUrl(path, baseUrl) {\n  if (isAbsoluteUrl(path)) {\n    return path;\n  }\n\n  if (path.startsWith(\"*\")) {\n    return path;\n  }\n\n  const origin = baseUrl || typeof document !== \"undefined\" && document.baseURI;\n  return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;\n} // src/utils/matching/normalizePath.ts\n\n\nfunction normalizePath(path, baseUrl) {\n  if (path instanceof RegExp) {\n    return path;\n  }\n\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);\n  return cleanUrl(maybeAbsoluteUrl);\n} // src/utils/matching/matchRequestUrl.ts\n\n\nfunction coercePath(path) {\n  return path.replace(/([:a-zA-Z_-]*)(\\*{1,2})+/g, (_, parameterName, wildcard) => {\n    const expression = \"(.*)\";\n\n    if (!parameterName) {\n      return expression;\n    }\n\n    return parameterName.startsWith(\":\") ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;\n  }).replace(/([^\\/])(:)(?=\\d+)/, \"$1\\\\$2\").replace(/^([^\\/]+)(:)(?=\\/\\/)/, \"$1\\\\$2\");\n}\n\nfunction matchRequestUrl(url, path, baseUrl) {\n  const normalizedPath = normalizePath(path, baseUrl);\n  const cleanPath = typeof normalizedPath === \"string\" ? coercePath(normalizedPath) : normalizedPath;\n  const cleanUrl2 = (0, import_getCleanUrl.getCleanUrl)(url);\n  const result = (0, import_path_to_regexp.match)(cleanPath, {\n    decode: decodeURIComponent\n  })(cleanUrl2);\n  const params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params\n  };\n} // src/handlers/RestHandler.ts\n\n\nvar RESTMethods = /* @__PURE__ */(RESTMethods2 => {\n  RESTMethods2[\"HEAD\"] = \"HEAD\";\n  RESTMethods2[\"GET\"] = \"GET\";\n  RESTMethods2[\"POST\"] = \"POST\";\n  RESTMethods2[\"PUT\"] = \"PUT\";\n  RESTMethods2[\"PATCH\"] = \"PATCH\";\n  RESTMethods2[\"OPTIONS\"] = \"OPTIONS\";\n  RESTMethods2[\"DELETE\"] = \"DELETE\";\n  return RESTMethods2;\n})(RESTMethods || {});\n\nvar restContext = __spreadProps(__spreadValues({}, defaultContext), {\n  cookie,\n  body,\n  text,\n  json,\n  xml\n});\n\nvar RestHandler = class extends RequestHandler {\n  constructor(method, path, resolver) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method\n      },\n      ctx: restContext,\n      resolver\n    });\n    this.checkRedundantQueryParameters();\n  }\n\n  checkRedundantQueryParameters() {\n    const {\n      method,\n      path\n    } = this.info;\n\n    if (path instanceof RegExp) {\n      return;\n    }\n\n    const url = cleanUrl(path);\n\n    if (url === path) {\n      return;\n    }\n\n    const searchParams = getSearchParams(path);\n    const queryParams = [];\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName);\n    });\n    devUtils.warn(`Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`);\n  }\n\n  parse(request, resolutionContext) {\n    return matchRequestUrl(request.url, this.info.path, resolutionContext == null ? void 0 : resolutionContext.baseUrl);\n  }\n\n  getPublicRequest(request, parsedResult) {\n    return __spreadProps(__spreadValues({}, request), {\n      params: parsedResult.params || {}\n    });\n  }\n\n  predicate(request, parsedResult) {\n    const matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);\n    return matchesMethod && parsedResult.matches;\n  }\n\n  log(request, response2) {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    console.groupCollapsed(devUtils.formatMessage(\"%s %s %s (%c%s%c)\"), getTimestamp(), request.method, publicUrl, `color:${statusColor}`, `${response2.status} ${response2.statusText}`, \"color:inherit\");\n    console.log(\"Request\", loggedRequest);\n    console.log(\"Handler:\", {\n      mask: this.info.path,\n      resolver: this.resolver\n    });\n    console.log(\"Response\", loggedResponse);\n    console.groupEnd();\n  }\n\n}; // src/context/field.ts\n\nvar import_outvariant2 = require(\"outvariant\");\n\nvar field = (fieldName, fieldValue) => {\n  return res => {\n    validateFieldName(fieldName);\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      [fieldName]: fieldValue\n    });\n    return json(nextBody)(res);\n  };\n};\n\nfunction validateFieldName(fieldName) {\n  (0, import_outvariant2.invariant)(fieldName.trim() !== \"\", devUtils.formatMessage(\"Failed to set a custom field on a GraphQL response: field name cannot be empty.\"));\n  (0, import_outvariant2.invariant)(fieldName !== \"data\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?', fieldName));\n  (0, import_outvariant2.invariant)(fieldName !== \"errors\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?', fieldName));\n  (0, import_outvariant2.invariant)(fieldName !== \"extensions\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?', fieldName));\n} // src/utils/internal/tryCatch.ts\n\n\nfunction tryCatch(fn, onException) {\n  try {\n    const result = fn();\n    return result;\n  } catch (error2) {\n    onException == null ? void 0 : onException(error2);\n  }\n} // src/handlers/GraphQLHandler.ts\n\n\nvar graphqlContext = __spreadProps(__spreadValues({}, defaultContext), {\n  data,\n  extensions,\n  errors,\n  cookie,\n  field\n});\n\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n\n  return typeof value === \"object\" && \"kind\" in value && \"definitions\" in value;\n}\n\nvar GraphQLHandler = class extends RequestHandler {\n  constructor(operationType, operationName, endpoint, resolver) {\n    let resolvedOperationName = operationName;\n\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName);\n\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`);\n      }\n\n      if (!parsedNode.operationName) {\n        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`);\n      }\n\n      resolvedOperationName = parsedNode.operationName;\n    }\n\n    const header = operationType === \"all\" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      ctx: graphqlContext,\n      resolver\n    });\n    this.endpoint = endpoint;\n  }\n\n  parse(request) {\n    return tryCatch(() => parseGraphQLRequest(request), error2 => console.error(error2.message));\n  }\n\n  getPublicRequest(request, parsedResult) {\n    return __spreadProps(__spreadValues({}, request), {\n      variables: (parsedResult == null ? void 0 : parsedResult.variables) || {}\n    });\n  }\n\n  predicate(request, parsedResult) {\n    if (!parsedResult) {\n      return false;\n    }\n\n    if (!parsedResult.operationName && this.info.operationType !== \"all\") {\n      const publicUrl = getPublicUrlFromRequest(request);\n      devUtils.warn(`Failed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      `);\n      return false;\n    }\n\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);\n    const hasMatchingOperationType = this.info.operationType === \"all\" || parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || \"\") : parsedResult.operationName === this.info.operationName;\n    return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n\n  log(request, response2, handler, parsedRequest) {\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    const requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? `${parsedRequest == null ? void 0 : parsedRequest.operationType} ${parsedRequest == null ? void 0 : parsedRequest.operationName}` : `anonymous ${parsedRequest == null ? void 0 : parsedRequest.operationType}`;\n    console.groupCollapsed(devUtils.formatMessage(\"%s %s (%c%s%c)\"), getTimestamp(), `${requestInfo}`, `color:${statusColor}`, `${response2.status} ${response2.statusText}`, \"color:inherit\");\n    console.log(\"Request:\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response:\", loggedResponse);\n    console.groupEnd();\n  }\n\n}; // src/utils/request/onUnhandledRequest.ts\n\nvar MAX_MATCH_SCORE = 3;\nvar MAX_SUGGESTION_COUNT = 4;\nvar TYPE_MATCH_DELTA = 0.5;\n\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce((groups, handler) => {\n    if (handler instanceof RestHandler) {\n      groups.rest.push(handler);\n    }\n\n    if (handler instanceof GraphQLHandler) {\n      groups.graphql.push(handler);\n    }\n\n    return groups;\n  }, {\n    rest: [],\n    graphql: []\n  });\n}\n\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const {\n      path,\n      method\n    } = handler.info;\n\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n\n    const hasSameMethod = isStringEqual(request.method, method);\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = (0, import_js_levenshtein.default)(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\n\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === \"undefined\") {\n      return Infinity;\n    }\n\n    const {\n      operationType,\n      operationName\n    } = handler.info;\n\n    if (typeof operationName !== \"string\") {\n      return Infinity;\n    }\n\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = (0, import_js_levenshtein.default)(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\n\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort((_ref3, _ref4) => {\n    let [leftScore] = _ref3;\n    let [rightScore] = _ref4;\n    return leftScore - rightScore;\n  }).filter(_ref5 => {\n    let [score] = _ref5;\n    return score <= MAX_MATCH_SCORE;\n  }).slice(0, MAX_SUGGESTION_COUNT).map(_ref6 => {\n    let [, handler] = _ref6;\n    return handler;\n  });\n  return suggestedHandlers;\n}\n\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `Did you mean to request one of the following resources instead?\n\n${handlers.map(handler => `  \\u2022 ${handler.info.header}`).join(\"\\n\")}`;\n  }\n\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`;\n}\n\nfunction onUnhandledRequest(request, handlers) {\n  let strategy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"warn\";\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\n\n  function generateHandlerSuggestion() {\n    const handlerGroups = groupHandlersByType(handlers);\n    const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n    const suggestedHandlers = getSuggestedHandler(request, relevantHandlers, parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore());\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : \"\";\n  }\n\n  function generateUnhandledRequestMessage() {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;\n    const handlerSuggestion = generateHandlerSuggestion();\n    const messageTemplate = [`captured a request without a matching request handler:`, `  \\u2022 ${requestHeader}`, handlerSuggestion, `If you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`].filter(Boolean);\n    return messageTemplate.join(\"\\n\\n\");\n  }\n\n  function applyStrategy(strategy2) {\n    const message = generateUnhandledRequestMessage();\n\n    switch (strategy2) {\n      case \"error\":\n        {\n          devUtils.error(\"Error: %s\", message);\n          throw new Error(devUtils.formatMessage('Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'));\n        }\n\n      case \"warn\":\n        {\n          devUtils.warn(\"Warning: %s\", message);\n          break;\n        }\n\n      case \"bypass\":\n        break;\n\n      default:\n        throw new Error(devUtils.formatMessage('Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.', strategy2));\n    }\n  }\n\n  if (typeof strategy === \"function\") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, \"warn\"),\n      error: applyStrategy.bind(null, \"error\")\n    });\n    return;\n  }\n\n  applyStrategy(strategy);\n} // src/utils/request/readResponseCookies.ts\n\n\nvar import_cookies2 = require(\"@mswjs/cookies\");\n\nfunction readResponseCookies(request, response2) {\n  import_cookies2.store.add(__spreadProps(__spreadValues({}, request), {\n    url: request.url.toString()\n  }), response2);\n  import_cookies2.store.persist();\n} // src/utils/handleRequest.ts\n\n\nasync function handleRequest(request, handlers, options, emitter, handleRequestOptions) {\n  var _a, _b, _c, _d;\n\n  emitter.emit(\"request:start\", request);\n\n  if (request.headers.get(\"x-msw-bypass\") === \"true\") {\n    emitter.emit(\"request:end\", request);\n    (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);\n    return;\n  }\n\n  const [lookupError, lookupResult] = await (0, import_until2.until)(() => {\n    return getResponse(request, handlers, handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext);\n  });\n\n  if (lookupError) {\n    emitter.emit(\"unhandledException\", lookupError, request);\n    throw lookupError;\n  }\n\n  const {\n    handler,\n    response: response2\n  } = lookupResult;\n\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n    emitter.emit(\"request:unhandled\", request);\n    emitter.emit(\"request:end\", request);\n    (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);\n    return;\n  }\n\n  if (!response2) {\n    devUtils.warn(`Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\n\n  \\u2022 %s\n    %s`, response2, handler.info.header, handler.info.callFrame);\n    emitter.emit(\"request:end\", request);\n    (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);\n    return;\n  }\n\n  if (response2.passthrough) {\n    emitter.emit(\"request:end\", request);\n    (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);\n    return;\n  }\n\n  readResponseCookies(request, response2);\n  emitter.emit(\"request:match\", request);\n  return new Promise(resolve => {\n    var _a2, _b2, _c2;\n\n    const requiredLookupResult = lookupResult;\n    const transformedResponse = ((_a2 = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _a2.call(handleRequestOptions, response2)) || response2;\n    (_b2 = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _b2.call(handleRequestOptions, transformedResponse, requiredLookupResult);\n    setTimeout(() => {\n      var _a3;\n\n      (_a3 = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponseSent) == null ? void 0 : _a3.call(handleRequestOptions, transformedResponse, requiredLookupResult);\n      emitter.emit(\"request:end\", request);\n      resolve(transformedResponse);\n    }, (_c2 = response2.delay) != null ? _c2 : 0);\n  });\n} // src/utils/worker/createRequestListener.ts\n\n\nvar createRequestListener = (context, options) => {\n  return async (event, message) => {\n    const channel = createBroadcastChannel(event);\n\n    try {\n      const request = parseWorkerRequest(message.payload);\n      await handleRequest(request, context.requestHandlers, options, context.emitter, {\n        transformResponse,\n\n        onPassthroughResponse() {\n          return channel.send({\n            type: \"MOCK_NOT_FOUND\"\n          });\n        },\n\n        onMockedResponse(response2) {\n          channel.send({\n            type: \"MOCK_SUCCESS\",\n            payload: response2\n          });\n        },\n\n        onMockedResponseSent(response2, _ref7) {\n          let {\n            handler,\n            publicRequest,\n            parsedRequest\n          } = _ref7;\n\n          if (options.quiet) {\n            return;\n          }\n\n          handler.log(publicRequest, response2, handler, parsedRequest);\n        }\n\n      });\n    } catch (error2) {\n      if (error2 instanceof NetworkError) {\n        return channel.send({\n          type: \"NETWORK_ERROR\",\n          payload: {\n            name: error2.name,\n            message: error2.message\n          }\n        });\n      }\n\n      if (error2 instanceof Error) {\n        channel.send({\n          type: \"INTERNAL_ERROR\",\n          payload: {\n            status: 500,\n            body: JSON.stringify({\n              errorType: error2.constructor.name,\n              message: error2.message,\n              location: error2.stack\n            })\n          }\n        });\n      }\n    }\n  };\n};\n\nfunction transformResponse(response2) {\n  return {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: response2.headers.all(),\n    body: response2.body,\n    delay: response2.delay\n  };\n} // src/utils/internal/requestIntegrityCheck.ts\n\n\nasync function requestIntegrityCheck(context, serviceWorker) {\n  context.workerChannel.send(\"INTEGRITY_CHECK_REQUEST\");\n  const {\n    payload: actualChecksum\n  } = await context.events.once(\"INTEGRITY_CHECK_RESPONSE\");\n\n  if (actualChecksum !== \"02f4ad4a2797f85668baf196e553d929\") {\n    throw new Error(`Currently active Service Worker (${actualChecksum}) is behind the latest published one (${\"02f4ad4a2797f85668baf196e553d929\"}).`);\n  }\n\n  return serviceWorker;\n} // src/utils/deferNetworkRequestsUntil.ts\n\n\nvar import_until3 = require(\"@open-draft/until\");\n\nfunction deferNetworkRequestsUntil(predicatePromise) {\n  const originalXhrSend = window.XMLHttpRequest.prototype.send;\n\n  window.XMLHttpRequest.prototype.send = function () {\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    (0, import_until3.until)(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend;\n      this.send(...args);\n    });\n  };\n\n  const originalFetch = window.fetch;\n\n  window.fetch = async function () {\n    await (0, import_until3.until)(() => predicatePromise);\n    window.fetch = originalFetch;\n    return window.fetch(...arguments);\n  };\n} // src/utils/worker/createResponseListener.ts\n\n\nfunction createResponseListener(context) {\n  return (_, message) => {\n    var _a;\n\n    const {\n      payload: responseJson\n    } = message;\n\n    if ((_a = responseJson.type) == null ? void 0 : _a.includes(\"opaque\")) {\n      return;\n    }\n\n    const response2 = new Response(responseJson.body || null, responseJson);\n    const isMockedResponse = response2.headers.get(\"x-powered-by\") === \"msw\";\n\n    if (isMockedResponse) {\n      context.emitter.emit(\"response:mocked\", response2, responseJson.requestId);\n    } else {\n      context.emitter.emit(\"response:bypass\", response2, responseJson.requestId);\n    }\n  };\n} // src/setupWorker/start/utils/validateWorkerScope.ts\n\n\nfunction validateWorkerScope(registration, options) {\n  if (!(options == null ? void 0 : options.quiet) && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(`Cannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.`);\n  }\n} // src/setupWorker/start/createStartHandler.ts\n\n\nvar createStartHandler = context => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      context.events.removeAllListeners();\n      context.workerChannel.on(\"REQUEST\", createRequestListener(context, options));\n      context.workerChannel.on(\"RESPONSE\", createResponseListener(context));\n      const instance = await getWorkerInstance(options.serviceWorker.url, options.serviceWorker.options, options.findWorker);\n      const [worker, registration] = instance;\n\n      if (!worker) {\n        const missingWorkerMessage = (customOptions == null ? void 0 : customOptions.findWorker) ? devUtils.formatMessage(`Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`, options.serviceWorker.url) : devUtils.formatMessage(`Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`, options.serviceWorker.url, location.host);\n        throw new Error(missingWorkerMessage);\n      }\n\n      context.worker = worker;\n      context.registration = registration;\n      context.events.addListener(window, \"beforeunload\", () => {\n        if (worker.state !== \"redundant\") {\n          context.workerChannel.send(\"CLIENT_CLOSED\");\n        }\n\n        window.clearInterval(context.keepAliveInterval);\n      });\n      const [integrityError] = await (0, import_until4.until)(() => requestIntegrityCheck(context, worker));\n\n      if (integrityError) {\n        devUtils.error(`Detected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues      `);\n      }\n\n      context.keepAliveInterval = window.setInterval(() => context.workerChannel.send(\"KEEPALIVE_REQUEST\"), 5e3);\n      validateWorkerScope(registration, context.startOptions);\n      return registration;\n    };\n\n    const workerRegistration = startWorkerInstance().then(async registration => {\n      const pendingInstance = registration.installing || registration.waiting;\n\n      if (pendingInstance) {\n        await new Promise(resolve => {\n          pendingInstance.addEventListener(\"statechange\", () => {\n            if (pendingInstance.state === \"activated\") {\n              return resolve();\n            }\n          });\n        });\n      }\n\n      await enableMocking(context, options).catch(error2 => {\n        throw new Error(`Failed to enable mocking: ${error2 == null ? void 0 : error2.message}`);\n      });\n      return registration;\n    });\n\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration);\n    }\n\n    return workerRegistration;\n  };\n}; // src/setupWorker/stop/utils/printStopMessage.ts\n\n\nfunction printStopMessage() {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (args.quiet) {\n    return;\n  }\n\n  console.log(`%c${devUtils.formatMessage(\"Mocking disabled.\")}`, \"color:orangered;font-weight:bold;\");\n} // src/setupWorker/stop/createStop.ts\n\n\nvar createStop = context => {\n  return function stop() {\n    var _a;\n\n    if (!context.isMockingEnabled) {\n      devUtils.warn('Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.');\n      return;\n    }\n\n    context.workerChannel.send(\"MOCK_DEACTIVATE\");\n    context.isMockingEnabled = false;\n    window.clearInterval(context.keepAliveInterval);\n    printStopMessage({\n      quiet: (_a = context.startOptions) == null ? void 0 : _a.quiet\n    });\n  };\n}; // src/utils/internal/requestHandlerUtils.ts\n\n\nfunction use(currentHandlers) {\n  for (var _len8 = arguments.length, handlers = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n    handlers[_key8 - 1] = arguments[_key8];\n  }\n\n  currentHandlers.unshift(...handlers);\n}\n\nfunction restoreHandlers(handlers) {\n  handlers.forEach(handler => {\n    handler.markAsSkipped(false);\n  });\n}\n\nfunction resetHandlers(initialHandlers) {\n  for (var _len9 = arguments.length, nextHandlers = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n    nextHandlers[_key9 - 1] = arguments[_key9];\n  }\n\n  return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers];\n} // src/setupWorker/start/utils/prepareStartHandler.ts\n\n\nvar DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: \"/mockServiceWorker.js\",\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: \"warn\",\n\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n\n};\n\nfunction resolveStartOptions(initialOptions) {\n  return mergeRight(DEFAULT_START_OPTIONS, initialOptions || {});\n}\n\nfunction prepareStartHandler(handler, context) {\n  return initialOptions => {\n    context.startOptions = resolveStartOptions(initialOptions);\n    return handler(context.startOptions, initialOptions || {});\n  };\n} // src/utils/worker/createFallbackRequestListener.ts\n\n\nvar import_interceptors = require(\"@mswjs/interceptors\");\n\nvar import_fetch3 = require(\"@mswjs/interceptors/lib/interceptors/fetch\");\n\nvar import_XMLHttpRequest = require(\"@mswjs/interceptors/lib/interceptors/XMLHttpRequest\"); // src/utils/request/parseIsomorphicRequest.ts\n\n\nfunction parseIsomorphicRequest(request) {\n  const mockedRequest = {\n    id: request.id,\n    url: request.url,\n    method: request.method,\n    body: parseBody(request.body, request.headers),\n    credentials: request.credentials || \"same-origin\",\n    headers: request.headers,\n    cookies: {},\n    redirect: \"manual\",\n    referrer: \"\",\n    keepalive: false,\n    cache: \"default\",\n    mode: \"cors\",\n    referrerPolicy: \"no-referrer\",\n    integrity: \"\",\n    destination: \"document\",\n    bodyUsed: false,\n    passthrough\n  };\n  setRequestCookies(mockedRequest);\n  return mockedRequest;\n} // src/utils/worker/createFallbackRequestListener.ts\n\n\nfunction createFallbackRequestListener(context, options) {\n  const interceptor = new import_interceptors.BatchInterceptor({\n    name: \"fallback\",\n    interceptors: [new import_fetch3.FetchInterceptor(), new import_XMLHttpRequest.XMLHttpRequestInterceptor()]\n  });\n  interceptor.on(\"request\", async request => {\n    const mockedRequest = parseIsomorphicRequest(request);\n    const response2 = await handleRequest(mockedRequest, context.requestHandlers, options, context.emitter, {\n      transformResponse(response3) {\n        return {\n          status: response3.status,\n          statusText: response3.statusText,\n          headers: response3.headers.all(),\n          body: response3.body,\n          delay: response3.delay\n        };\n      },\n\n      onMockedResponseSent(response3, _ref8) {\n        let {\n          handler,\n          publicRequest,\n          parsedRequest\n        } = _ref8;\n\n        if (!options.quiet) {\n          handler.log(publicRequest, response3, handler, parsedRequest);\n        }\n      }\n\n    });\n\n    if (response2) {\n      request.respondWith(response2);\n    }\n  });\n  interceptor.apply();\n  return interceptor;\n} // src/setupWorker/start/createFallbackStart.ts\n\n\nfunction createFallbackStart(context) {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(context, options);\n    printStartMessage({\n      message: \"Mocking enabled (fallback mode).\",\n      quiet: options.quiet\n    });\n    return void 0;\n  };\n} // src/setupWorker/stop/createFallbackStop.ts\n\n\nfunction createFallbackStop(context) {\n  return function stop() {\n    var _a, _b;\n\n    (_a = context.fallbackInterceptor) == null ? void 0 : _a.dispose();\n    printStopMessage({\n      quiet: (_b = context.startOptions) == null ? void 0 : _b.quiet\n    });\n  };\n} // src/utils/internal/pipeEvents.ts\n\n\nfunction pipeEvents(source, destination) {\n  const rawEmit = source.emit;\n\n  if (rawEmit._isPiped) {\n    return;\n  }\n\n  source.emit = function (event) {\n    for (var _len10 = arguments.length, data2 = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n      data2[_key10 - 1] = arguments[_key10];\n    }\n\n    destination.emit(event, ...data2);\n    return rawEmit.call(this, event, ...data2);\n  };\n\n  source.emit._isPiped = true;\n} // src/setupWorker/setupWorker.ts\n\n\nvar listeners = [];\n\nfunction setupWorker() {\n  for (var _len11 = arguments.length, requestHandlers = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n    requestHandlers[_key11] = arguments[_key11];\n  }\n\n  requestHandlers.forEach(handler => {\n    if (Array.isArray(handler)) throw new Error(devUtils.formatMessage('Failed to call \"setupWorker\" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).'));\n  });\n\n  if ((0, import_is_node_process3.isNodeProcess)()) {\n    throw new Error(devUtils.formatMessage(\"Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.\"));\n  }\n\n  const emitter = new import_strict_event_emitter.StrictEventEmitter();\n  const publicEmitter = new import_strict_event_emitter.StrictEventEmitter();\n  pipeEvents(emitter, publicEmitter);\n  const context = {\n    isMockingEnabled: false,\n    startOptions: void 0,\n    worker: null,\n    registration: null,\n    requestHandlers: [...requestHandlers],\n    emitter,\n    workerChannel: {\n      on(eventType, callback) {\n        context.events.addListener(navigator.serviceWorker, \"message\", event => {\n          if (event.source !== context.worker) {\n            return;\n          }\n\n          const message = jsonParse(event.data);\n\n          if (!message) {\n            return;\n          }\n\n          if (message.type === eventType) {\n            callback(event, message);\n          }\n        });\n      },\n\n      send(type) {\n        var _a;\n\n        (_a = context.worker) == null ? void 0 : _a.postMessage(type);\n      }\n\n    },\n    events: {\n      addListener(target, eventType, callback) {\n        target.addEventListener(eventType, callback);\n        listeners.push({\n          eventType,\n          target,\n          callback\n        });\n        return () => {\n          target.removeEventListener(eventType, callback);\n        };\n      },\n\n      removeAllListeners() {\n        for (const {\n          target,\n          eventType,\n          callback\n        } of listeners) {\n          target.removeEventListener(eventType, callback);\n        }\n\n        listeners = [];\n      },\n\n      once(eventType) {\n        const bindings = [];\n        return new Promise((resolve, reject) => {\n          const handleIncomingMessage = event => {\n            try {\n              const message = JSON.parse(event.data);\n\n              if (message.type === eventType) {\n                resolve(message);\n              }\n            } catch (error2) {\n              reject(error2);\n            }\n          };\n\n          bindings.push(context.events.addListener(navigator.serviceWorker, \"message\", handleIncomingMessage), context.events.addListener(navigator.serviceWorker, \"messageerror\", reject));\n        }).finally(() => {\n          bindings.forEach(unbind => unbind());\n        });\n      }\n\n    },\n    useFallbackMode: !(\"serviceWorker\" in navigator) || location.protocol === \"file:\"\n  };\n  const startHandler = context.useFallbackMode ? createFallbackStart(context) : createStartHandler(context);\n  const stopHandler = context.useFallbackMode ? createFallbackStop(context) : createStop(context);\n  return {\n    start: prepareStartHandler(startHandler, context),\n\n    stop() {\n      context.events.removeAllListeners();\n      context.emitter.removeAllListeners();\n      publicEmitter.removeAllListeners();\n      stopHandler();\n    },\n\n    use() {\n      for (var _len12 = arguments.length, handlers = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n        handlers[_key12] = arguments[_key12];\n      }\n\n      use(context.requestHandlers, ...handlers);\n    },\n\n    restoreHandlers() {\n      restoreHandlers(context.requestHandlers);\n    },\n\n    resetHandlers() {\n      for (var _len13 = arguments.length, nextHandlers = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        nextHandlers[_key13] = arguments[_key13];\n      }\n\n      context.requestHandlers = resetHandlers(requestHandlers, ...nextHandlers);\n    },\n\n    printHandlers() {\n      context.requestHandlers.forEach(handler => {\n        const {\n          header,\n          callFrame\n        } = handler.info;\n        const pragma = handler.info.hasOwnProperty(\"operationType\") ? \"[graphql]\" : \"[rest]\";\n        console.groupCollapsed(`${pragma} ${header}`);\n\n        if (callFrame) {\n          console.log(`Declaration: ${callFrame}`);\n        }\n\n        console.log(\"Handler:\", handler);\n\n        if (handler instanceof RestHandler) {\n          console.log(\"Match:\", `https://mswjs.io/repl?path=${handler.info.path}`);\n        }\n\n        console.groupEnd();\n      });\n    },\n\n    events: {\n      on() {\n        return publicEmitter.on(...arguments);\n      },\n\n      removeListener() {\n        return publicEmitter.removeListener(...arguments);\n      },\n\n      removeAllListeners() {\n        return publicEmitter.removeAllListeners(...arguments);\n      }\n\n    }\n  };\n} // src/rest.ts\n\n\nfunction createRestHandler(method) {\n  return (path, resolver) => {\n    return new RestHandler(method, path, resolver);\n  };\n}\n\nvar rest = {\n  all: createRestHandler(/.+/),\n  head: createRestHandler(\"HEAD\"\n  /* HEAD */\n  ),\n  get: createRestHandler(\"GET\"\n  /* GET */\n  ),\n  post: createRestHandler(\"POST\"\n  /* POST */\n  ),\n  put: createRestHandler(\"PUT\"\n  /* PUT */\n  ),\n  delete: createRestHandler(\"DELETE\"\n  /* DELETE */\n  ),\n  patch: createRestHandler(\"PATCH\"\n  /* PATCH */\n  ),\n  options: createRestHandler(\"OPTIONS\"\n  /* OPTIONS */\n  )\n}; // src/graphql.ts\n\nvar import_graphql2 = require(\"graphql\");\n\nfunction createScopedGraphQLHandler(operationType, url) {\n  return (operationName, resolver) => {\n    return new GraphQLHandler(operationType, operationName, url, resolver);\n  };\n}\n\nfunction createGraphQLOperationHandler(url) {\n  return resolver => {\n    return new GraphQLHandler(\"all\", new RegExp(\".*\"), url, resolver);\n  };\n}\n\nvar standardGraphQLHandlers = {\n  operation: createGraphQLOperationHandler(\"*\"),\n  query: createScopedGraphQLHandler(import_graphql2.OperationTypeNode.QUERY, \"*\"),\n  mutation: createScopedGraphQLHandler(import_graphql2.OperationTypeNode.MUTATION, \"*\")\n};\n\nfunction createGraphQLLink(url) {\n  return {\n    operation: createGraphQLOperationHandler(url),\n    query: createScopedGraphQLHandler(import_graphql2.OperationTypeNode.QUERY, url),\n    mutation: createScopedGraphQLHandler(import_graphql2.OperationTypeNode.MUTATION, url)\n  };\n}\n\nvar graphql = __spreadProps(__spreadValues({}, standardGraphQLHandlers), {\n  link: createGraphQLLink\n}); // Annotate the CommonJS export names for ESM import in node:\n\n\n0 && (module.exports = {\n  GraphQLHandler,\n  RESTMethods,\n  RequestHandler,\n  RestHandler,\n  cleanUrl,\n  compose,\n  context,\n  createResponseComposition,\n  defaultContext,\n  defaultResponse,\n  graphql,\n  graphqlContext,\n  handleRequest,\n  matchRequestUrl,\n  parseIsomorphicRequest,\n  response,\n  rest,\n  restContext,\n  setupWorker\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAAAA;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;AAAA;;AAAAC,2C;;ACAA;;AAAApB;EAAAqB;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;EAAAC;AAAA,G;;;ACAA,mBAAqBC,uCAArB;;AAUO,IAAMH,SAAS,CACpBI,UADoB,EAEpBC,UAFoB,KAGI;EACxB,OAAQC,GAAD,IAAS;IACdA,IAAIN,MAAJ,GAAaI,UAAb;IACAE,IAAID,UAAJ,GACEA,cAAcE,qBAASC,OAAOJ,UAAP,CAAT,CADhB;IAGA,OAAOE,GAAP;EACF,CANA;AAOF,CAXO,C;;;ACVP,8BAAgCG,2BAAhC;;AA8BO,eAUgB;EAAA,kCATlBC,IASkB;IATlBA,IASkB;EAAA;;EACrB,OAAQJ,GAAD,IAAS;IACd,MAAM,CAACK,IAAD,EAAOC,KAAP,IAAgBF,IAAtB;;IAEA,IAAI,OAAOC,IAAP,KAAgB,QAApB,EAA8B;MAC5BL,IAAIO,OAAJ,CAAYC,MAAZ,CAAmBH,IAAnB,EAAyBC,KAAzB;IACF,CAFA,MAEO;MACL,MAAMC,UAAU,6CAAgBF,IAAhB,CAAhB;MACAE,QAAQE,OAAR,CAAgB,CAACC,MAAD,EAAQC,KAAR,KAAiB;QAC/BX,IAAIO,OAAJ,CAAYC,MAAZ,CAAmBG,KAAnB,EAAyBD,MAAzB;MACD,CAFD;IAGF;;IAEA,OAAOV,GAAP;EACF,CAbA;AAcF,C;;;ACvDA,kBAA6BH,0BAA7B;;AAOO,IAAMX,SAAS,CACpBmB,IADoB,EAEpBC,KAFoB,EAGpBM,OAHoB,KAII;EACxB,OAAQZ,GAAD,IAAS;IACd,MAAMa,mBAAmBC,WAAY,UAAZ,CAAsBT,IAAtB,EAA4BC,KAA5B,EAAmCM,OAAnC,CAAzB;IACAZ,IAAIO,OAAJ,CAAYd,GAAZ,CAAgB,YAAhB,EAA8BoB,gBAA9B;;IAEA,IAAI,OAAOE,QAAP,KAAoB,WAAxB,EAAqC;MACnCA,SAAS7B,MAAT,GAAkB2B,gBAAlB;IACF;;IAEA,OAAOb,GAAP;EACF,CATA;AAUF,CAfO,C;;;ACEA,IAAMf,OAGXqB,KAHkB,IAIgB;EAClC,OAAQN,GAAD,IAAS;IACdA,IAAIf,IAAJ,GAAWqB,KAAX;IACA,OAAON,GAAP;EACF,CAHA;AAIF,CATO,C;;;ACLA,mBACLM,KADK,EAEkB;EACvB,IAAI;IACF,OAAOU,KAAKC,KAAL,CAAWX,KAAX,CAAP;EACF,CAFA,CAEA,OAASY,MAAT,EAAE;IACA,OAAO,MAAP;EACF;AACF,C;;;ACTO,kBAAkBZ,KAAlB,EAAuC;EAC5C,OAAOA,SAAS,IAAT,IAAiB,OAAOA,KAAP,KAAiB,QAAlC,IAA8C,CAACa,MAAMC,OAAN,CAAcd,KAAd,CAAtD;AACF,C;;;ACCO,oBACLe,IADK,EAELC,KAFK,EAGL;EACA,OAAOC,OAAOC,OAAP,CAAeF,KAAf,EAAsBG,MAAtB,CAA6B,CAACC,MAAD,WAA+B;IAAA,IAAtB,CAACC,GAAD,EAAMC,UAAN,CAAsB;IACjE,MAAMC,YAAYH,OAAOC,GAAP,CAAlB;;IAEA,IAAIR,MAAMC,OAAN,CAAcS,SAAd,KAA4BV,MAAMC,OAAN,CAAcQ,UAAd,CAAhC,EAA2D;MACzDF,OAAOC,GAAP,IAAcE,UAAUC,MAAV,CAAiBF,UAAjB,CAAd;MACA,OAAOF,MAAP;IACF;;IAEA,IAAIK,SAASF,SAAT,KAAuBE,SAASH,UAAT,CAA3B,EAAiD;MAC/CF,OAAOC,GAAP,IAAcK,WAAWH,SAAX,EAAsBD,UAAtB,CAAd;MACA,OAAOF,MAAP;IACF;;IAEAA,OAAOC,GAAP,IAAcC,UAAd;IACA,OAAOF,MAAP;EACF,CAfO,EAeJH,OAAOU,MAAP,CAAc,EAAd,EAAkBZ,IAAlB,CAfI,CAAP;AAgBF,C;;;ACdO,IAAM7B,OACX0C,KADkB,IAEoB;EACtC,OAAQlC,GAAD,IAAS;IACdA,IAAIO,OAAJ,CAAYd,GAAZ,CAAgB,cAAhB,EAAgC,kBAAhC;IACAO,IAAIf,IAAJ,GAAW+B,KAAKmB,SAAL,CAAeD,KAAf,CAAX;IAEA,OAAOlC,GAAP;EACF,CALA;AAMF,CATO,C;;;ACDA,IAAMb,OACXiD,OADkE,IAE/D;EACH,OAAQpC,GAAD,IAAS;IACd,MAAMqC,WAAWC,UAAUtC,IAAIf,IAAd,KAAuB,EAAxC;IACA,MAAMsD,WAAWP,WAAWK,QAAX,EAAqB;MAAElD,MAAMiD;IAAR,CAArB,CAAjB;IAEA,OAAO5C,KAAK+C,QAAL,EAAevC,GAAf,CAAP;EACF,CALA;AAMF,CATO,C;;;ACAA,IAAMV,aACX8C,OADwE,IAErE;EACH,OAAQpC,GAAD,IAAS;IACd,MAAMqC,WAAWC,UAAUtC,IAAIf,IAAd,KAAuB,EAAxC;IACA,MAAMsD,WAAWP,WAAWK,QAAX,EAAqB;MAAE/C,YAAY8C;IAAd,CAArB,CAAjB;IACA,OAAO5C,KAAK+C,QAAL,EAAevC,GAAf,CAAP;EACF,CAJA;AAKF,CARO,C;;;ACXP,6BAA8BG,0BAA9B;;AAGO,IAAMqC,8BAA8B,UAApC;AACA,IAAMC,2BAA2B,GAAjC;AACA,IAAMC,2BAA2B,GAAjC;AACA,IAAMC,4BAA4B,CAAlC;;AAEP,IAAMC,8BAA8B,MAAM;EACxC,IAAI,2CAAJ,EAAqB;IACnB,OAAOD,yBAAP;EACF;;EAEA,OAAOE,KAAKC,KAAL,CACLD,KAAKE,MAAL,MAAiBL,2BAA2BD,wBAA5C,IACEA,wBAFG,CAAP;AAIF,CATA;;AAqBO,IAAMrD,QACX4D,cADmB,IAEK;EACxB,OAAQhD,GAAD,IAAS;IACd,IAAIiD,SAAJ;;IAEA,IAAI,OAAOD,cAAP,KAA0B,QAA9B,EAAwC;MACtC,QAAQA,cAAR;QAAQ,KACD,UADC;UACW;YAGfC,YAAYT,2BAAZ;YACA;UACF;;QAAA,KACK,MADL;UACa;YACXS,YAAYL,6BAAZ;YACA;UACF;;QAAA;UACS;YACP,MAAM,IAAIM,KAAJ,CACJ,mDAAmDF,2HAD/C,CAAN;UAGF;MAfF;IAiBF,CAlBA,MAkBA,IAAW,OAAOA,cAAP,KAA0B,WAArC,EAAkD;MAEhDC,YAAYL,6BAAZ;IACF,CAHA,MAGO;MAGL,IAAII,iBAAiBR,2BAArB,EAAkD;QAChD,MAAM,IAAIU,KAAJ,CACJ,wDAAwDF,0EAA0ER,wPAD9H,CAAN;MAGF;;MAEAS,YAAYD,cAAZ;IACF;;IAEAhD,IAAIZ,KAAJ,GAAY6D,SAAZ;IACA,OAAOjD,GAAP;EACF,CAtCA;AAuCF,CA1CO,C;;;AClBA,IAAMX,SAGX8D,UAHoB,IAIY;EAChC,OAAQnD,GAAD,IAAS;IACd,IAAImD,cAAc,IAAlB,EAAwB;MACtB,OAAOnD,GAAP;IACF;;IAEA,MAAMqC,WAAWC,UAAUtC,IAAIf,IAAd,KAAuB,EAAxC;IACA,MAAMsD,WAAWP,WAAWK,QAAX,EAAqB;MAAEhD,QAAQ8D;IAAV,CAArB,CAAjB;IAEA,OAAO3D,KAAK+C,QAAL,EAAevC,GAAf,CAAP;EACF,CATA;AAUF,CAfO,C;;;ACXP,8BAA8BG,0BAA9B;;AACA,+BAAwBA,2BAAxB;;AAGA,IAAMiD,WACJ,+CAAkBjD,QAAQ,YAAR,CAAlB,GAA0CkD,OAAO9D,KADnD;;AAGO,IAAM+D,qBAAsBC,WAAD,IAA2C;EAC3E,MAAMhD,UAAU,IAAIiD,gCAAJ,CAAYD,YAAYhD,OAAxB,CAAhB;EACAA,QAAQd,GAAR,CAAY,cAAZ,EAA4B,MAA5B;EAEA,OAAOgE,iCACFF,WADE;IAELhD,SAASA,QAAQmD,GAAR;EAFJ,EAAP;AAIF,CARO;;AAUP,IAAMC,+BAAgCC,KAAD,IAAuC;EAC1E,MAAM;IAAE3E,WAAF;IAAQ4E;EAAR,IAAmBD,KAAzB;;EACA,MAAME,oBAAiCL,iCAClCG,KADkC;IAErC3E,MAAM;EAF+B,EAAvC;;EAKA,IAAI,CAAC,KAAD,EAAQ,MAAR,EAAgB8E,QAAhB,CAAyBF,MAAzB,CAAJ,EAAsC;IACpC,OAAOC,iBAAP;EACF;;EAEA,IACE,OAAO5B,KAAP,KAAgB,QAAhB,IACA,OAAOA,KAAP,KAAgB,QADhB,IAEA,OAAOA,KAAP,KAAgB,SAHlB,EAIE;IACA4B,kBAAkB7E,IAAlB,GAAyB+B,KAAKmB,SAAL,CAAeD,KAAf,CAAzB;EACF,CANA,MAMO;IACL4B,kBAAkB7E,IAAlB,GAAyBiD,KAAzB;EACF;;EAEA,OAAO4B,iBAAP;AACF,CAtBA;;AA8BO,IAAMvE,QAAQ,UACnBqE,KADmB,EAGG;EAAA,IADtBL,WACsB,uEADK,EACL;;EACtB,IAAI,OAAOK,KAAP,KAAiB,QAArB,EAA+B;IAC7B,OAAOR,SAASQ,KAAT,EAAgBN,mBAAmBC,WAAnB,CAAhB,CAAP;EACF;;EAEA,MAAMO,oBAAoBH,6BAA6BC,KAA7B,CAA1B;EACA,MAAMI,qBAAqBV,mBAAmBQ,iBAAnB,CAA3B;EAEA,OAAOV,SAASQ,MAAMK,GAAN,CAAUC,IAAnB,EAAyBF,kBAAzB,CAAP;AACF,CAZO,C;;;ACvCA,IAAMrE,OACXuC,KADkB,IAEgB;EAClC,OAAQlC,GAAD,IAAS;IACdA,IAAIO,OAAJ,CAAYd,GAAZ,CAAgB,cAAhB,EAAgC,YAAhC;IACAO,IAAIf,IAAJ,GAAWiD,KAAX;IACA,OAAOlC,GAAP;EACF,CAJA;AAKF,CARO,C;;;ACCA,IAAMJ,MACXsC,KADiB,IAEiB;EAClC,OAAQlC,GAAD,IAAS;IACdA,IAAIO,OAAJ,CAAYd,GAAZ,CAAgB,cAAhB,EAAgC,UAAhC;IACAO,IAAIf,IAAJ,GAAWiD,KAAX;IACA,OAAOlC,GAAP;EACF,CAJA;AAKF,CARO,C;;;ACTP,8BAA8BG,0BAA9B;;AACA,kCAAmCA,+BAAnC,C;;;ACDA,oBAAsBA,4BAAtB,C;;;ACAA,mBAAsBA,4BAAtB,C;;;ACMO,IAAMgE,0BAA0B,CACrCC,YADqC,EAErCC,iBAFqC,EAGrCC,UAHqC,KAIZ;EACzB,MAAMC,YAAY,CAChBH,aAAaI,MADG,EAEhBJ,aAAaK,UAFG,EAGhBL,aAAaM,OAHG,CAAlB;EAKA,MAAMC,iBAAiBJ,UAAUK,MAAV,CAAiBC,OAAjB,CAAvB;EACA,MAAMC,aAAaH,eAAeI,IAAf,CAAqBC,MAAD,IAAY;IACjD,OAAOV,WAAWU,OAAOC,SAAlB,EAA6BZ,iBAA7B,CAAP;EACD,CAFkB,CAAnB;EAIA,OAAOS,cAAc,IAArB;AACF,CAhBO,C;;;ACFA,8BAA8BI,WAA9B,EAA2D;EAChE,OAAO,IAAIC,GAAJ,CAAQD,WAAR,EAAqBE,SAASC,MAA9B,EAAsCnB,IAA7C;AACF,C;;;ACNA,wBAAuB/D,qBAAvB;;AAEA,IAAMmF,iBAAiB,OAAvB;;AAKA,uBAAuBC,OAAvB,EAAuE;EAAA,mCAA5BC,WAA4B;IAA5BA,WAA4B;EAAA;;EACrE,MAAMC,sBAAsB,8BAAOF,OAAP,EAAgB,GAAGC,WAAnB,CAA5B;EACA,OAAO,GAAGF,kBAAkBG,qBAA5B;AACF;;AAKA,cAAcF,OAAd,EAA4D;EAAA,mCAA1BC,WAA0B;IAA1BA,WAA0B;EAAA;;EAC1DE,QAAQC,IAAR,CAAaC,cAAcL,OAAd,EAAuB,GAAGC,WAA1B,CAAb;AACF;;AAKA,eAAeD,OAAf,EAA6D;EAAA,mCAA1BC,WAA0B;IAA1BA,WAA0B;EAAA;;EAC3DE,QAAQG,KAAR,CAAcD,cAAcL,OAAd,EAAuB,GAAGC,WAA1B,CAAd;AACF;;AAEO,IAAMM,WAAW;EACtBF,aADsB;EAEtBD,IAFsB;EAGtBE;AAHsB,CAAjB,C;;AHhBA,IAAME,oBAAoB,gBAC/B9B,GAD+B,EAIS;EAAA,IAFxCrD,OAEwC,uEAFT,EAES;EAAA,IADxC0D,UACwC;EAExC,MAAMD,oBAAoB2B,qBAAqB/B,GAArB,CAA1B;EAEA,MAAMgC,oBAAoB,MAAMC,UAAUC,aAAV,CAC7BC,gBAD6B,GAE7BC,IAF6B,CAEvBC,aAAD,IACJA,cAAc1B,MAAd,CAAsBR,YAAD,IACnBD,wBAAwBC,YAAxB,EAAsCC,iBAAtC,EAAyDC,UAAzD,CADF,CAH4B,CAAhC;;EAOA,IAAI,CAAC4B,UAAUC,aAAV,CAAwBI,UAAzB,IAAuCN,kBAAkBO,MAAlB,GAA2B,CAAtE,EAAyE;IAOvEpB,SAASqB,MAAT;EACF;;EAEA,MAAM,CAACC,oBAAD,IAAyBT,iBAA/B;;EAEA,IAAIS,oBAAJ,EAA0B;IAExB,OAAOA,qBAAqBC,MAArB,GAA8BN,IAA9B,CAAmC,MAAM;MAC9C,OAAO,CACLlC,wBACEuC,oBADF,EAEErC,iBAFF,EAGEC,UAHF,CADK,EAMLoC,oBANK,CAAP;IAQD,CATM,CAAP;EAUF;;EAGA,MAAM,CAACxF,MAAD,EAAQ0F,QAAR,IAAoB,MAAM,wBAC9B,YAAY;IACV,MAAMxC,eAAe,MAAM8B,UAAUC,aAAV,CAAwBU,QAAxB,CAAiC5C,GAAjC,EAAsCrD,OAAtC,CAA3B;IACA,OAAO,CAGLuD,wBAAwBC,YAAxB,EAAsCC,iBAAtC,EAAyDC,UAAzD,CAHK,EAILF,YAJK,CAAP;EAOJ,CAVgC,CAAhC;;EAaA,IAAIlD,MAAJ,EAAW;IACT,MAAM4F,kBAAkB5F,OAAMqE,OAAN,CAAcxB,QAAd,CAAuB,OAAvB,CAAxB;;IAIA,IAAI+C,eAAJ,EAAqB;MACnB,MAAMC,WAAW,IAAI5B,GAAJ,CAAQ,oCAAS6B,KAAT,KAAkB,GAA1B,EAA+B5B,SAASlB,IAAxC,CAAjB;MAEA,MAAM,IAAIhB,KAAJ,CACJ4C,SAASF,aAAT,CAAuB,mDACmBmB,SAAS7C,wBAAwBG;AAAA;AAAA;AAAA;AAAA,oFAD3E,CADI,CAAN;IAQF;;IAGA,MAAM,IAAInB,KAAJ,CACJ4C,SAASF,aAAT,CACE,8CADF,EAEE1E,OAAMqE,OAFR,CADI,CAAN;EAMF;;EAEA,OAAOqB,QAAP;AACF,CAnFO,C;;;AIEA,6BAA6D;EAAA,IAAlCxG,IAAkC,uEAAJ,EAAI;;EAClE,IAAIA,KAAK6G,KAAT,EAAgB;IACd;EACF;;EAEA,MAAM1B,UAAUnF,KAAKmF,OAAL,IAAgB,kBAAhC;EAEAG,QAAQwB,cAAR,CACE,KAAKpB,SAASF,aAAT,CAAuBL,OAAvB,CAA8B,EADrC,EAEE,mCAFF;EAIAG,QAAQyB,GAAR,CACE,0CADF,EAEE,kBAFF,EAGE,oBAHF;EAKAzB,QAAQyB,GAAR,CAAY,qDAAZ;;EAEA,IAAI/G,KAAKgH,SAAT,EAAoB;IAClB1B,QAAQyB,GAAR,CAAY,oBAAZ,EAAkC/G,KAAKgH,SAAvC;EACF;;EAEA,IAAIhH,KAAKiH,WAAT,EAAsB;IACpB3B,QAAQyB,GAAR,CAAY,eAAZ,EAA6B/G,KAAKiH,WAAlC;EACF;;EAEA3B,QAAQ4B,QAAR;AACF,C;;;AChCA,6BACEnJ,OADF,EAEEyC,OAFF,EAGE;EAVF;;EAWEzC,QAAQoJ,aAAR,CAAsBC,IAAtB,CAA2B,eAA3B;EACA,MAAMrJ,QAAQsJ,MAAR,CAAeC,IAAf,CAAoB,iBAApB,CAAN;;EAKA,IAAIvJ,QAAQwJ,gBAAZ,EAA8B;IAC5B7B,SAASH,IAAT,CACE,4KADF;IAGA;EACF;;EAEAxH,QAAQwJ,gBAAR,GAA2B,IAA3B;EAEAC,kBAAkB;IAChBX,OAAOrG,QAAQqG,KADC;IAEhBI,aAAa,cAAQjD,YAAR,wBAAsB4C,KAFnB;IAGhBI,WAAW,cAAQpC,MAAR,wBAAgBC;EAHX,CAAlB;AAKF,C;;;ACdO,IAAM4C,yBAA0BC,KAAD,IAAyB;EAC7D,MAAMC,OAAOD,MAAME,KAAN,CAAY,CAAZ,CAAb;EAEA,OAAO;IAILR,KAAKjC,OAAL,EAGG;MACD,IAAIwC,IAAJ,EAAU;QACRA,KAAKE,WAAL,CAAiB1C,OAAjB;MACF;IACF;;EAXK,CAAP;AAaF,CAhBO,C;;;ACjBA,iCAA2BrC,KAA3B,CAAiC;EACtCgF,YAAY3C,OAAZ,EAA6B;IAC3B,MAAMA,OAAN;IACA,KAAKlF,IAAL,GAAY,cAAZ;EACF;;AAJsC,CAAjC,C;;ACAP,+BAAwBF,2BAAxB,C;;;ACAA,+BAAwBA,2BAAxB,C;;;ACAA,+BAAwBA,2BAAxB,C;;;AC6BO,mBAQc;EAAA,mCAHhBgI,GAGgB;IAHhBA,GAGgB;EAAA;;EACnB,OAAO,YAAa;IAClB,OAAOA,IAAIC,WAAJ,CAAgB,CAACC,MAAD,EAAcC,OAAd,KAA0B;MAC/C,OAAOD,kBAAkBE,OAAlB,GACHA,QAAQC,OAAR,CAAgBH,MAAhB,EAAwBhC,IAAxB,CAA6BiC,OAA7B,CADG,GAEHA,QAAQD,MAAR,CAFJ;IAGF,CAJO,mDAAP;EAKF,CANA;AAOF,C;;;ADLO,IAAM/J,kBAAmD;EAC9DoB,QAAQ,GADsD;EAE9DK,YAAY,IAFkD;EAG9Dd,MAAM,IAHwD;EAI9DG,OAAO,CAJuD;EAK9DsI,MAAM,KALwD;EAM9De,aAAa;AANiD,CAAzD;AAcA,IAAMC,8BAA0D,EAAhE;;AAEA,mCACLC,iBADK,EAGa;EAAA,IADlBC,mBACkB,uEADqCF,2BACrC;EAClB,OAAO,kBAA2B;IAChC,MAAMG,kBAAkCtH,OAAOU,MAAP,CACtC,EADsC,EAEtC3D,eAFsC,EAGtC;MACEiC,SAAS,IAAIuI,gCAAJ,CAAY;QACnB,gBAAgB;MADG,CAAZ;IADX,CAHsC,EAQtCH,iBARsC,CAAxC;;IADgC,mCAAjBI,YAAiB;MAAjBA,YAAiB;IAAA;;IAYhC,MAAMC,uBAAuB,CAC3B,GAAGJ,mBADwB,EAE3B,GAAGG,YAFwB,EAG3BnE,MAH2B,CAGpBC,OAHoB,CAA7B;IAKA,MAAMoE,mBACJD,qBAAqBxC,MAArB,GAA8B,CAA9B,GACItI,QAAQ,GAAG8K,oBAAX,EAAiCH,eAAjC,CADJ,GAEIA,eAHN;IAKA,OAAOI,gBAAP;EACF,CAvBA;AAwBF;;AAEO,IAAMrK,WAAW2C,OAAOU,MAAP,CAAc7D,2BAAd,EAA2C;EACjEsJ,MAAMtJ,0BAA0B;IAAEsJ,MAAM;EAAR,CAA1B,CAD2D;;EAEjEwB,aAAa3D,OAAb,EAA8B;IAC5B,MAAM,IAAI4D,YAAJ,CAAiB5D,OAAjB,CAAN;EACF;;AAJiE,CAA3C,CAAjB,C;;AErFP,IAAM6D,eAAe,kBAArB;AAEA,IAAMC,cACJ,mEADF;;AAMO,sBAAsBnI,MAAtB,EAAoC;EAEzC,MAAMoI,QAAQpI,OAAMoI,KAApB;;EAEA,IAAI,CAACA,KAAL,EAAY;IACV;EACF;;EAEA,MAAMC,SAAmBD,MAAME,KAAN,CAAY,IAAZ,EAAkBC,KAAlB,CAAwB,CAAxB,CAAzB;EAIA,MAAMC,mBAAmBH,OAAOxE,IAAP,CAAa4E,KAAD,IAAW;IAC9C,OAAO,EAAEP,aAAaQ,IAAb,CAAkBD,KAAlB,KAA4BN,YAAYO,IAAZ,CAAiBD,KAAjB,CAA9B,CAAP;EACD,CAFwB,CAAzB;;EAIA,IAAI,CAACD,gBAAL,EAAuB;IACrB;EACF;;EAGA,MAAMG,kBAAkBH,iBACrBI,OADqB,CACb,yBADa,EACc,IADd,EAErBA,OAFqB,CAEb,IAFa,EAEP,EAFO,CAAxB;EAGA,OAAOD,eAAP;AACF,C;;;AC/BO,oBACLE,EADK,EAEsD;EAC3D,IAAI,CAACA,EAAL,EAAS;IACP,OAAO,KAAP;EACF;;EAEA,OAAO,OAAQA,GAA0BC,OAAOC,QAAjC,CAAR,IAAsD,UAA7D;AACF,C;;;AJYO,IAAM5L,iBAAiC;EAC5CqB,MAD4C;EAE5CD,GAF4C;EAG5CL,KAH4C;EAI5CG;AAJ4C,CAAvC;AA2FA,2BAKL;EAcA2I,YAAYtH,OAAZ,EAAyD;IACvD,KAAKsJ,UAAL,GAAkB,KAAlB;IACA,KAAKC,GAAL,GAAWvJ,QAAQuJ,GAAR,IAAe9L,cAA1B;IACA,KAAK+L,QAAL,GAAgBxJ,QAAQwJ,QAAxB;IAEA,MAAMC,YAAYC,aAAa,IAAIpH,KAAJ,EAAb,CAAlB;IAEA,KAAKqH,IAAL,GAAY9G,iCACP7C,QAAQ2J,IADD;MAEVF;IAFU,EAAZ;EAIF;;EAyBApJ,MACEuJ,QADF,EAEEC,kBAFF,EAGgB;IACd,OAAO,IAAP;EACF;;EAKOb,KACLc,OADK,EAELC,iBAFK,EAGI;IACT,OAAO,KAAKC,SAAL,CACLF,OADK,EAEL,KAAKzJ,KAAL,CAAWyJ,OAAX,EAAoBC,iBAApB,CAFK,EAGLA,iBAHK,CAAP;EAKF;;EAMUE,iBACRH,OADQ,EAERI,aAFQ,EAGR;IACA,OAAOJ,OAAP;EACF;;EAEOK,gBAAiC;IAAA,IAAnBb,UAAmB,uEAAN,IAAM;IACtC,KAAKA,UAAL,GAAkBA,UAAlB;EACF;;EAMa,UACXQ,OADW,EAEXC,iBAFW,EAGmD;IAC9D,IAAI,KAAKT,UAAT,EAAqB;MACnB,OAAO,IAAP;IACF;;IAEA,MAAMc,eAAe,KAAK/J,KAAL,CAAWyJ,OAAX,EAAoBC,iBAApB,CAArB;IACA,MAAMM,kBAAkB,KAAKL,SAAL,CACtBF,OADsB,EAEtBM,YAFsB,EAGtBL,iBAHsB,CAAxB;;IAMA,IAAI,CAACM,eAAL,EAAsB;MACpB,OAAO,IAAP;IACF;;IAEA,MAAMC,gBAAgB,KAAKL,gBAAL,CAAsBH,OAAtB,EAA+BM,YAA/B,CAAtB;IAIA,MAAMG,kBAAkB,KAAKC,YAAL,CAAkB,KAAKhB,QAAvB,CAAxB;IACA,MAAMiB,iBAAiB,MAAMF,gBAC3BD,aAD2B,EAE3BtM,QAF2B,EAG3B,KAAKuL,GAHsB,CAA7B;IAMA,OAAO,KAAKmB,qBAAL,CACLN,YADK,EAELE,aAFK,EAGLG,cAHK,CAAP;EAKF;;EAEQD,aACNhB,QADM,EAEuD;IAC7D,OAAO,OAAOmB,GAAP,EAAYvL,GAAZ,EAAiBmK,GAAjB,KAAyB;MAC9B,MAAMzI,SAAS,KAAK8J,iBAAL,KAA2B,MAAMpB,SAASmB,GAAT,EAAcvL,GAAd,EAAmBmK,GAAnB,CAAjC,CAAf;;MAEA,IAAIsB,WAAiD/J,MAAjD,CAAJ,EAA8D;QAC5D,MAAM;UAAEpB,KAAF;UAASoL;QAAT,IAAkBhK,OAAOsI,OAAOC,QAAd,IAA0B0B,IAA1B,EAAxB;QACA,MAAMC,eAAe,MAAMtL,KAA3B;;QAIA,IAAI,CAACsL,YAAD,IAAiBF,IAArB,EAA2B;UACzB,OAAO,KAAKG,uBAAZ;QACF;;QAEA,IAAI,CAAC,KAAKL,iBAAV,EAA6B;UAC3B,KAAKA,iBAAL,GAAyB9J,MAAzB;QACF;;QAEA,KAAKmK,uBAAL,GAA+BD,YAA/B;QACA,OAAOA,YAAP;MACF;;MAEA,OAAOlK,MAAP;IACF,CAtBA;EAuBF;;EAEQ4J,sBACNN,YADM,EAENN,OAFM,EAGNoB,SAHM,EAIwC;IAC9C,OAAO;MACLC,SAAS,IADJ;MAELf,cAAcA,gBAAgB,IAFzB;MAGLN,OAHK;MAIL9L,UAAUkN,aAAY;IAJjB,CAAP;EAMF;;AAtKA,CALK;;AAkLA,uBAA6C;EAGlD,OAAO;IACLpM,QAAQ,GADH;IAELK,YAAY,UAFP;IAGLQ,SAAS,IAAIyL,gCAAJ,EAHJ;IAIL/M,MAAM,IAJD;IAOLwJ,aAAa,IAPR;IAQLf,MAAM;EARD,CAAP;AAUF,C;;;AKjTA,mBAA6B7H,0BAA7B;;AACA,qBAAsBM,yBAAtB,C;;;ACDA,mBAA6BN,0BAA7B;;AAGA,yBAAyB;EACvB,OAAOoM,YAAY,MAAZ,CAAkBlL,SAAS7B,MAA3B,CAAP;AACF;;AAKO,2BAA2BwL,OAA3B,EAAmD;EAIxD,IAAI,OAAO3J,QAAP,KAAoB,WAApB,IAAmC,OAAOqE,QAAP,KAAoB,WAA3D,EAAwE;IACtE,OAAO,EAAP;EACF;;EAEA,QAAQsF,QAAQwB,WAAhB;IAAgB,KACT,aADS;MACM;QAGlB,OAAO9G,SAASC,MAAT,KAAoBqF,QAAQzG,GAAR,CAAYoB,MAAhC,GAAyC8G,eAAzC,GAA2D,EAAlE;MACF;;IAAA,KAEK,SAFL;MAEgB;QAEd,OAAOA,eAAP;MACF;;IAAA;MAES;QACP,OAAO,EAAP;MACF;EAdF;AAgBF,C;;;ADtBO,2BAA2BzB,OAA3B,EAAyD;EAZhE;;EAiBE,MAAM0B,uBAAuB1B,QAAQnK,OAAR,CAAgB8L,GAAhB,CAAoB,QAApB,CAA7B;EAEAC,qBAAMC,OAAN;EAEA,MAAMC,mBAAmBrL,MAAMsL,IAAN,CACvB,2BAAMJ,GAAN,CAAU5I,iCAAKiH,OAAL;IAAczG,KAAKyG,QAAQzG,GAAR,CAAYyI,QAAZ;EAAnB,EAAV,yBAAwDlL,OAAxD,EADuB,EAEvBC,MAFuB,CAEhB,CAACkL,OAAD,YAAgC;IAAA,IAAtB,CAACtM,IAAD,EAAO;MAAEC;IAAF,CAAP,CAAsB;IACvC,OAAOiB,OAAOU,MAAP,CAAc0K,OAAd,EAAuB;MAAA,CAAGtM,KAAKuM,IAAL,EAAH,GAAiBtM;IAAjB,CAAvB,CAAP;EACF,CAJyB,EAItB,EAJsB,CAAzB;EAMA,MAAMuM,sBAAsBC,kBAAkBpC,OAAlB,CAA5B;;EAEA,MAAMqC,mBAAmBC,kCACpBH,mBADoB,GAEpBL,gBAFoB,CAAzB;;EAQA,WAAW,CAACnM,IAAD,EAAOC,KAAP,CAAX,IAA4BiB,OAAOC,OAAP,CAAeuL,gBAAf,CAA5B,EAA8D;IAC5DrC,QAAQnK,OAAR,CAAgBC,MAAhB,CAAuB,QAAvB,EAAiC,GAAGH,QAAQC,OAA5C;EACF;;EAEA,MAAM2M,aAAab,uBACfc,YAAY,MAAZ,CAAkBd,oBAAlB,CADe,GAEf,EAFJ;EAIA1B,QAAQiC,OAAR,GAAkBK,iDACbtC,QAAQiC,OADK,GAEbI,gBAFa,GAGbE,UAHa,CAAlB;AAKF,C;;;AElDA,+BAAgC9M,2BAAhC;;AAgBA,6BAA6BgN,aAA7B,EAA0E;EAhB1E;;EAiBE,MAAM5M,UAAU,8CAAgB4M,aAAhB,CAAhB;EACA,MAAMC,cAAc7M,QAAQ8L,GAAR,CAAY,cAAZ,KAA+B,YAAnD;EACA,MAAMgB,cAAc9M,QAAQ8L,GAAR,CAAY,qBAAZ,CAApB;;EAEA,IAAI,CAACgB,WAAL,EAAkB;IAChB,MAAM,IAAInK,KAAJ,CAAU,2CAAV,CAAN;EACF;;EAEA,MAAMoK,aAAaD,YAAY7D,KAAZ,CAAkB,GAAlB,EAAuB/H,MAAvB,CAA8B,CAAC8L,GAAD,EAAMC,KAAN,KAAgB;IAC/D,MAAM,CAAC7M,KAAD,EAAC,GAAS8M,KAAV,IAAkBD,MAAMZ,IAAN,GAAapD,KAAb,CAAmB,GAAnB,CAAxB;IACA+D,IAAI5M,KAAJ,IAAY8M,MAAKC,IAAL,CAAU,GAAV,CAAZ;IACA,OAAOH,GAAP;EACF,CAJmB,EAIhB,EAJgB,CAAnB;EAMA,MAAMlN,OAAO,iBAAWA,IAAX,wBAAiBoJ,KAAjB,CAAuB,CAAvB,EAA0B,EAA1B,CAAb;EACA,MAAMkE,WAAW,iBAAWA,QAAX,wBAAqBlE,KAArB,CAA2B,CAA3B,EAA8B,EAA9B,CAAjB;EAEA,OAAO;IACLpJ,IADK;IAELsN,QAFK;IAGLP;EAHK,CAAP;AAKF;;AAMO,4BACLQ,KADK,EAELrN,OAFK,EAGU;EACf,MAAM6M,cAAc7M,mCAAS8L,GAAT,CAAa,cAAb,CAApB;;EAEA,IAAI,CAACe,WAAL,EAAkB;IAChB,OAAO,MAAP;EACF;;EAEA,MAAM,GAAC,GAAKE,UAAN,IAAoBF,YAAY5D,KAAZ,CAAkB,KAAlB,CAA1B;EACA,MAAMqE,WAAWP,WACd1I,MADc,CACNkJ,CAAD,IAAOA,EAAEC,UAAF,CAAa,WAAb,CADA,EAEdC,GAFc,CAETC,CAAD,IAAOA,EAAEnE,OAAF,CAAU,YAAV,EAAwB,EAAxB,CAFG,EAE0B,CAF1B,CAAjB;;EAIA,IAAI,CAAC+D,QAAL,EAAe;IACb,OAAO,MAAP;EACF;;EAEA,MAAMK,iBAAiB,IAAIC,MAAJ,CAAW,MAAMN,UAAjB,CAAvB;EACA,MAAMO,SAASR,MACZpE,KADY,CACN0E,cADM,EAEZtJ,MAFY,CAEJ4I,KAAD,IAAWA,MAAMO,UAAN,CAAiB,MAAjB,KAA4BP,MAAMa,QAAN,CAAe,MAAf,CAFlC,EAGZL,GAHY,CAGPR,KAAD,IAAWA,MAAMc,SAAN,GAAkBxE,OAAlB,CAA0B,OAA1B,EAAmC,EAAnC,CAHH,CAAf;;EAKA,IAAI,CAACsE,OAAO5H,MAAZ,EAAoB;IAClB,OAAO,MAAP;EACF;;EAEA,MAAM+H,aAA0C,EAAhD;;EAEA,IAAI;IACF,WAAWC,MAAX,IAAoBJ,MAApB,EAA4B;MAC1B,MAAM,CAACK,cAAD,EAAC,GAAmBhB,KAApB,IAA4Be,OAAMhF,KAAN,CAAY,UAAZ,CAAlC;MACA,MAAMkF,cAAcjB,MAAKC,IAAL,CAAU,UAAV,CAApB;MACA,MAAM;QAAEN,yBAAF;QAAeO,QAAf;QAAyBtN;MAAzB,IACJsO,oBAAoBF,cAApB,CADF;MAGA,MAAMnO,QACJqN,aAAa,MAAb,GACIe,WADJ,GAEI,IAAIE,IAAJ,CAAS,CAACF,WAAD,CAAT,EAAwBf,QAAxB,EAAkC;QAAEkB,MAAMC;MAAR,CAAlC,CAHN;MAKA,MAAMC,cAAcR,WAAWlO,IAAX,CAApB;;MAEA,IAAI0O,gBAAgB,MAApB,EAA+B;QAC7BR,WAAWlO,IAAX,IAAmBC,KAAnB;MACF,CAFA,MAEA,IAAWa,MAAMC,OAAN,CAAc2N,WAAd,CAAX,EAAuC;QACrCR,WAAWlO,IAAX,IAAmB,CAAC,GAAG0O,WAAJ,EAAiBzO,KAAjB,CAAnB;MACF,CAFA,MAEO;QACLiO,WAAWlO,IAAX,IAAmB,CAAC0O,WAAD,EAAczO,KAAd,CAAnB;MACF;IACF;;IAEA,OAAOiO,UAAP;EACF,CAxBA,CAwBA,OAASrN,MAAT,EAAE;IACA,OAAO,MAAP;EACF;AACF,C;;;AChGO,mBAAmBgB,KAAnB,EAAiD3B,OAAjD,EAAoE;EAP3E;;EASE,IAAI,CAAC2B,KAAL,EAAW;IACT,OAAOA,KAAP;EACF;;EAEA,MAAMkL,cAAc,0CAASf,GAAT,CAAa,cAAb,yBAA8B2C,WAA9B,OAA+C,EAAnE;EAIA,MAAMC,sBAAsB7B,YAAYW,UAAZ,CAAuB,qBAAvB,CAA5B;;EACA,IAAIkB,uBAAuB,OAAO/M,KAAP,KAAgB,QAA3C,EAAqD;IACnD,OAAOgN,mBAAmBhN,MAAKwK,QAAL,EAAnB,EAAoCnM,OAApC,KAAgD2B,KAAvD;EACF;;EAIA,MAAMiN,iBAAiB/B,YAAYrJ,QAAZ,CAAqB,MAArB,CAAvB;;EAEA,IAAIoL,kBAAkB,OAAOjN,KAAP,KAAgB,QAAtC,EAAgD;IAC9C,OAAOI,UAAUJ,MAAKwK,QAAL,EAAV,KAA8BxK,KAArC;EACF;;EAGA,OAAOA,KAAP;AACF,C;;;AC7BO,uBAAuBkN,MAAvB,EAAuCC,QAAvC,EAAkE;EACvE,OAAOD,OAAOJ,WAAP,OAAyBK,SAASL,WAAT,EAAhC;AACF,C;;;ACGO,6BACLtE,OADK,EAEiC;EACtC,IACEA,QAAQ7G,MAAR,IACAyL,cAAc5E,QAAQ7G,MAAtB,EAA8B,KAA9B,CADA,IAEA6G,QAAQzL,IAAR,KAAiB,EAHnB,EAIE;IACA,OAAO,MAAP;EACF;;EAEA,OAAOyL,QAAQzL,IAAf;AACF,C;;;AXRO,4BACLsQ,UADK,EAEQ;EACb,MAAM7E,UAAuB;IAC3B8E,IAAID,WAAWC,EADY;IAE3BC,OAAOF,WAAWE,KAFS;IAG3BvD,aAAaqD,WAAWrD,WAHG;IAI3BrI,QAAQ0L,WAAW1L,MAJQ;IAK3BI,KAAK,IAAIkB,GAAJ,CAAQoK,WAAWtL,GAAnB,CALsB;IAM3ByL,UAAUH,WAAWG,QANM;IAO3BC,gBAAgBJ,WAAWI,cAPA;IAQ3BC,UAAUL,WAAWK,QARM;IAS3BC,MAAMN,WAAWM,IATU;IAU3BC,QAAQ,EAVmB;IAW3BnD,SAAS,EAXkB;IAY3BoD,WAAWR,WAAWQ,SAZK;IAa3BC,WAAWT,WAAWS,SAbK;IAc3BC,aAAaV,WAAWU,WAdG;IAe3BhR,MAAMiR,oBAAoBX,UAApB,CAfqB;IAgB3BY,UAAUZ,WAAWY,QAhBM;IAiB3B5P,SAAS,IAAI6P,gCAAJ,CAAYb,WAAWhP,OAAvB,CAjBkB;IAkB3BkI;EAlB2B,CAA7B;EAsBA4H,kBAAkB3F,OAAlB;EAGAA,QAAQzL,IAAR,GAAeqR,UAAU5F,QAAQzL,IAAlB,EAAwByL,QAAQnK,OAAhC,CAAf;EAEA,OAAOmK,OAAP;AACF,C;;;AY3CA,oBAAsBvK,4BAAtB,C;;;ACqBO,IAAMoQ,cAAc,OAIzB7F,OAJyB,EAKzB8F,QALyB,EAMzB7F,iBANyB,KAOS;EAClC,MAAM8F,mBAAmBD,SAAS5L,MAAT,CAAiBmH,OAAD,IAAa;IACpD,OAAOA,QAAQnC,IAAR,CAAac,OAAb,EAAsBC,iBAAtB,CAAP;EACD,CAFwB,CAAzB;;EAIA,IAAI8F,iBAAiBjK,MAAjB,KAA4B,CAAhC,EAAmC;IACjC,OAAO;MACLuF,SAAS,MADJ;MAELnN,UAAU;IAFL,CAAP;EAIF;;EAEA,MAAM8C,SAAS,MAAM+O,iBAAiBhP,MAAjB,CAEnB,OAAOiP,eAAP,EAAwB3E,OAAxB,KAAoC;IACpC,MAAM4E,kBAAkB,MAAMD,eAA9B;;IAEA,IAAI,CAAC,EAACC,mDAAiB/R,QAAlB,CAAL,EAAiC;MAC/B,OAAO8R,eAAP;IACF;;IAEA,MAAME,UAAS,MAAM7E,QAAQ8E,GAAR,CAAYnG,OAAZ,EAAqBC,iBAArB,CAArB;;IAEA,IAAIiG,YAAW,IAAX,IAAmBA,QAAO7E,OAAP,CAAe7B,UAAtC,EAAkD;MAChD,OAAO,IAAP;IACF;;IAEA,IAAI,CAAC0G,QAAOhS,QAAZ,EAAsB;MACpB,OAAO;QACL8L,SAASkG,QAAOlG,OADX;QAELqB,SAAS6E,QAAO7E,OAFX;QAGLnN,UAAU,MAHL;QAILoM,cAAc4F,QAAO5F;MAJhB,CAAP;IAMF;;IAEA,IAAI4F,QAAOhS,QAAP,CAAgB8I,IAApB,EAA0B;MACxBqE,QAAQhB,aAAR,CAAsB,IAAtB;IACF;;IAEA,OAAO6F,OAAP;EACF,CA7BqB,EA6BlBrI,QAAQC,OAAR,CAAgB,IAAhB,CA7BkB,CAArB;;EAkCA,IAAI,CAAC9G,MAAL,EAAa;IACX,OAAO;MACLqK,SAAS,MADJ;MAELnN,UAAU;IAFL,CAAP;EAIF;;EAEA,OAAO;IACLmN,SAASrK,OAAOqK,OADX;IAELb,eAAexJ,OAAOgJ,OAFjB;IAGLoG,eAAepP,OAAOsJ,YAHjB;IAILpM,UAAU8C,OAAO9C;EAJZ,CAAP;AAMF,CAlEO,C;;;ACrBP,4BAAgCiB,kCAAhC,C;;;ACAA,qBAKOM,kBALP,C;;;ACMO,IAAM4Q,0BAA2BrG,OAAD,IAA4B;EACjE,OAAOA,QAAQgF,QAAR,CAAiB3B,UAAjB,CAA4BrD,QAAQzG,GAAR,CAAYoB,MAAxC,IACHqF,QAAQzG,GAAR,CAAY+M,QADT,GAEH,IAAI7L,GAAJ,CACEuF,QAAQzG,GAAR,CAAY+M,QADd,EAEE,GAAGtG,QAAQzG,GAAR,CAAYgN,aAAavG,QAAQzG,GAAR,CAAYiN,MAF1C,EAGEhN,IALN;AAMF,CAPO,C;;;ADwBA,2BAA2BiN,IAA3B,EAAmE;EA9B1E;;EA+BE,MAAMC,eAAeD,KAAKE,WAAL,CAAiBtM,IAAjB,CAAuBuM,GAAD,IAAS;IAClD,OAAOA,IAAIC,IAAJ,KAAa,qBAApB;EACD,CAFoB,CAArB;EAIA,OAAO;IACLC,eAAeJ,6CAAcK,SADxB;IAELC,eAAe,mDAAcrR,IAAd,wBAAoBC;EAF9B,CAAP;AAIF;;AAEA,oBAAoBqR,KAApB,EAA+D;EAC7D,IAAI;IACF,MAAMC,MAAM,0BAAMD,KAAN,CAAZ;IACA,OAAOE,kBAAkBD,GAAlB,CAAP;EACF,CAHA,CAGA,OAAS1Q,MAAT,EAAE;IACA,OAAOA,MAAP;EACF;AACF;;AAUA,mCACE4Q,SADF,EAEE9D,GAFF,EAGE+D,KAHF,EAIE;EACA,MAAMC,aAAa;IAAEF;EAAF,CAAnB;;EACA,WAAW,CAACnQ,GAAD,EAAMsQ,SAAN,CAAX,IAA+B1Q,OAAOC,OAAP,CAAewM,GAAf,CAA/B,EAAoD;IAClD,IAAI,EAAErM,OAAOoQ,KAAT,CAAJ,EAAqB;MACnB,MAAM,IAAI7O,KAAJ,CAAU,kCAAkCvB,QAA5C,CAAN;IACF;;IAEA,WAAWuQ,OAAX,IAAsBD,SAAtB,EAAiC;MAC/B,MAAM,CAACE,QAAD,EAAC,GAAaC,aAAd,IAA+BF,QAAQ1I,KAAR,CAAc,GAAd,EAAmB6I,OAAnB,EAArC;MACA,MAAMC,QAAQF,cAAcC,OAAd,EAAd;MACA,IAAIE,SAA8BP,UAAlC;;MAEA,WAAWQ,IAAX,IAAmBF,KAAnB,EAA0B;QACxB,IAAI,EAAEE,QAAQD,MAAV,CAAJ,EAAuB;UACrB,MAAM,IAAIrP,KAAJ,CAAU,aAAaoP,8BAAvB,CAAN;QACF;;QAEAC,SAASA,OAAOC,IAAP,CAAT;MACF;;MAEAD,OAAOJ,QAAP,IAAmBJ,MAAMpQ,GAAN,CAAnB;IACF;EACF;;EACA,OAAOqQ,WAAWF,SAAlB;AACF;;AAEA,yBAAyBpH,OAAzB,EAA2E;EAxF3E;;EAyFE,QAAQA,QAAQ7G,MAAhB;IAAgB,KACT,KADS;MACF;QACV,MAAM8N,QAAQjH,QAAQzG,GAAR,CAAYwO,YAAZ,CAAyBpG,GAAzB,CAA6B,OAA7B,CAAd;QACA,MAAMyF,YAAYpH,QAAQzG,GAAR,CAAYwO,YAAZ,CAAyBpG,GAAzB,CAA6B,WAA7B,KAA6C,EAA/D;QAEA,OAAO;UACLsF,KADK;UAELG,WAAWxP,UAAUwP,SAAV;QAFN,CAAP;MAIF;;IAAA,KAEK,MAFL;MAEa;QACX,IAAI,cAAQ7S,IAAR,wBAAc0S,KAAlB,EAAyB;UACvB,MAAM;YAAEA,KAAF;YAASG;UAAT,IAAuBpH,QAAQzL,IAArC;UAEA,OAAO;YACL0S,KADK;YAELG;UAFK,CAAP;QAIF;;QAGA,IAAI,cAAQ7S,IAAR,wBAAc+S,UAAlB,EAA8B;UAC5B,MACEU,aAAQzT,IADV;UAAA,MAAQ;YAAA+S;YAAYhE;UAAZ,IACN0E,EADF;UAAA,MAA4BX,kBAC1BW,EAD0B,GAApB,YAAoB,EAAR,KAAQ,EAA5B;;UAEA,MAAMC,mBACJrQ,UACE0P,UADF,KAEK,EAHP;;UAKA,IAAI,CAACW,iBAAiBhB,KAAtB,EAA6B;YAC3B,OAAO,IAAP;UACF;;UAEA,MAAMiB,YAAYtQ,UAAsC0L,OAAO,EAA7C,KAAoD,EAAtE;UACA,MAAM8D,YAAYa,iBAAiBb,SAAjB,GACde,0BACEF,iBAAiBb,SADnB,EAEEc,SAFF,EAGEb,KAHF,CADc,GAMd,EANJ;UAQA,OAAO;YACLJ,OAAOgB,iBAAiBhB,KADnB;YAELG;UAFK,CAAP;QAIF;MACF;;IAAA;MAGE,OAAO,IAAP;EAnDJ;AAqDF;;AAMO,6BACLpH,OADK,EAEiB;EACtB,MAAM9G,QAAQkP,gBAAgBpI,OAAhB,CAAd;;EAEA,IAAI,CAAC9G,KAAD,IAAU,CAACA,MAAM+N,KAArB,EAA4B;IAC1B,OAAO,MAAP;EACF;;EAEA,MAAM;IAAEA,KAAF;IAASG;EAAT,IAAuBlO,KAA7B;EACA,MAAMoH,eAAe+H,WAAWpB,KAAX,CAArB;;EAEA,IAAI3G,wBAAwB9H,KAA5B,EAAmC;IACjC,MAAM8P,mBAAmBjC,wBAAwBrG,OAAxB,CAAzB;IAEA,MAAM,IAAIxH,KAAJ,CACJ4C,SAASF,aAAT,CACE,0HADF,EAEE8E,QAAQ7G,MAFV,EAGEmP,gBAHF,EAIEhI,aAAazF,OAJf,CADI,CAAN;EAQF;;EAEA,OAAO;IACLiM,eAAexG,aAAawG,aADvB;IAELE,eAAe1G,aAAa0G,aAFvB;IAGLI;EAHK,CAAP;AAKF,C;;;AEzKO,4BAA4BmB,OAA5B,EAA6D;EAClE,IAAIA,UAAS,GAAb,EAAkB;IAChB,OAAO;IAAA;IAAP;EACF;;EAEA,IAAIA,UAAS,GAAb,EAAkB;IAChB,OAAO;IAAA;IAAP;EACF;;EAEA,OAAO;EAAA;EAAP;AACF,C;;;AChBO,wBAAgC;EACrC,MAAMC,MAAM,IAAIC,IAAJ,EAAZ;EAEA,OAAO,CAACD,IAAIE,QAAJ,EAAD,EAAiBF,IAAIG,UAAJ,EAAjB,EAAmCH,IAAII,UAAJ,EAAnC,EACJtF,GADI,CACA9N,MADA,EAEJ8N,GAFI,CAECR,KAAD,IAAWA,MAAM/D,KAAN,CAAY,CAAZ,EAAe,CAAf,CAFX,EAGJuE,GAHI,CAGCR,KAAD,IAAWA,MAAM+F,QAAN,CAAe,CAAf,EAAkB,GAAlB,CAHX,EAIJ7F,IAJI,CAIC,GAJD,CAAP;AAKF,C;;;ACNO,wBAAwBhD,OAAxB,EAAgD;EACrD,OAAOjH,iCACFiH,OADE;IAELnK,SAASmK,QAAQnK,OAAR,CAAgBmD,GAAhB;EAFJ,EAAP;AAIF,C;;;ACVA,+BAAgCvD,2BAAhC;;AAOO,yBAAyBH,GAAzB,EAAuD;EAC5D,MAAMwT,kBAAkB,8CAAgBxT,IAAIO,OAApB,CAAxB;EAEA,OAAOkD,iCACFzD,GADE;IAGLf,MAAMqR,UAAUtQ,IAAIf,IAAd,EAAoBuU,eAApB;EAHD,EAAP;AAKF,C;;;ACfA,4BAAsBrT,yBAAtB;;AACA,yBAA4BA,oDAA5B,C;;;ACDA,IAAMsT,2BAA2B,YAAjC;;AAEO,yBAAyBjB,IAAzB,EAAuC;EAC5C,OAAO,IAAIrN,GAAJ,CAAQ,IAAIqN,MAAZ,EAAoB,kBAApB,EAAwCC,YAA/C;AACF;;AAKO,kBAAkBD,IAAlB,EAAwC;EAC7C,OAAOA,KAAK1I,OAAL,CAAa2J,wBAAb,EAAuC,EAAvC,CAAP;AACF,C;;;ACRO,uBAAuBxP,GAAvB,EAA6C;EAClD,OAAO,gCAAgC2F,IAAhC,CAAqC3F,GAArC,CAAP;AACF,C;;;ACAO,wBAAwBuO,IAAxB,EAAsCkB,OAAtC,EAAgE;EAErE,IAAIC,cAAcnB,IAAd,CAAJ,EAAyB;IACvB,OAAOA,IAAP;EACF;;EAGA,IAAIA,KAAKzE,UAAL,CAAgB,GAAhB,CAAJ,EAA0B;IACxB,OAAOyE,IAAP;EACF;;EAIA,MAAMnN,SACJqO,WAAY,OAAO3S,QAAP,KAAoB,WAApB,IAAmCA,SAAS6S,OAD1D;EAGA,OAAOvO,SAEHwO,UAAU,IAAI1O,GAAJ,CAAQ2O,UAAUtB,IAAV,CAAR,EAAyBnN,MAAzB,EAAiCnB,IAA3C,CAFG,GAGHsO,IAHJ;AAIF,C;;;ACdO,uBAAuBA,IAAvB,EAAmCkB,OAAnC,EAA2D;EAEhE,IAAIlB,gBAAgBrE,MAApB,EAA4B;IAC1B,OAAOqE,IAAP;EACF;;EAEA,MAAMuB,mBAAmBC,eAAexB,IAAf,EAAqBkB,OAArB,CAAzB;EAEA,OAAOzV,SAAS8V,gBAAT,CAAP;AACF,C;;;AJFO,oBAAoBvB,IAApB,EAA0C;EAC/C,OACEA,KAMG1I,OANH,CAOI,2BAPJ,EAQI,CAACmK,CAAD,EAAIC,aAAJ,EAAuCC,QAAvC,KAA4D;IAC1D,MAAMC,aAAa,MAAnB;;IAEA,IAAI,CAACF,aAAL,EAAoB;MAClB,OAAOE,UAAP;IACF;;IAEA,OAAOF,cAAcnG,UAAd,CAAyB,GAAzB,IACH,GAAGmG,gBAAgBC,UADhB,GAEH,GAAGD,gBAAgBE,YAFvB;EAIJ,CAnBF,EAwBGtK,OAxBH,CAwBW,mBAxBX,EAwBgC,QAxBhC,EA8BGA,OA9BH,CA8BW,sBA9BX,EA8BmC,QA9BnC,CADF;AAiCF;;AAKO,yBAAyB7F,GAAzB,EAAmCuO,IAAnC,EAA+CkB,OAA/C,EAAwE;EAC7E,MAAMW,iBAAiBC,cAAc9B,IAAd,EAAoBkB,OAApB,CAAvB;EACA,MAAMa,YACJ,OAAOF,cAAP,KAA0B,QAA1B,GACIG,WAAWH,cAAX,CADJ,GAEIA,cAHN;EAKA,MAAMI,YAAW,oCAAYxQ,GAAZ,CAAjB;EACA,MAAMvC,SAAS,iCAAM6S,SAAN,EAAiB;IAAEG,QAAQC;EAAV,CAAjB,EAAiDF,SAAjD,CAAf;EACA,MAAM3E,SAAUpO,UAAWA,OAAOoO,MAAlB,IAA4C,EAA5D;EAEA,OAAO;IACL8E,SAASlT,WAAW,KADf;IAELoO;EAFK,CAAP;AAIF,C;;;AKtCO,IAAKhS,cAAL,gBAAK+W,YAAL;EACLA,uBAAO,MAAP;EACAA,sBAAM,KAAN;EACAA,uBAAO,MAAP;EACAA,sBAAM,KAAN;EACAA,wBAAQ,OAAR;EACAA,0BAAU,SAAV;EACAA,yBAAS,QAAT;EAPU;AAAA,CAAL,EAAK/W,iBAAL;;AAoBA,IAAMgB,cAA2B2E,iCACnCpF,cADmC;EAEtCa,MAFsC;EAGtCD,IAHsC;EAItCU,IAJsC;EAKtCH,IALsC;EAMtCI;AANsC,EAAjC;;AA0BA,gCAEG7B,cAFH,CAYL;EACAmK,YACErE,MADF,EAEE2O,IAFF,EAGEpI,QAHF,EAIE;IACA,MAAM;MACJG,MAAM;QACJuK,QAAQ,GAAGjR,UAAU2O,MADjB;QAEJA,IAFI;QAGJ3O;MAHI,CADF;MAMJsG,KAAKrL,WAND;MAOJsL;IAPI,CAAN;IAUA,KAAK2K,6BAAL;EACF;;EAEQA,gCAAgC;IACtC,MAAM;MAAElR,MAAF;MAAU2O;IAAV,IAAmB,KAAKjI,IAA9B;;IAEA,IAAIiI,gBAAgBrE,MAApB,EAA4B;MAC1B;IACF;;IAEA,MAAMlK,MAAMhG,SAASuU,IAAT,CAAZ;;IAGA,IAAIvO,QAAQuO,IAAZ,EAAkB;MAChB;IACF;;IAEA,MAAMC,eAAeuC,gBAAgBxC,IAAhB,CAArB;IACA,MAAMyC,cAAwB,EAA9B;IAEAxC,aAAahS,OAAb,CAAqB,CAACwT,CAAD,EAAIiB,SAAJ,KAAkB;MACrCD,YAAYE,IAAZ,CAAiBD,SAAjB;IACD,CAFD;IAIApP,SAASH,IAAT,CACE,+EAA+E9B,UAAU2O,wIAD3F;EAGF;;EAEAvR,MAAMyJ,OAAN,EAA4BC,iBAA5B,EAA2E;IACzE,OAAOjM,gBACLgM,QAAQzG,GADH,EAEL,KAAKsG,IAAL,CAAUiI,IAFL,EAGL7H,uDAAmB+I,OAHd,CAAP;EAKF;;EAEU7I,iBACRH,OADQ,EAERM,YAFQ,EAGsB;IAC9B,OAAOvH,iCACFiH,OADE;MAELoF,QAAQ9E,aAAa8E,MAAb,IAAuB;IAF1B,EAAP;EAIF;;EAEAlF,UAAUF,OAAV,EAAgCM,YAAhC,EAAiE;IAC/D,MAAMoK,gBACJ,KAAK7K,IAAL,CAAU1G,MAAV,YAA4BsK,MAA5B,GACI,KAAK5D,IAAL,CAAU1G,MAAV,CAAiB+F,IAAjB,CAAsBc,QAAQ7G,MAA9B,CADJ,GAEIyL,cAAc,KAAK/E,IAAL,CAAU1G,MAAxB,EAAgC6G,QAAQ7G,MAAxC,CAHN;IAKA,OAAOuR,iBAAiBpK,aAAa4J,OAArC;EACF;;EAEAzN,IAAIuD,OAAJ,EAA0BoB,SAA1B,EAAwD;IACtD,MAAMuJ,YAAYtE,wBAAwBrG,OAAxB,CAAlB;IACA,MAAM4K,gBAAgBC,eAAe7K,OAAf,CAAtB;IACA,MAAM8K,iBAAiBC,gBAAgB3J,SAAhB,CAAvB;IACA,MAAM4J,cAAcC,mBAAmB7J,UAASpM,MAA5B,CAApB;IAEAgG,QAAQwB,cAAR,CACEpB,SAASF,aAAT,CAAuB,mBAAvB,CADF,EAEEgQ,cAFF,EAGElL,QAAQ7G,MAHV,EAIEwR,SAJF,EAKE,SAASK,aALX,EAME,GAAG5J,UAASpM,UAAUoM,UAAS/L,YANjC,EAOE,eAPF;IASA2F,QAAQyB,GAAR,CAAY,SAAZ,EAAuBmO,aAAvB;IACA5P,QAAQyB,GAAR,CAAY,UAAZ,EAAwB;MACtB0O,MAAM,KAAKtL,IAAL,CAAUiI,IADM;MAEtBpI,UAAU,KAAKA;IAFO,CAAxB;IAIA1E,QAAQyB,GAAR,CAAY,UAAZ,EAAwBqO,cAAxB;IACA9P,QAAQ4B,QAAR;EACF;;AA9FA,CAZK,C;;AChFP,yBAA0BnH,qBAA1B;;AAcO,IAAM2V,QAAQ,CACnBC,SADmB,EAEnBC,UAFmB,KAGa;EAChC,OAAQhW,GAAD,IAAS;IACdiW,kBAAkBF,SAAlB;IAEA,MAAM1T,WAAWC,UAAUtC,IAAIf,IAAd,KAAuB,EAAxC;IACA,MAAMsD,WAAWP,WAAWK,QAAX,EAAqB;MAAA,CAAG0T,SAAH,GAAeC;IAAf,CAArB,CAAjB;IAEA,OAAOxW,KAAK+C,QAAL,EAAevC,GAAf,CAAP;EACF,CAPA;AAQF,CAZO;;AAcP,2BAA2B+V,SAA3B,EAA8C;EAC5C,kCACEA,UAAUnJ,IAAV,OAAqB,EADvB,EAEE9G,SAASF,aAAT,CACE,iFADF,CAFF;EAOA,kCACEmQ,cAAc,MADhB,EAEEjQ,SAASF,aAAT,CACE,kIADF,EAEEmQ,SAFF,CAFF;EAQA,kCACEA,cAAc,QADhB,EAEEjQ,SAASF,aAAT,CACE,oIADF,EAEEmQ,SAFF,CAFF;EAQA,kCACEA,cAAc,YADhB,EAEEjQ,SAASF,aAAT,CACE,wIADF,EAEEmQ,SAFF,CAFF;AAOF,C;;;AC3DO,kBACLhM,EADK,EAELmM,WAFK,EAGuB;EAC5B,IAAI;IACF,MAAMxU,SAASqI,IAAf;IACA,OAAOrI,MAAP;EACF,CAHA,CAGA,OAASR,MAAT,EAAE;IACAgV,2CAAchV,MAAd;EACF;AACF,C;;;ACoCO,IAAM1C,iBAAsCiF,iCAC9CpF,cAD8C;EAEjDc,IAFiD;EAGjDG,UAHiD;EAIjDD,MAJiD;EAKjDH,MALiD;EAMjD4W;AANiD,EAA5C;;AAgCA,wBACLxV,KADK,EAEkB;EACvB,IAAIA,SAAS,IAAb,EAAmB;IACjB,OAAO,KAAP;EACF;;EAEA,OAAO,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,UAAUA,KAAvC,IAAgD,iBAAiBA,KAAxE;AACF;;AAEO,mCAEGvC,cAFH,CAOL;EAGAmK,YACEsJ,aADF,EAEEE,aAFF,EAGEyE,QAHF,EAIE/L,QAJF,EAKE;IACA,IAAIgM,wBAAwB1E,aAA5B;;IAEA,IAAI2E,eAAe3E,aAAf,CAAJ,EAAmC;MACjC,MAAM4E,aAAazE,kBAAkBH,aAAlB,CAAnB;;MAEA,IAAI4E,WAAW9E,aAAX,KAA6BA,aAAjC,EAAgD;QAC9C,MAAM,IAAItO,KAAJ,CACJ,2GAA2GsO,4BAA4B8E,WAAW9E,kBAD9I,CAAN;MAGF;;MAEA,IAAI,CAAC8E,WAAW5E,aAAhB,EAA+B;QAC7B,MAAM,IAAIxO,KAAJ,CACJ,qFADI,CAAN;MAGF;;MAEAkT,wBAAwBE,WAAW5E,aAAnC;IACF;;IAEA,MAAMoD,SACJtD,kBAAkB,KAAlB,GACI,GAAGA,0BAA0B2E,SAASzJ,QAAT,EAAkB,GADnD,GAEI,GAAG8E,iBAAiB4E,kCAAkCD,SAASzJ,QAAT,EAAkB,GAH9E;IAKA,MAAM;MACJnC,MAAM;QACJuK,MADI;QAEJtD,aAFI;QAGJE,eAAe0E;MAHX,CADF;MAMJjM,KAAK3L,cAND;MAOJ4L;IAPI,CAAN;IAUA,KAAK+L,QAAL,GAAgBA,QAAhB;EACF;;EAEAlV,MAAMyJ,OAAN,EAA8B;IAC5B,OAAO6L,SACL,MAAMC,oBAAoB9L,OAApB,CADD,EAEJxJ,MAAD,IAAWwE,QAAQG,KAAR,CAAc3E,OAAMqE,OAApB,CAFN,CAAP;EAIF;;EAEUsF,iBACRH,OADQ,EAERM,YAFQ,EAGa;IACrB,OAAOvH,iCACFiH,OADE;MAELoH,WAAW,8CAAcA,SAAd,KAA2B;IAFjC,EAAP;EAIF;;EAEAlH,UAAUF,OAAV,EAAkCM,YAAlC,EAAsE;IACpE,IAAI,CAACA,YAAL,EAAmB;MACjB,OAAO,KAAP;IACF;;IAEA,IAAI,CAACA,aAAa0G,aAAd,IAA+B,KAAKnH,IAAL,CAAUiH,aAAV,KAA4B,KAA/D,EAAsE;MACpE,MAAM6D,YAAYtE,wBAAwBrG,OAAxB,CAAlB;MACA5E,SAASH,IAAT,CAAc,6CACwB+E,QAAQ7G,UAAUwR;AAAA;AAAA,gNADxD;MAKA,OAAO,KAAP;IACF;;IAEA,MAAMoB,iBAAiB/X,gBAAgBgM,QAAQzG,GAAxB,EAA6B,KAAKkS,QAAlC,CAAvB;IACA,MAAMO,2BACJ,KAAKnM,IAAL,CAAUiH,aAAV,KAA4B,KAA5B,IACAxG,aAAawG,aAAb,KAA+B,KAAKjH,IAAL,CAAUiH,aAF3C;IAIA,MAAMmF,2BACJ,KAAKpM,IAAL,CAAUmH,aAAV,YAAmCvD,MAAnC,GACI,KAAK5D,IAAL,CAAUmH,aAAV,CAAwB9H,IAAxB,CAA6BoB,aAAa0G,aAAb,IAA8B,EAA3D,CADJ,GAEI1G,aAAa0G,aAAb,KAA+B,KAAKnH,IAAL,CAAUmH,aAH/C;IAKA,OACE+E,eAAe7B,OAAf,IACA8B,wBADA,IAEAC,wBAHF;EAKF;;EAEAxP,IACEuD,OADF,EAEEoB,SAFF,EAGEC,OAHF,EAIE+E,aAJF,EAKE;IACA,MAAMwE,gBAAgBC,eAAe7K,OAAf,CAAtB;IACA,MAAM8K,iBAAiBC,gBAAgB3J,SAAhB,CAAvB;IACA,MAAM4J,cAAcC,mBAAmB7J,UAASpM,MAA5B,CAApB;IACA,MAAMkX,cAAc,gDAAelF,aAAf,IAChB,GAAGZ,+CAAeU,iBAAiBV,+CAAeY,eADlC,GAEhB,aAAaZ,+CAAeU,eAFhC;IAIA9L,QAAQwB,cAAR,CACEpB,SAASF,aAAT,CAAuB,gBAAvB,CADF,EAEEgQ,cAFF,EAGE,GAAGgB,aAHL,EAIE,SAASlB,aAJX,EAKE,GAAG5J,UAASpM,UAAUoM,UAAS/L,YALjC,EAME,eANF;IAQA2F,QAAQyB,GAAR,CAAY,UAAZ,EAAwBmO,aAAxB;IACA5P,QAAQyB,GAAR,CAAY,UAAZ,EAAwB,IAAxB;IACAzB,QAAQyB,GAAR,CAAY,WAAZ,EAAyBqO,cAAzB;IACA9P,QAAQ4B,QAAR;EACF;;AAzHA,CAPK,C;;Af3EP,IAAMuP,kBAAkB,CAAxB;AACA,IAAMC,uBAAuB,CAA7B;AACA,IAAMC,mBAAmB,GAAzB;;AAuBA,6BAA6BvG,QAA7B,EAA+E;EAC7E,OAAOA,SAAS/O,MAAT,CACL,CAACuV,MAAD,EAASjL,OAAT,KAAqB;IACnB,IAAIA,mBAAmB/N,WAAvB,EAAoC;MAClCgZ,OAAOnY,IAAP,CAAYsW,IAAZ,CAAiBpJ,OAAjB;IACF;;IAEA,IAAIA,mBAAmBlO,cAAvB,EAAuC;MACrCmZ,OAAOzY,OAAP,CAAe4W,IAAf,CAAoBpJ,OAApB;IACF;;IAEA,OAAOiL,MAAP;EACF,CAXK,EAYL;IACEnY,MAAM,EADR;IAEEN,SAAS;EAFX,CAZK,CAAP;AAiBF;;AASA,+BAA2D;EACzD,OAAO,CAACmM,OAAD,EAAUqB,OAAV,KAAsB;IAC3B,MAAM;MAAEyG,IAAF;MAAQ3O;IAAR,IAAmBkI,QAAQxB,IAAjC;;IAEA,IAAIiI,gBAAgBrE,MAAhB,IAA0BtK,kBAAkBsK,MAAhD,EAAwD;MACtD,OAAO8I,QAAP;IACF;;IAEA,MAAMC,gBAAgB5H,cAAc5E,QAAQ7G,MAAtB,EAA8BA,MAA9B,CAAtB;IAGA,MAAMsT,mBAAmBD,gBAAgBH,gBAAhB,GAAmC,CAA5D;IACA,MAAM/D,mBAAmBjC,wBAAwBrG,OAAxB,CAAzB;IACA,MAAM0M,QAAQ,mCAAoBpE,gBAApB,EAAsCR,IAAtC,CAAd;IAEA,OAAO4E,QAAQD,gBAAf;EACF,CAfA;AAgBF;;AAEA,gCACEE,WADF,EAEiC;EAC/B,OAAO,CAACpD,CAAD,EAAIlI,OAAJ,KAAgB;IACrB,IAAI,OAAOsL,YAAY3F,aAAnB,KAAqC,WAAzC,EAAsD;MACpD,OAAOuF,QAAP;IACF;;IAEA,MAAM;MAAEzF,aAAF;MAAiBE;IAAjB,IAAmC3F,QAAQxB,IAAjD;;IAEA,IAAI,OAAOmH,aAAP,KAAyB,QAA7B,EAAuC;MACrC,OAAOuF,QAAP;IACF;;IAEA,MAAMK,uBAAuBD,YAAY7F,aAAZ,KAA8BA,aAA3D;IAEA,MAAM+F,0BAA0BD,uBAAuBP,gBAAvB,GAA0C,CAA1E;IACA,MAAMK,QAAQ,mCAAoBC,YAAY3F,aAAhC,EAA+CA,aAA/C,CAAd;IAEA,OAAO0F,QAAQG,uBAAf;EACF,CAjBA;AAkBF;;AAEA,6BACE7M,OADF,EAEE8F,QAFF,EAGEgH,QAHF,EAIoB;EAClB,MAAMC,oBAAqBjH,SACxB/O,MADwB,CACW,CAACiW,WAAD,EAAc3L,OAAd,KAA0B;IAC5D,MAAMqL,QAAQI,SAAS9M,OAAT,EAAkBqB,OAAlB,CAAd;IACA,OAAO2L,YAAY5V,MAAZ,CAAmB,CAAC,CAACsV,KAAD,EAAQrL,OAAR,CAAD,CAAnB,CAAP;EACF,CAJyB,EAItB,EAJsB,EAKxB4L,IALwB,CAKnB;IAAA,IAAC,CAACC,SAAD,CAAD;IAAA,IAAc,CAACC,UAAD,CAAd;IAAA,OAA+BD,YAAYC,UAA3C;EAAA,CALmB,EAMxBjT,MANwB,CAMjB;IAAA,IAAC,CAACwS,KAAD,CAAD;IAAA,OAAaA,SAASP,eAAtB;EAAA,CANiB,EAOxBpN,KAPwB,CAOlB,CAPkB,EAOfqN,oBAPe,EAQxB9I,GARwB,CAQpB;IAAA,IAAC,GAAGjC,OAAH,CAAD;IAAA,OAAiBA,OAAjB;EAAA,CARoB,CAA3B;EAUA,OAAO0L,iBAAP;AACF;;AAEA,qCAAqCjH,QAArC,EAAiE;EAC/D,IAAIA,SAAShK,MAAT,GAAkB,CAAtB,EAAyB;IACvB,OAAO;AAAA;AAAA,EAGTgK,SAASxC,GAAT,CAAcjC,OAAD,IAAa,YAAOA,QAAQxB,IAAR,CAAauK,QAA9C,EAAwDpH,IAAxD,CAA6D,IAA7D,CAAiE,EAH/D;EAIF;;EAEA,OAAO,4BAA4B8C,SAAS,CAAT,EAAYjG,IAAZ,CAAiBuK,kBAApD;AACF;;AAEO,4BACLpK,OADK,EAEL8F,QAFK,EAIC;EAAA,IADNsH,QACM,uEAD+B,MAC/B;EACN,MAAMC,qBAAqBxB,SAAS,MAAMC,oBAAoB9L,OAApB,CAAf,CAA3B;;EAEA,qCAA6C;IAM3C,MAAMsN,gBAAgBC,oBAAoBzH,QAApB,CAAtB;IACA,MAAMC,mBAAmBsH,qBACrBC,cAAczZ,OADO,GAErByZ,cAAcnZ,IAFlB;IAIA,MAAM4Y,oBAAoBS,oBACxBxN,OADwB,EAExB+F,gBAFwB,EAGxBsH,qBACII,uBAAuBJ,kBAAvB,CADJ,GAEIK,qBALoB,CAA1B;IAQA,OAAOX,kBAAkBjR,MAAlB,GAA2B,CAA3B,GACH6R,4BAA4BZ,iBAA5B,CADG,GAEH,EAFJ;EAGF;;EAEA,2CAAmD;IACjD,MAAMpC,YAAYtE,wBAAwBrG,OAAxB,CAAlB;IACA,MAAM4N,gBAAgBP,qBAClB,GAAGA,mBAAmBvG,iBAAiBuG,mBAAmBrG,kBAAkBhH,QAAQ7G,UAAUwR,YAD5E,GAElB,GAAG3K,QAAQ7G,UAAUwR,WAFzB;IAGA,MAAMkD,oBAAoBC,2BAA1B;IAEA,MAAMC,kBAAkB,CACtB,wDADsB,EAEtB,YAAYH,eAFU,EAGtBC,iBAHsB,EAItB;AAAA,uDAJsB,EAQtB3T,MARsB,CAQfC,OARe,CAAxB;IASA,OAAO4T,gBAAgB/K,IAAhB,CAAqB,MAArB,CAAP;EACF;;EAEA,uBAAuBgL,SAAvB,EAA2D;IAIzD,MAAMnT,UAAUoT,iCAAhB;;IAEA,QAAQD,SAAR;MAAQ,KACD,OADC;QACQ;UAEZ5S,SAASD,KAAT,CAAe,WAAf,EAA4BN,OAA5B;UAGA,MAAM,IAAIrC,KAAJ,CACJ4C,SAASF,aAAT,CACE,8FADF,CADI,CAAN;QAKF;;MAAA,KAEK,MAFL;QAEa;UACXE,SAASH,IAAT,CAAc,aAAd,EAA6BJ,OAA7B;UACA;QACF;;MAAA,KAEK,QAFL;QAGE;;MAAA;QAGA,MAAM,IAAIrC,KAAJ,CACJ4C,SAASF,aAAT,CACE,2NADF,EAEE8S,SAFF,CADI,CAAN;IAtBJ;EA6BF;;EAEA,IAAI,OAAOZ,QAAP,KAAoB,UAAxB,EAAoC;IAClCA,SAASpN,OAAT,EAAkB;MAChBkO,SAASC,cAAcC,IAAd,CAAmB,IAAnB,EAAyB,MAAzB,CADO;MAEhBjT,OAAOgT,cAAcC,IAAd,CAAmB,IAAnB,EAAyB,OAAzB;IAFS,CAAlB;IAIA;EACF;;EAEAD,cAAcf,QAAd;AACF,C;;;AgBxOA,sBAAsB3X,yBAAtB;;AAIO,6BACLuK,OADK,EAELoB,SAFK,EAGL;EACAiN,sBAAMC,GAAN,CAAUvV,iCAAKiH,OAAL;IAAczG,KAAKyG,QAAQzG,GAAR,CAAYyI,QAAZ;EAAnB,EAAV,EAAuDZ,SAAvD;EACAiN,sBAAME,OAAN;AACF,C;;;AlBuCA,6BAGEvO,OAHF,EAIE8F,QAJF,EAKE5P,OALF,EAMEsY,OANF,EAOEC,oBAPF,EAQqC;EAzDrC;;EA0DED,QAAQE,IAAR,CAAa,eAAb,EAA8B1O,OAA9B;;EAGA,IAAIA,QAAQnK,OAAR,CAAgB8L,GAAhB,CAAoB,cAApB,MAAwC,MAA5C,EAAoD;IAClD6M,QAAQE,IAAR,CAAa,aAAb,EAA4B1O,OAA5B;IACA,mEAAsB2O,qBAAtB,mDAA8C3O,OAA9C;IACA;EACF;;EAGA,MAAM,CAAC4O,WAAD,EAAcC,YAAd,IAA8B,MAAM,yBAAM,MAAM;IACpD,OAAOhJ,YACL7F,OADK,EAEL8F,QAFK,EAGL2I,6DAAsBxO,iBAHjB,CAAP;EAKD,CANyC,CAA1C;;EAQA,IAAI2O,WAAJ,EAAiB;IAEfJ,QAAQE,IAAR,CAAa,oBAAb,EAAmCE,WAAnC,EAAgD5O,OAAhD;IACA,MAAM4O,WAAN;EACF;;EAEA,MAAM;IAAEvN,OAAF;IAAWnN;EAAX,IAAwB2a,YAA9B;;EAIA,IAAI,CAACxN,OAAL,EAAc;IACZyN,mBAAmB9O,OAAnB,EAA4B8F,QAA5B,EAAsC5P,QAAQ4Y,kBAA9C;IACAN,QAAQE,IAAR,CAAa,mBAAb,EAAkC1O,OAAlC;IACAwO,QAAQE,IAAR,CAAa,aAAb,EAA4B1O,OAA5B;IACA,mEAAsB2O,qBAAtB,mDAA8C3O,OAA9C;IACA;EACF;;EAIA,IAAI,CAACoB,SAAL,EAAe;IACbhG,SAASH,IAAT,CACE;AAAA;AAAA;AAAA,OADF,EAOEmG,SAPF,EAQEC,QAAQxB,IAAR,CAAauK,MARf,EASE/I,QAAQxB,IAAR,CAAaF,SATf;IAYA6O,QAAQE,IAAR,CAAa,aAAb,EAA4B1O,OAA5B;IACA,mEAAsB2O,qBAAtB,mDAA8C3O,OAA9C;IACA;EACF;;EAIA,IAAIoB,UAASrD,WAAb,EAA0B;IACxByQ,QAAQE,IAAR,CAAa,aAAb,EAA4B1O,OAA5B;IACA,mEAAsB2O,qBAAtB,mDAA8C3O,OAA9C;IACA;EACF;;EAGA+O,oBAAoB/O,OAApB,EAA6BoB,SAA7B;EAEAoN,QAAQE,IAAR,CAAa,eAAb,EAA8B1O,OAA9B;EAEA,OAAO,IAAInC,OAAJ,CAAaC,OAAD,IAAa;IA/HlC;;IAgII,MAAMkR,uBACJH,YADF;IAGA,MAAMI,sBACJ,qEAAsBC,iBAAtB,oDAA0C9N,SAA1C,MACCA,SAFH;IAIA,oEAAsB+N,gBAAtB,oDACEF,mBADF,EAEED,oBAFF;IAKAI,WAAW,MAAM;MA5IrB;;MA6IM,oEAAsBC,oBAAtB,oDACEJ,mBADF,EAEED,oBAFF;MAIAR,QAAQE,IAAR,CAAa,aAAb,EAA4B1O,OAA5B;MAEAlC,QAAQmR,mBAAR;IACF,CARA,EAQG,iBAASva,KAAT,kBAAkB,CARrB;EASD,CAtBM,CAAP;AAuBF,C;;;AmBrIO,IAAM4a,wBAAwB,CACnC7b,OADmC,EAEnCyC,OAFmC,KAGhC;EACH,OAAO,OACLkH,KADK,EAELvC,OAFK,KAMF;IACH,MAAM0U,UAAUpS,uBAAuBC,KAAvB,CAAhB;;IAEA,IAAI;MACF,MAAM4C,UAAUwP,mBAAmB3U,QAAQnD,OAA3B,CAAhB;MACA,MAAM3D,cACJiM,OADI,EAEJvM,QAAQgc,eAFJ,EAGJvZ,OAHI,EAIJzC,QAAQ+a,OAJJ,EAKJ;QACEU,iBADF;;QAEEP,wBAAwB;UACtB,OAAOY,QAAQzS,IAAR,CAAa;YAClBqH,MAAM;UADY,CAAb,CAAP;QAGF,CANF;;QAOEgL,iBAAiB/N,SAAjB,EAA2B;UACzBmO,QAAQzS,IAAR,CAAa;YACXqH,MAAM,cADK;YAEXzM,SAAS0J;UAFE,CAAb;QAIF,CAZF;;QAaEiO,qBACEjO,SADF,SAGE;UAAA,IADA;YAAEC,OAAF;YAAWb,aAAX;YAA0B4F;UAA1B,CACA;;UACA,IAAIlQ,QAAQqG,KAAZ,EAAmB;YACjB;UACF;;UAEA8E,QAAQ5E,GAAR,CACE+D,aADF,EAEEY,SAFF,EAGEC,OAHF,EAIE+E,aAJF;QAMF;;MA3BF,CALI,CAAN;IAmCF,CArCA,CAqCA,OAAS5P,MAAT,EAAE;MACA,IAAIA,kBAAiBiI,YAArB,EAAmC;QAGjC,OAAO8Q,QAAQzS,IAAR,CAAa;UAClBqH,MAAM,eADY;UAElBzM,SAAS;YACP/B,MAAMa,OAAMb,IADL;YAEPkF,SAASrE,OAAMqE;UAFR;QAFS,CAAb,CAAP;MAOF;;MAEA,IAAIrE,kBAAiBgC,KAArB,EAA4B;QAG1B+W,QAAQzS,IAAR,CAAa;UACXqH,MAAM,gBADK;UAEXzM,SAAS;YACP1C,QAAQ,GADD;YAEPT,MAAM+B,KAAKmB,SAAL,CAAe;cACnBiY,WAAWlZ,OAAMgH,WAAN,CAAkB7H,IADV;cAEnBkF,SAASrE,OAAMqE,OAFI;cAGnBH,UAAUlE,OAAMoI;YAHG,CAAf;UAFC;QAFE,CAAb;MAWF;IACF;EACF,CA3EA;AA4EF,CAhFO;;AAkFP,2BACEwC,SADF,EAE8B;EAC5B,OAAO;IACLpM,QAAQoM,UAASpM,MADZ;IAELK,YAAY+L,UAAS/L,UAFhB;IAGLQ,SAASuL,UAASvL,OAAT,CAAiBmD,GAAjB,EAHJ;IAILzE,MAAM6M,UAAS7M,IAJV;IAKLG,OAAO0M,UAAS1M;EALX,CAAP;AAOF,C;;;AC3GA,qCACEjB,OADF,EAEEgI,aAFF,EAG0B;EAExBhI,QAAQoJ,aAAR,CAAsBC,IAAtB,CAA2B,yBAA3B;EAEA,MAAM;IAAEpF,SAASiY;EAAX,IAA8B,MAAMlc,QAAQsJ,MAAR,CAAeC,IAAf,CACxC,0BADwC,CAA1C;;EAMA,IAAI2S,mBAAmB,kCAAvB,EAAgD;IAC9C,MAAM,IAAInX,KAAJ,CACJ,oCAAoCmX,uDAAuD,sCADvF,CAAN;EAGF;;EAEA,OAAOlU,aAAP;AACF,C;;;ACtBA,oBAAsBhG,4BAAtB;;AAOO,mCAAmCma,gBAAnC,EAAmE;EAExE,MAAMC,kBAAkBlX,OAAOmX,cAAP,CAAsBC,SAAtB,CAAgCjT,IAAxD;;EACAnE,OAAOmX,cAAP,CAAsBC,SAAtB,CAAgCjT,IAAhC,GAAuC,YAErC;IAAA,mCADGpH,IACH;MADGA,IACH;IAAA;;IAGA,yBAAM,MAAMka,gBAAZ,EAA8BjU,IAA9B,CAAmC,MAAM;MACvChD,OAAOmX,cAAP,CAAsBC,SAAtB,CAAgCjT,IAAhC,GAAuC+S,eAAvC;MACA,KAAK/S,IAAL,CAAU,GAAGpH,IAAb;IACD,CAHD;EAIF,CATA;;EAYA,MAAMsa,gBAAgBrX,OAAO9D,KAA7B;;EACA8D,OAAO9D,KAAP,GAAe,kBAAmB;IAChC,MAAM,yBAAM,MAAM+a,gBAAZ,CAAN;IACAjX,OAAO9D,KAAP,GAAemb,aAAf;IACA,OAAOrX,OAAO9D,KAAP,CAAa,YAAb,CAAP;EACF,CAJA;AAKF,C;;;ACtBO,gCAAgCpB,OAAhC,EAAqE;EAC1E,OAAO,CACL8V,CADK,EAEL1O,OAFK,KAMF;IAbP;;IAcI,MAAM;MAAEnD,SAASuY;IAAX,IAA4BpV,OAAlC;;IASA,IAAI,mBAAasJ,IAAb,wBAAmB9K,QAAnB,CAA4B,QAA5B,CAAJ,EAA2C;MACzC;IACF;;IAEA,MAAM+H,YAAW,IAAI8O,QAAJ,CAAaD,aAAa1b,IAAb,IAAqB,IAAlC,EAAwC0b,YAAxC,CAAjB;IACA,MAAME,mBAAmB/O,UAASvL,OAAT,CAAiB8L,GAAjB,CAAqB,cAArB,MAAyC,KAAlE;;IAEA,IAAIwO,gBAAJ,EAAsB;MACpB1c,QAAQ+a,OAAR,CAAgBE,IAAhB,CAAqB,iBAArB,EAAwCtN,SAAxC,EAAkD6O,aAAaG,SAA/D;IACF,CAFA,MAEO;MACL3c,QAAQ+a,OAAR,CAAgBE,IAAhB,CAAqB,iBAArB,EAAwCtN,SAAxC,EAAkD6O,aAAaG,SAA/D;IACF;EACF,CA5BA;AA6BF,C;;;ACjCO,6BACL1W,YADK,EAELxD,OAFK,EAGC;EACN,IAAI,EAACA,mCAASqG,KAAV,KAAmB,CAAC7B,SAASlB,IAAT,CAAc6J,UAAd,CAAyB3J,aAAa4C,KAAtC,CAAxB,EAAsE;IACpElB,SAASH,IAAT,CACE,uFACgFvB,aAAa4C;AAAA;AAAA;AAAA,kFAF/F;EAQF;AACF,C;;;A5CNO,IAAM+T,qBACX5c,OADgC,IAEf;EACjB,OAAO,eAAeyC,OAAf,EAAwBoa,aAAxB,EAAuC;IAC5C,MAAMC,sBAAsB,YAAY;MAItC9c,QAAQsJ,MAAR,CAAeyT,kBAAf;MAGA/c,QAAQoJ,aAAR,CAAsB4T,EAAtB,CACE,SADF,EAEEnB,sBAAsB7b,OAAtB,EAA+ByC,OAA/B,CAFF;MAKAzC,QAAQoJ,aAAR,CAAsB4T,EAAtB,CAAyB,UAAzB,EAAqCC,uBAAuBjd,OAAvB,CAArC;MAEA,MAAMyI,WAAW,MAAMb,kBACrBnF,QAAQuF,aAAR,CAAsBlC,GADD,EAErBrD,QAAQuF,aAAR,CAAsBvF,OAFD,EAGrBA,QAAQ0D,UAHa,CAAvB;MAMA,MAAM,CAACU,MAAD,EAASZ,YAAT,IAAyBwC,QAA/B;;MAEA,IAAI,CAAC5B,MAAL,EAAa;QACX,MAAMqW,uBAAuB,gDAAe/W,UAAf,IACzBwB,SAASF,aAAT,CACE;AAAA;AAAA;AAAA;AAAA,CADF,EAMEhF,QAAQuF,aAAR,CAAsBlC,GANxB,CADyB,GASzB6B,SAASF,aAAT,CACE;AAAA;AAAA;AAAA;AAAA,yPADF,EAMEhF,QAAQuF,aAAR,CAAsBlC,GANxB,EAOEmB,SAAS8L,IAPX,CATJ;QAmBA,MAAM,IAAIhO,KAAJ,CAAUmY,oBAAV,CAAN;MACF;;MAEAld,QAAQ6G,MAAR,GAAiBA,MAAjB;MACA7G,QAAQiG,YAAR,GAAuBA,YAAvB;MAEAjG,QAAQsJ,MAAR,CAAe6T,WAAf,CAA2BjY,MAA3B,EAAmC,cAAnC,EAAmD,MAAM;QACvD,IAAI2B,OAAOuW,KAAP,KAAiB,WAArB,EAAkC;UAKhCpd,QAAQoJ,aAAR,CAAsBC,IAAtB,CAA2B,eAA3B;QACF;;QAGAnE,OAAOmY,aAAP,CAAqBrd,QAAQsd,iBAA7B;MACD,CAXD;MAcA,MAAM,CAACC,cAAD,IAAmB,MAAM,yBAAM,MACnCC,sBAAsBxd,OAAtB,EAA+B6G,MAA/B,CAD6B,CAA/B;;MAIA,IAAI0W,cAAJ,EAAoB;QAClB5V,SAASD,KAAT,CAAe,qCACa6V,eAAenW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sHAD3C;MAUF;;MAEApH,QAAQsd,iBAAR,GAA4BpY,OAAOuY,WAAP,CAC1B,MAAMzd,QAAQoJ,aAAR,CAAsBC,IAAtB,CAA2B,mBAA3B,CADoB,EAE1B,GAF0B,CAA5B;MAOAqU,oBAAoBzX,YAApB,EAAkCjG,QAAQ2d,YAA1C;MAEA,OAAO1X,YAAP;IACF,CAzFA;;IA2FA,MAAM2X,qBAAqBd,sBAAsB5U,IAAtB,CACzB,MAAOjC,YAAP,IAAwB;MACtB,MAAM4X,kBAAkB5X,aAAaK,UAAb,IAA2BL,aAAaM,OAAhE;;MAKA,IAAIsX,eAAJ,EAAqB;QACnB,MAAM,IAAIzT,OAAJ,CAAmBC,OAAD,IAAa;UACnCwT,gBAAgBC,gBAAhB,CAAiC,aAAjC,EAAgD,MAAM;YACpD,IAAID,gBAAgBT,KAAhB,KAA0B,WAA9B,EAA2C;cACzC,OAAO/S,SAAP;YACF;UACD,CAJD;QAKD,CANK,CAAN;MAOF;;MAGA,MAAM0T,cAAc/d,OAAd,EAAuByC,OAAvB,EAAgCub,KAAhC,CAAuCjb,MAAD,IAAW;QACrD,MAAM,IAAIgC,KAAJ,CAAU,6BAA6BhC,iCAAOqE,SAA9C,CAAN;MACD,CAFK,CAAN;MAIA,OAAOnB,YAAP;IAEJ,CAxB2B,CAA3B;;IA6BA,IAAIxD,QAAQwb,cAAZ,EAA4B;MAC1BC,0BAA0BN,kBAA1B;IACF;;IAEA,OAAOA,kBAAP;EACF,CA9HA;AA+HF,CAlIO,C;;;A6CTA,4BAAgE;EAAA,IAAtC3b,IAAsC,uEAAV,EAAU;;EACrE,IAAIA,KAAK6G,KAAT,EAAgB;IACd;EACF;;EAEAvB,QAAQyB,GAAR,CACE,KAAKrB,SAASF,aAAT,CAAuB,mBAAvB,CAA0C,EADjD,EAEE,mCAFF;AAIF,C;;;ACPO,IAAM0W,aACXne,OADwB,IAER;EAChB,OAAO,gBAAgB;IAPzB;;IAUI,IAAI,CAACA,QAAQwJ,gBAAb,EAA+B;MAC7B7B,SAASH,IAAT,CACE,iKADF;MAGA;IACF;;IAOAxH,QAAQoJ,aAAR,CAAsBC,IAAtB,CAA2B,iBAA3B;IACArJ,QAAQwJ,gBAAR,GAA2B,KAA3B;IACAtE,OAAOmY,aAAP,CAAqBrd,QAAQsd,iBAA7B;IAEAc,iBAAiB;MAAEtV,OAAO,cAAQ6U,YAAR,wBAAsB7U;IAA/B,CAAjB;EACF,CApBA;AAqBF,CAxBO,C;;;ACFA,aACLuV,eADK,EAGC;EAAA,mCADHhM,QACG;IADHA,QACG;EAAA;;EACNgM,gBAAgBC,OAAhB,CAAwB,GAAGjM,QAA3B;AACF;;AAEO,yBAAyBA,QAAzB,EAA2D;EAChEA,SAAS/P,OAAT,CAAkBsL,OAAD,IAAa;IAC5BA,QAAQhB,aAAR,CAAsB,KAAtB;EACD,CAFD;AAGF;;AAEO,uBACL2R,eADK,EAGL;EAAA,mCADGC,YACH;IADGA,YACH;EAAA;;EACA,OAAOA,aAAanW,MAAb,GAAsB,CAAtB,GAA0B,CAAC,GAAGmW,YAAJ,CAA1B,GAA8C,CAAC,GAAGD,eAAJ,CAArD;AACF,C;;;ACXO,IAAME,wBAAoD;EAC/DzW,eAAe;IACblC,KAAK,uBADQ;IAEbrD,SAAS;EAFI,CADgD;EAK/DqG,OAAO,KALwD;EAM/DmV,gBAAgB,IAN+C;EAO/D5C,oBAAoB,MAP2C;;EAQ/DlV,WAAWW,SAAX,EAAsB4X,oBAAtB,EAA4C;IAC1C,OAAO5X,cAAc4X,oBAArB;EACF;;AAV+D,CAA1D;;AAiBA,6BACLC,cADK,EAEuB;EAC5B,OAAO9a,WACL4a,qBADK,EAELE,kBAAkB,EAFb,CAAP;AAIF;;AAEO,6BACL/Q,OADK,EAEL5N,OAFK,EAGoB;EACzB,OAAQ2e,cAAD,IAAoB;IACzB3e,QAAQ2d,YAAR,GAAuBiB,oBAAoBD,cAApB,CAAvB;IACA,OAAO/Q,QAAQ5N,QAAQ2d,YAAhB,EAA8BgB,kBAAkB,EAAhD,CAAP;EACF,CAHA;AAIF,C;;;AC3CA,0BAIO3c,8BAJP;;AAKA,oBAAiCA,qDAAjC;;AACA,4BAA0CA,8DAA1C,C;;;ACEO,gCACLuK,OADK,EAEU;EACf,MAAMsS,gBAA+B;IACnCxN,IAAI9E,QAAQ8E,EADuB;IAEnCvL,KAAKyG,QAAQzG,GAFsB;IAGnCJ,QAAQ6G,QAAQ7G,MAHmB;IAInC5E,MAAMqR,UAAU5F,QAAQzL,IAAlB,EAAwByL,QAAQnK,OAAhC,CAJ6B;IAKnC2L,aAAaxB,QAAQwB,WAAR,IAAuB,aALD;IAMnC3L,SAASmK,QAAQnK,OANkB;IAOnCoM,SAAS,EAP0B;IAQnCiD,UAAU,QARyB;IASnCF,UAAU,EATyB;IAUnCM,WAAW,KAVwB;IAWnCP,OAAO,SAX4B;IAYnCI,MAAM,MAZ6B;IAanCF,gBAAgB,aAbmB;IAcnCI,WAAW,EAdwB;IAenCE,aAAa,UAfsB;IAgBnCE,UAAU,KAhByB;IAiBnC1H;EAjBmC,CAArC;EAqBA4H,kBAAkB2M,aAAlB;EAEA,OAAOA,aAAP;AACF,C;;;ADlBO,uCACL7e,OADK,EAELyC,OAFK,EAG6B;EAClC,MAAMqc,cAAc,IAAIC,oCAAJ,CAAqB;IACvC7c,MAAM,UADiC;IAEvC8c,cAAc,CAAC,IAAIC,8BAAJ,EAAD,EAAyB,IAAIC,+CAAJ,EAAzB;EAFyB,CAArB,CAApB;EAKAJ,YAAY9B,EAAZ,CAAe,SAAf,EAA0B,MAAOzQ,OAAP,IAAmB;IAC3C,MAAMsS,gBAAgBre,uBAAuB+L,OAAvB,CAAtB;IAEA,MAAMoB,YAAW,MAAMrN,cACrBue,aADqB,EAErB7e,QAAQgc,eAFa,EAGrBvZ,OAHqB,EAIrBzC,QAAQ+a,OAJa,EAKrB;MACEU,kBAAkB0D,SAAlB,EAA4B;QAC1B,OAAO;UACL5d,QAAQ4d,UAAS5d,MADZ;UAELK,YAAYud,UAASvd,UAFhB;UAGLQ,SAAS+c,UAAS/c,OAAT,CAAiBmD,GAAjB,EAHJ;UAILzE,MAAMqe,UAASre,IAJV;UAKLG,OAAOke,UAASle;QALX,CAAP;MAOF,CATF;;MAUE2a,qBACEuD,SADF,SAGE;QAAA,IADA;UAAEvR,OAAF;UAAWb,aAAX;UAA0B4F;QAA1B,CACA;;QACA,IAAI,CAAClQ,QAAQqG,KAAb,EAAoB;UAClB8E,QAAQ5E,GAAR,CACE+D,aADF,EAEEoS,SAFF,EAGEvR,OAHF,EAIE+E,aAJF;QAMF;MACF;;IAtBF,CALqB,CAAvB;;IA+BA,IAAIhF,SAAJ,EAAc;MACZpB,QAAQ6S,WAAR,CAAoBzR,SAApB;IACF;EACD,CArCD;EAuCAmR,YAAYO,KAAZ;EAEA,OAAOP,WAAP;AACF,C;;;AEhEO,6BACL9e,OADK,EAES;EACd,OAAO,qBAAqByC,OAArB,EAA8B;IACnCzC,QAAQsf,mBAAR,GAA8BC,8BAC5Bvf,OAD4B,EAE5ByC,OAF4B,CAA9B;IAKAgH,kBAAkB;MAChBrC,SAAS,kCADO;MAEhB0B,OAAOrG,QAAQqG;IAFC,CAAlB;IAKA,OAAO,MAAP;EACF,CAZA;AAaF,C;;;ACjBO,4BACL9I,OADK,EAEQ;EACb,OAAO,gBAAgB;IANzB;;IAOI,cAAQsf,mBAAR,wBAA6BE,OAA7B;IACApB,iBAAiB;MAAEtV,OAAO,cAAQ6U,YAAR,wBAAsB7U;IAA/B,CAAjB;EACF,CAHA;AAIF,C;;;ACLO,oBACL2W,MADK,EAEL3N,WAFK,EAGC;EACN,MAAM4N,UAAUD,OAAOxE,IAAvB;;EAGA,IAAIyE,QAAQC,QAAZ,EAAsB;IACpB;EACF;;EAEAF,OAAOxE,IAAP,GAAc,UAAUtR,KAAV,EAA0B;IAAA,oCAAN8F,KAAM;MAANA,KAAM;IAAA;;IACtCqC,YAAYmJ,IAAZ,CAAiBtR,KAAjB,EAAwB,GAAG8F,KAA3B;IACA,OAAOiQ,QAAQE,IAAR,CAAa,IAAb,EAAmBjW,KAAnB,EAA0B,GAAG8F,KAA7B,CAAP;EACF,CAHA;;EAMAgQ,OAAOxE,IAAP,CAAY0E,QAAZ,GAAuB,IAAvB;AACF,C;;;AtDMA,IAAIE,YAAwB,EAA5B;;AAQO,uBAEW;EAAA,oCADb7D,eACa;IADbA,eACa;EAAA;;EAChBA,gBAAgB1Z,OAAhB,CAAyBsL,OAAD,IAAa;IACnC,IAAI5K,MAAMC,OAAN,CAAc2K,OAAd,CAAJ,EACE,MAAM,IAAI7I,KAAJ,CACJ4C,SAASF,aAAT,CACE,0JADF,CADI,CAAN;EAKH,CAPD;;EAUA,IAAI,4CAAJ,EAAqB;IACnB,MAAM,IAAI1C,KAAJ,CACJ4C,SAASF,aAAT,CACE,6HADF,CADI,CAAN;EAKF;;EAEA,MAAMsT,UAAU,IAAI+E,8CAAJ,EAAhB;EACA,MAAMC,gBAAgB,IAAID,8CAAJ,EAAtB;EACAE,WAAWjF,OAAX,EAAoBgF,aAApB;EAEA,MAAM/f,UAAsC;IAG1CwJ,kBAAkB,KAHwB;IAI1CmU,cAAc,MAJ4B;IAK1C9W,QAAQ,IALkC;IAM1CZ,cAAc,IAN4B;IAO1C+V,iBAAiB,CAAC,GAAGA,eAAJ,CAPyB;IAQ1CjB,OAR0C;IAS1C3R,eAAe;MACb4T,GAAGiD,SAAH,EAAcC,QAAd,EAAwB;QACtBlgB,QAAQsJ,MAAR,CAAe6T,WAAf,CACEpV,UAAUC,aADZ,EAEE,SAFF,EAGG2B,KAAD,IAAyB;UAEvB,IAAIA,MAAM8V,MAAN,KAAiBzf,QAAQ6G,MAA7B,EAAqC;YACnC;UACF;;UAEA,MAAMO,UAAUjD,UAEdwF,MAAM3I,IAFQ,CAAhB;;UAIA,IAAI,CAACoG,OAAL,EAAc;YACZ;UACF;;UAEA,IAAIA,QAAQsJ,IAAR,KAAiBuP,SAArB,EAAgC;YAC9BC,SAASvW,KAAT,EAAgBvC,OAAhB;UACF;QAEJ,CArBA;MAsBF,CAxBa;;MAyBbiC,KAAKqH,IAAL,EAAW;QAhGjB;;QAiGQ,cAAQ7J,MAAR,wBAAgBiD,WAAhB,CAA4B4G,IAA5B;MACF;;IA3Ba,CAT2B;IAsC1CpH,QAAQ;MACN6T,YACE/I,MADF,EAEE6L,SAFF,EAGEC,QAHF,EAIE;QACA9L,OAAO0J,gBAAP,CAAwBmC,SAAxB,EAAmCC,QAAnC;QACAL,UAAU7I,IAAV,CAAe;UAAEiJ,SAAF;UAAa7L,MAAb;UAAqB8L;QAArB,CAAf;QAEA,OAAO,MAAM;UACX9L,OAAO+L,mBAAP,CAA2BF,SAA3B,EAAsCC,QAAtC;QACF,CAFA;MAGF,CAZM;;MAaNnD,qBAAqB;QACnB,WAAW;UAAE3I,MAAF;UAAU6L,SAAV;UAAqBC;QAArB,CAAX,IAA8CL,SAA9C,EAAyD;UACvDzL,OAAO+L,mBAAP,CAA2BF,SAA3B,EAAsCC,QAAtC;QACF;;QACAL,YAAY,EAAZ;MACF,CAlBM;;MAmBNtW,KAAK0W,SAAL,EAAgB;QACd,MAAMG,WAA8B,EAApC;QAEA,OAAO,IAAIhW,OAAJ,CAKL,CAACC,OAAD,EAAUgW,MAAV,KAAqB;UACrB,MAAMC,wBAAyB3W,KAAD,IAAyB;YACrD,IAAI;cACF,MAAMvC,UAAUvE,KAAKC,KAAL,CAAW6G,MAAM3I,IAAjB,CAAhB;;cAEA,IAAIoG,QAAQsJ,IAAR,KAAiBuP,SAArB,EAAgC;gBAC9B5V,QAAQjD,OAAR;cACF;YACF,CANA,CAMA,OAASrE,MAAT,EAAE;cACAsd,OAAOtd,MAAP;YACF;UACF,CAVA;;UAYAqd,SAASpJ,IAAT,CACEhX,QAAQsJ,MAAR,CAAe6T,WAAf,CACEpV,UAAUC,aADZ,EAEE,SAFF,EAGEsY,qBAHF,CADF,EAMEtgB,QAAQsJ,MAAR,CAAe6T,WAAf,CACEpV,UAAUC,aADZ,EAEE,cAFF,EAGEqY,MAHF,CANF;QAYD,CA9BM,EA8BJE,OA9BI,CA8BI,MAAM;UACfH,SAAS9d,OAAT,CAAkBke,MAAD,IAAYA,QAA7B;QACD,CAhCM,CAAP;MAiCF;;IAvDM,CAtCkC;IA+F1CC,iBACE,EAAE,mBAAmB1Y,SAArB,KAAmCd,SAAS6L,QAAT,KAAsB;EAhGjB,CAA5C;EAmGA,MAAM4N,eAAe1gB,QAAQygB,eAAR,GACjBE,oBAAoB3gB,OAApB,CADiB,GAEjB4c,mBAAmB5c,OAAnB,CAFJ;EAGA,MAAM4gB,cAAc5gB,QAAQygB,eAAR,GAChBI,mBAAmB7gB,OAAnB,CADgB,GAEhBme,WAAWne,OAAX,CAFJ;EAIA,OAAO;IACL8gB,OAAOC,oBAAoBL,YAApB,EAAkC1gB,OAAlC,CADF;;IAELghB,OAAO;MACLhhB,QAAQsJ,MAAR,CAAeyT,kBAAf;MACA/c,QAAQ+a,OAAR,CAAgBgC,kBAAhB;MACAgD,cAAchD,kBAAd;MACA6D;IACF,CAPK;;IASLK,MAAiB;MAAA,oCAAV5O,QAAU;QAAVA,QAAU;MAAA;;MACK4O,IAAIjhB,QAAQgc,eAAZ,EAA6B,GAAG3J,QAAhC;IACtB,CAXK;;IAaL6O,kBAAkB;MACIA,gBAAgBlhB,QAAQgc,eAAxB;IACtB,CAfK;;IAiBLmF,gBAA+B;MAAA,oCAAd3C,YAAc;QAAdA,YAAc;MAAA;;MAC7Bxe,QAAQgc,eAAR,GAA0BmF,aAAoB,CAC5CnF,eAD4C,EAE5C,GAAGwC,YAFyC,CAA9C;IAIF,CAtBK;;IAwBL4C,gBAAgB;MACdphB,QAAQgc,eAAR,CAAwB1Z,OAAxB,CAAiCsL,OAAD,IAAa;QAC3C,MAAM;UAAE+I,MAAF;UAAUzK;QAAV,IAAwB0B,QAAQxB,IAAtC;QACA,MAAMiV,SAASzT,QAAQxB,IAAR,CAAakV,cAAb,CAA4B,eAA5B,IACX,WADW,GAEX,QAFJ;QAIA/Z,QAAQwB,cAAR,CAAuB,GAAGsY,UAAU1K,QAApC;;QAEA,IAAIzK,SAAJ,EAAe;UACb3E,QAAQyB,GAAR,CAAY,gBAAgBkD,WAA5B;QACF;;QAEA3E,QAAQyB,GAAR,CAAY,UAAZ,EAAwB4E,OAAxB;;QAEA,IAAIA,mBAAmB/N,WAAvB,EAAoC;UAClC0H,QAAQyB,GAAR,CACE,QADF,EAEE,8BAA8B4E,QAAQxB,IAAR,CAAaiI,MAF7C;QAIF;;QAEA9M,QAAQ4B,QAAR;MACD,CAtBD;IAuBF,CAhDK;;IAkDLG,QAAQ;MACN0T,KAAY;QACV,OAAO+C,cAAc/C,EAAd,CAAiB,YAAjB,CAAP;MACF,CAHM;;MAINuE,iBAAwB;QACtB,OAAOxB,cAAcwB,cAAd,CAA6B,YAA7B,CAAP;MACF,CANM;;MAONxE,qBAA4B;QAC1B,OAAOgD,cAAchD,kBAAd,CAAiC,YAAjC,CAAP;MACF;;IATM;EAlDH,CAAP;AA8DF,C;;;AuD7NA,2BACErX,MADF,EAEE;EACA,OAAO,CAKL2O,IALK,EAMLpI,QANK,KAgBF;IACH,OAAO,IAAIpM,WAAJ,CAAgB6F,MAAhB,EAAwB2O,IAAxB,EAA8BpI,QAA9B,CAAP;EACF,CAlBA;AAmBF;;AAEO,IAAMvL,OAAO;EAClB6E,KAAKic,kBAAkB,IAAlB,CADa;EAElBC,MAAMD,kBAAkB;EAAA;EAAlB,CAFY;EAGlBtT,KAAKsT,kBAAkB;EAAA;EAAlB,CAHa;EAIlBE,MAAMF,kBAAkB;EAAA;EAAlB,CAJY;EAKlBG,KAAKH,kBAAkB;EAAA;EAAlB,CALa;EAMlBI,QAAQJ,kBAAkB;EAAA;EAAlB,CANU;EAOlBK,OAAOL,kBAAkB;EAAA;EAAlB,CAPW;EAQlB/e,SAAS+e,kBAAkB;EAAA;EAAlB;AARS,CAAb,C;;ACjCP,sBAAgDxf,kBAAhD;;AAqBA,oCACEqR,aADF,EAEEvN,GAFF,EAGE;EACA,OAAO,CAILyN,aAJK,EAQLtH,QARK,KAYF;IACH,OAAO,IAAIvM,cAAJ,CACL2T,aADK,EAELE,aAFK,EAGLzN,GAHK,EAILmG,QAJK,CAAP;EAMF,CAnBA;AAoBF;;AAEA,uCAAuCnG,GAAvC,EAAkD;EAChD,OAIEmG,QAJK,IAQF;IACH,OAAO,IAAIvM,cAAJ,CACL,KADK,EAEL,IAAIsQ,MAAJ,CAAW,IAAX,CAFK,EAGLlK,GAHK,EAILmG,QAJK,CAAP;EAMF,CAfA;AAgBF;;AAEA,IAAM6V,0BAA0B;EAS9BxO,WAAWyO,8BAA8B,GAA9B,CATmB;EAmB9BvO,OAAOwO,2BAA2BC,kCAAkBC,KAA7C,EAAoD,GAApD,CAnBuB;EA6B9BC,UAAUH,2BAA2BC,kCAAkBG,QAA7C,EAAuD,GAAvD;AA7BoB,CAAhC;;AAgCA,2BAA2Btc,GAA3B,EAAsE;EACpE,OAAO;IACLwN,WAAWyO,8BAA8Bjc,GAA9B,CADN;IAEL0N,OAAOwO,2BAA2BC,kCAAkBC,KAA7C,EAAoDpc,GAApD,CAFF;IAGLqc,UAAUH,2BAA2BC,kCAAkBG,QAA7C,EAAuDtc,GAAvD;EAHL,CAAP;AAKF;;AAEO,IAAM1F,UAAUkF,iCAClBwc,uBADkB;EAErBO,MAAMC;AAFe,EAAhB,C","names":["__export","GraphQLHandler","RESTMethods","RequestHandler","RestHandler","cleanUrl","compose","context","createResponseComposition","defaultContext","defaultResponse","graphql","graphqlContext","handleRequest","matchRequestUrl","parseIsomorphicRequest","response","rest","restContext","setupWorker","module","body","cookie","data","delay","errors","extensions","fetch","json","set","status","text","xml","__toESM","statusCode","statusText","res","import_codes","String","require","args","name","value","headers","append","forEach","value2","name2","options","serializedCookie","cookieUtils","document","JSON","parse","error2","Array","isArray","left","right","Object","entries","reduce","result","key","rightValue","leftValue","concat","isObject","mergeRight","assign","body2","stringify","payload","prevBody","jsonParse","nextBody","SET_TIMEOUT_MAX_ALLOWED_INT","MIN_SERVER_RESPONSE_TIME","MAX_SERVER_RESPONSE_TIME","NODE_SERVER_RESPONSE_TIME","getRandomServerResponseTime","Math","floor","random","durationOrMode","delayTime","Error","errorsList","useFetch","window","augmentRequestInit","requestInit","import_headers_polyfill2","__spreadProps","all","createFetchRequestParameters","input","method","requestParameters","includes","derivedRequestInit","url","href","getWorkerByRegistration","registration","absoluteWorkerUrl","findWorker","allStates","active","installing","waiting","existingStates","filter","Boolean","mockWorker","find","worker","scriptURL","relativeUrl","URL","location","origin","LIBRARY_PREFIX","message","positionals","interpolatedMessage","console","warn","formatMessage","error","devUtils","getWorkerInstance","getAbsoluteWorkerUrl","mockRegistrations","navigator","serviceWorker","getRegistrations","then","registrations","controller","length","reload","existingRegistration","update","instance","register","isWorkerMissing","scopeUrl","scope","quiet","groupCollapsed","log","workerUrl","workerScope","groupEnd","workerChannel","send","events","once","isMockingEnabled","printStartMessage","createBroadcastChannel","event","port","ports","postMessage","constructor","fns","reduceRight","leftFn","rightFn","Promise","resolve","passthrough","defaultResponseTransformers","responseOverrides","defaultTransformers","initialResponse","import_headers_polyfill3","transformers","resolvedTransformers","resolvedResponse","networkError","NetworkError","SOURCE_FRAME","BUILD_FRAME","stack","frames","split","slice","declarationFrame","frame","test","declarationPath","replace","fn","Symbol","iterator","shouldSkip","ctx","resolver","callFrame","getCallFrame","info","_request","_resolutionContext","request","resolutionContext","predicate","getPublicRequest","_parsedResult","markAsSkipped","parsedResult","shouldIntercept","publicRequest","executeResolver","wrapResolver","mockedResponse","createExecutionResult","req","resolverGenerator","isIterable","done","next","nextResponse","resolverGeneratorResult","response2","handler","import_headers_polyfill4","cookieUtils2","credentials","getAllCookies","requestCookiesString","get","import_cookies","hydrate","cookiesFromStore","from","toString","cookies","trim","cookiesFromDocument","getRequestCookies","forwardedCookies","__spreadValues","ownCookies","cookieUtils3","headersString","contentType","disposition","directives","acc","chunk","rest2","join","filename","data2","boundary","d","startsWith","map","s","boundaryRegExp","RegExp","fields","endsWith","trimStart","parsedBody","field2","contentHeaders","contentBody","parseContentHeaders","File","type","contentType2","parsedValue","toLowerCase","hasMultipartContent","parseMultipartData","hasJsonContent","actual","expected","isStringEqual","rawRequest","id","cache","referrer","referrerPolicy","redirect","mode","params","integrity","keepalive","destination","pruneGetRequestBody","bodyUsed","import_headers_polyfill6","setRequestCookies","parseBody","getResponse","handlers","relevantHandlers","executionResult","previousResults","result2","run","parsedRequest","getPublicUrlFromRequest","pathname","protocol","host","node","operationDef","definitions","def","kind","operationType","operation","operationName","query","ast","parseDocumentNode","variables","files","operations","pathArray","dotPath","lastPath","reversedPaths","reverse","paths","target","path","searchParams","_c","parsedOperations","parsedMap","extractMultipartVariables","getGraphQLInput","parseQuery","requestPublicUrl","status2","now","Date","getHours","getMinutes","getSeconds","padStart","responseHeaders","REDUNDANT_CHARACTERS_EXP","baseUrl","isAbsoluteUrl","baseURI","decodeURI","encodeURI","maybeAbsoluteUrl","getAbsoluteUrl","_","parameterName","wildcard","expression","normalizedPath","normalizePath","cleanPath","coercePath","cleanUrl2","decode","decodeURIComponent","matches","RESTMethods2","header","checkRedundantQueryParameters","getSearchParams","queryParams","paramName","push","matchesMethod","publicUrl","loggedRequest","prepareRequest","loggedResponse","prepareResponse","statusColor","getStatusCodeColor","getTimestamp","mask","field","fieldName","fieldValue","validateFieldName","onException","endpoint","resolvedOperationName","isDocumentNode","parsedNode","tryCatch","parseGraphQLRequest","hasMatchingUrl","hasMatchingOperationType","hasMatchingOperationName","requestInfo","MAX_MATCH_SCORE","MAX_SUGGESTION_COUNT","TYPE_MATCH_DELTA","groups","Infinity","hasSameMethod","methodScoreDelta","score","parsedQuery","hasSameOperationType","operationTypeScoreDelta","getScore","suggestedHandlers","suggestions","sort","leftScore","rightScore","strategy","parsedGraphQLQuery","handlerGroups","groupHandlersByType","getSuggestedHandler","getGraphQLHandlerScore","getRestHandlerScore","getSuggestedHandlersMessage","requestHeader","handlerSuggestion","generateHandlerSuggestion","messageTemplate","strategy2","generateUnhandledRequestMessage","warning","applyStrategy","bind","import_cookies2","add","persist","emitter","handleRequestOptions","emit","onPassthroughResponse","lookupError","lookupResult","onUnhandledRequest","readResponseCookies","requiredLookupResult","transformedResponse","transformResponse","onMockedResponse","setTimeout","onMockedResponseSent","createRequestListener","channel","parseWorkerRequest","requestHandlers","errorType","actualChecksum","predicatePromise","originalXhrSend","XMLHttpRequest","prototype","originalFetch","responseJson","Response","isMockedResponse","requestId","createStartHandler","customOptions","startWorkerInstance","removeAllListeners","on","createResponseListener","missingWorkerMessage","addListener","state","clearInterval","keepAliveInterval","integrityError","requestIntegrityCheck","setInterval","validateWorkerScope","startOptions","workerRegistration","pendingInstance","addEventListener","enableMocking","catch","waitUntilReady","deferNetworkRequestsUntil","createStop","printStopMessage","currentHandlers","unshift","initialHandlers","nextHandlers","DEFAULT_START_OPTIONS","mockServiceWorkerUrl","initialOptions","resolveStartOptions","mockedRequest","interceptor","import_interceptors","interceptors","import_fetch3","import_XMLHttpRequest","response3","respondWith","apply","fallbackInterceptor","createFallbackRequestListener","dispose","source","rawEmit","_isPiped","call","listeners","import_strict_event_emitter","publicEmitter","pipeEvents","eventType","callback","removeEventListener","bindings","reject","handleIncomingMessage","finally","unbind","useFallbackMode","startHandler","createFallbackStart","stopHandler","createFallbackStop","start","prepareStartHandler","stop","use","restoreHandlers","resetHandlers","printHandlers","pragma","hasOwnProperty","removeListener","createRestHandler","head","post","put","delete","patch","standardGraphQLHandlers","createGraphQLOperationHandler","createScopedGraphQLHandler","import_graphql2","QUERY","mutation","MUTATION","link","createGraphQLLink"],"sources":["/Users/donghyun/Desktop/lewns2/node_modules/msw/src/index.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/context/index.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/context/status.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/context/set.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/context/cookie.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/context/body.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/internal/jsonParse.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/internal/isObject.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/internal/mergeRight.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/context/json.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/context/data.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/context/extensions.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/context/delay.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/context/errors.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/context/fetch.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/context/text.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/context/xml.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/setupWorker/setupWorker.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/setupWorker/start/createStartHandler.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/setupWorker/start/utils/getWorkerInstance.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/setupWorker/start/utils/getWorkerByRegistration.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/url/getAbsoluteWorkerUrl.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/internal/devUtils.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/setupWorker/start/utils/printStartMessage.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/setupWorker/start/utils/enableMocking.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/createBroadcastChannel.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/NetworkError.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/request/parseWorkerRequest.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/handlers/RequestHandler.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/response.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/internal/compose.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/internal/getCallFrame.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/internal/isIterable.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/request/setRequestCookies.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/request/getRequestCookies.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/internal/parseMultipartData.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/request/parseBody.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/internal/isStringEqual.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/request/pruneGetRequestBody.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/handleRequest.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/getResponse.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/request/onUnhandledRequest.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/internal/parseGraphQLRequest.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/request/getPublicUrlFromRequest.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/logging/getStatusCodeColor.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/logging/getTimestamp.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/logging/prepareRequest.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/logging/prepareResponse.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/matching/matchRequestUrl.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/url/cleanUrl.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/url/isAbsoluteUrl.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/url/getAbsoluteUrl.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/matching/normalizePath.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/handlers/RestHandler.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/context/field.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/internal/tryCatch.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/handlers/GraphQLHandler.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/request/readResponseCookies.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/worker/createRequestListener.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/internal/requestIntegrityCheck.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/deferNetworkRequestsUntil.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/worker/createResponseListener.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/setupWorker/start/utils/validateWorkerScope.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/setupWorker/stop/utils/printStopMessage.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/setupWorker/stop/createStop.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/internal/requestHandlerUtils.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/setupWorker/start/utils/prepareStartHandler.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/worker/createFallbackRequestListener.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/request/parseIsomorphicRequest.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/setupWorker/start/createFallbackStart.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/setupWorker/stop/createFallbackStop.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/utils/internal/pipeEvents.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/rest.ts","/Users/donghyun/Desktop/lewns2/node_modules/msw/src/graphql.ts"],"sourcesContent":["import * as context from './context'\nexport { context }\n\nexport { setupWorker } from './setupWorker/setupWorker'\nexport {\n  response,\n  defaultResponse,\n  createResponseComposition,\n} from './response'\n\n/* Request handlers */\nexport { RequestHandler, defaultContext } from './handlers/RequestHandler'\nexport { rest } from './rest'\nexport { RestHandler, RESTMethods, restContext } from './handlers/RestHandler'\nexport { graphql } from './graphql'\nexport { GraphQLHandler, graphqlContext } from './handlers/GraphQLHandler'\n\n/* Utils */\nexport { matchRequestUrl } from './utils/matching/matchRequestUrl'\nexport { compose } from './utils/internal/compose'\nexport * from './utils/handleRequest'\nexport * from './utils/request/parseIsomorphicRequest'\nexport { cleanUrl } from './utils/url/cleanUrl'\n\n/**\n * Type definitions.\n */\nexport type { SetupWorkerApi, StartOptions } from './setupWorker/glossary'\nexport type { SharedOptions } from './sharedOptions'\n\nexport type {\n  MockedRequest,\n  ResponseResolver,\n  ResponseResolverReturnType,\n  AsyncResponseResolverReturnType,\n  DefaultBodyType,\n  DefaultRequestMultipartBody,\n} from './handlers/RequestHandler'\n\nexport type {\n  MockedResponse,\n  ResponseTransformer,\n  ResponseComposition,\n  ResponseCompositionOptions,\n  ResponseFunction,\n} from './response'\n\nexport type {\n  RestContext,\n  RequestQuery,\n  RestRequest,\n  ParsedRestRequest,\n} from './handlers/RestHandler'\n\nexport type {\n  GraphQLContext,\n  GraphQLVariables,\n  GraphQLRequest,\n  GraphQLRequestBody,\n  GraphQLJsonRequestBody,\n} from './handlers/GraphQLHandler'\n\nexport type { Path, PathParams, Match } from './utils/matching/matchRequestUrl'\nexport type { DelayMode } from './context/delay'\nexport { ParsedGraphQLRequest } from './utils/internal/parseGraphQLRequest'\n","export { status } from './status'\nexport { set } from './set'\nexport { cookie } from './cookie'\nexport { body } from './body'\nexport { data } from './data'\nexport { extensions } from './extensions'\nexport { delay } from './delay'\nexport { errors } from './errors'\nexport { fetch } from './fetch'\nexport { json } from './json'\nexport { text } from './text'\nexport { xml } from './xml'\n","import statuses from 'statuses/codes.json'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a response status code and text.\n * @example\n * res(ctx.status(301))\n * res(ctx.status(400, 'Custom status text'))\n * @see {@link https://mswjs.io/docs/api/context/status `ctx.status()`}\n */\nexport const status = (\n  statusCode: number,\n  statusText?: string,\n): ResponseTransformer => {\n  return (res) => {\n    res.status = statusCode\n    res.statusText =\n      statusText || statuses[String(statusCode) as keyof typeof statuses]\n\n    return res\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { ResponseTransformer } from '../response'\n\nexport type HeadersObject<KeyType extends string = string> = Record<\n  KeyType,\n  string | string[]\n>\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\n */\nexport type ForbiddenHeaderNames =\n  | 'cookie'\n  | 'cookie2'\n  | 'set-cookie'\n  | 'set-cookie2'\n\nexport type ForbiddenHeaderError<HeaderName extends string> =\n  `SafeResponseHeader: the '${HeaderName}' header cannot be set on the response. Please use the 'ctx.cookie()' function instead.`\n\n/**\n * Sets one or multiple response headers.\n * @example\n * ctx.set('Content-Type', 'text/plain')\n * ctx.set({\n *   'Accept': 'application/javascript',\n *   'Content-Type': \"text/plain\"\n * })\n * @see {@link https://mswjs.io/docs/api/context/set `ctx.set()`}\n */\nexport function set<N extends string | HeadersObject>(\n  ...args: N extends string\n    ? Lowercase<N> extends ForbiddenHeaderNames\n      ? ForbiddenHeaderError<N>\n      : [N, string]\n    : N extends HeadersObject<infer CookieName>\n    ? Lowercase<CookieName> extends ForbiddenHeaderNames\n      ? ForbiddenHeaderError<CookieName>\n      : [N]\n    : [N]\n): ResponseTransformer {\n  return (res) => {\n    const [name, value] = args\n\n    if (typeof name === 'string') {\n      res.headers.append(name, value as string)\n    } else {\n      const headers = objectToHeaders(name)\n      headers.forEach((value, name) => {\n        res.headers.append(name, value)\n      })\n    }\n\n    return res\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a given cookie on the mocked response.\n * @example res(ctx.cookie('name', 'value'))\n */\nexport const cookie = (\n  name: string,\n  value: string,\n  options?: cookieUtils.CookieSerializeOptions,\n): ResponseTransformer => {\n  return (res) => {\n    const serializedCookie = cookieUtils.serialize(name, value, options)\n    res.headers.set('Set-Cookie', serializedCookie)\n\n    if (typeof document !== 'undefined') {\n      document.cookie = serializedCookie\n    }\n\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a raw response body. Does not append any `Content-Type` headers.\n * @example\n * res(ctx.body('Successful response'))\n * res(ctx.body(JSON.stringify({ key: 'value' })))\n * @see {@link https://mswjs.io/docs/api/context/body `ctx.body()`}\n */\nexport const body = <\n  BodyType extends string | Blob | BufferSource | ReadableStream | FormData,\n>(\n  value: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.body = value\n    return res\n  }\n}\n","/**\n * Parses a given value into a JSON.\n * Does not throw an exception on an invalid JSON string.\n */\nexport function jsonParse<ValueType extends Record<string, any>>(\n  value: any,\n): ValueType | undefined {\n  try {\n    return JSON.parse(value)\n  } catch (error) {\n    return undefined\n  }\n}\n","/**\n * Determines if the given value is an object.\n */\nexport function isObject(value: any): boolean {\n  return value != null && typeof value === 'object' && !Array.isArray(value)\n}\n","import { isObject } from './isObject'\n\n/**\n * Deeply merges two given objects with the right one\n * having a priority during property assignment.\n */\nexport function mergeRight(\n  left: Record<string, any>,\n  right: Record<string, any>,\n) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key]\n\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue)\n      return result\n    }\n\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue)\n      return result\n    }\n\n    result[key] = rightValue\n    return result\n  }, Object.assign({}, left))\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets the given value as the JSON body of the response.\n * Appends a `Content-Type: application/json` header on the\n * mocked response.\n * @example\n * res(ctx.json('Some string'))\n * res(ctx.json({ key: 'value' }))\n * res(ctx.json([1, '2', false, { ok: true }]))\n * @see {@link https://mswjs.io/docs/api/context/json `ctx.json()`}\n */\nexport const json = <BodyTypeJSON>(\n  body: BodyTypeJSON,\n): ResponseTransformer<BodyTypeJSON> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'application/json')\n    res.body = JSON.stringify(body) as any\n\n    return res\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets a given payload as a GraphQL response body.\n * @example\n * res(ctx.data({ user: { firstName: 'John' }}))\n * @see {@link https://mswjs.io/docs/api/context/data `ctx.data()`}\n */\nexport const data: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { data: payload })\n\n    return json(nextBody)(res)\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets the GraphQL extensions on a given response.\n * @example\n * res(ctx.extensions({ tracing: { version: 1 }}))\n * @see {@link https://mswjs.io/docs/api/context/extensions `ctx.extensions()`}\n */\nexport const extensions: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { extensions: payload })\n    return json(nextBody)(res)\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { ResponseTransformer } from '../response'\n\nexport const SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647\nexport const MIN_SERVER_RESPONSE_TIME = 100\nexport const MAX_SERVER_RESPONSE_TIME = 400\nexport const NODE_SERVER_RESPONSE_TIME = 5\n\nconst getRandomServerResponseTime = () => {\n  if (isNodeProcess()) {\n    return NODE_SERVER_RESPONSE_TIME\n  }\n\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) +\n      MIN_SERVER_RESPONSE_TIME,\n  )\n}\n\nexport type DelayMode = 'real' | 'infinite'\n\n/**\n * Delays the response by the given duration (ms).\n * @example\n * res(ctx.delay(1200)) // delay response by 1200ms\n * res(ctx.delay()) // emulate realistic server response time\n * res(ctx.delay('infinite')) // delay response infinitely\n * @see {@link https://mswjs.io/docs/api/context/delay `ctx.delay()`}\n */\nexport const delay = (\n  durationOrMode?: DelayMode | number,\n): ResponseTransformer => {\n  return (res) => {\n    let delayTime: number\n\n    if (typeof durationOrMode === 'string') {\n      switch (durationOrMode) {\n        case 'infinite': {\n          // Using `Infinity` as a delay value executes the response timeout immediately.\n          // Instead, use the maximum allowed integer for `setTimeout`.\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT\n          break\n        }\n        case 'real': {\n          delayTime = getRandomServerResponseTime()\n          break\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`,\n          )\n        }\n      }\n    } else if (typeof durationOrMode === 'undefined') {\n      // Use random realistic server response time when no explicit delay duration was provided.\n      delayTime = getRandomServerResponseTime()\n    } else {\n      // Guard against passing values like `Infinity` or `Number.MAX_VALUE`\n      // as the response delay duration. They don't produce the result you may expect.\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`,\n        )\n      }\n\n      delayTime = durationOrMode\n    }\n\n    res.delay = delayTime\n    return res\n  }\n}\n","import { GraphQLError } from 'graphql'\nimport { ResponseTransformer } from '../response'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\n/**\n * Sets a given list of GraphQL errors on the mocked response.\n * @example res(ctx.errors([{ message: 'Unauthorized' }]))\n * @see {@link https://mswjs.io/docs/api/context/errors}\n */\nexport const errors = <\n  ErrorsType extends readonly Partial<GraphQLError>[] | null | undefined,\n>(\n  errorsList: ErrorsType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    if (errorsList == null) {\n      return res\n    }\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { errors: errorsList })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { Headers } from 'headers-polyfill'\nimport type { MockedRequest } from '../handlers/RequestHandler'\n\nconst useFetch: (input: RequestInfo, init?: RequestInit) => Promise<Response> =\n  isNodeProcess() ? require('node-fetch') : window.fetch\n\nexport const augmentRequestInit = (requestInit: RequestInit): RequestInit => {\n  const headers = new Headers(requestInit.headers)\n  headers.set('x-msw-bypass', 'true')\n\n  return {\n    ...requestInit,\n    headers: headers.all(),\n  }\n}\n\nconst createFetchRequestParameters = (input: MockedRequest): RequestInit => {\n  const { body, method } = input\n  const requestParameters: RequestInit = {\n    ...input,\n    body: undefined,\n  }\n\n  if (['GET', 'HEAD'].includes(method)) {\n    return requestParameters\n  }\n\n  if (\n    typeof body === 'object' ||\n    typeof body === 'number' ||\n    typeof body === 'boolean'\n  ) {\n    requestParameters.body = JSON.stringify(body)\n  } else {\n    requestParameters.body = body\n  }\n\n  return requestParameters\n}\n\n/**\n * Performs a bypassed request inside a request handler.\n * @example\n * const originalResponse = await ctx.fetch(req)\n * @see {@link https://mswjs.io/docs/api/context/fetch `ctx.fetch()`}\n */\nexport const fetch = (\n  input: string | MockedRequest,\n  requestInit: RequestInit = {},\n): Promise<Response> => {\n  if (typeof input === 'string') {\n    return useFetch(input, augmentRequestInit(requestInit))\n  }\n\n  const requestParameters = createFetchRequestParameters(input)\n  const derivedRequestInit = augmentRequestInit(requestParameters)\n\n  return useFetch(input.url.href, derivedRequestInit)\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a textual response body. Appends a `Content-Type: text/plain`\n * header on the mocked response.\n * @example res(ctx.text('Successful response'))\n * @see {@link https://mswjs.io/docs/api/context/text `ctx.text()`}\n */\nexport const text = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/plain')\n    res.body = body\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets an XML response body. Appends a `Content-Type: text/xml` header\n * on the mocked response.\n * @example\n * res(ctx.xml('<node key=\"value\">Content</node>'))\n * @see {@link https://mswjs.io/docs/api/context/xml `ctx.xml()`}\n */\nexport const xml = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/xml')\n    res.body = body\n    return res\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { StrictEventEmitter } from 'strict-event-emitter'\nimport {\n  SetupWorkerInternalContext,\n  SetupWorkerApi,\n  ServiceWorkerIncomingEventsMap,\n  WorkerLifecycleEventsMap,\n} from './glossary'\nimport { createStartHandler } from './start/createStartHandler'\nimport { createStop } from './stop/createStop'\nimport * as requestHandlerUtils from '../utils/internal/requestHandlerUtils'\nimport { ServiceWorkerMessage } from '../utils/createBroadcastChannel'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { RestHandler } from '../handlers/RestHandler'\nimport { prepareStartHandler } from './start/utils/prepareStartHandler'\nimport { createFallbackStart } from './start/createFallbackStart'\nimport { createFallbackStop } from './stop/createFallbackStop'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { pipeEvents } from '../utils/internal/pipeEvents'\n\ninterface Listener {\n  target: EventTarget\n  eventType: string\n  callback: EventListener\n}\n\n// Declare the list of event handlers on the module's scope\n// so it persists between Fash refreshes of the application's code.\nlet listeners: Listener[] = []\n\n/**\n * Creates a new mock Service Worker registration\n * with the given request handlers.\n * @param {RequestHandler[]} requestHandlers List of request handlers\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker`}\n */\nexport function setupWorker(\n  ...requestHandlers: RequestHandler[]\n): SetupWorkerApi {\n  requestHandlers.forEach((handler) => {\n    if (Array.isArray(handler))\n      throw new Error(\n        devUtils.formatMessage(\n          'Failed to call \"setupWorker\" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).',\n        ),\n      )\n  })\n\n  // Error when attempting to run this function in a Node.js environment.\n  if (isNodeProcess()) {\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.',\n      ),\n    )\n  }\n\n  const emitter = new StrictEventEmitter<WorkerLifecycleEventsMap>()\n  const publicEmitter = new StrictEventEmitter<WorkerLifecycleEventsMap>()\n  pipeEvents(emitter, publicEmitter)\n\n  const context: SetupWorkerInternalContext = {\n    // Mocking is not considered enabled until the worker\n    // signals back the successful activation event.\n    isMockingEnabled: false,\n    startOptions: undefined,\n    worker: null,\n    registration: null,\n    requestHandlers: [...requestHandlers],\n    emitter,\n    workerChannel: {\n      on(eventType, callback) {\n        context.events.addListener(\n          navigator.serviceWorker,\n          'message',\n          (event: MessageEvent) => {\n            // Avoid messages broadcasted from unrelated workers.\n            if (event.source !== context.worker) {\n              return\n            }\n\n            const message = jsonParse<\n              ServiceWorkerMessage<typeof eventType, any>\n            >(event.data)\n\n            if (!message) {\n              return\n            }\n\n            if (message.type === eventType) {\n              callback(event, message)\n            }\n          },\n        )\n      },\n      send(type) {\n        context.worker?.postMessage(type)\n      },\n    },\n    events: {\n      addListener(\n        target: EventTarget,\n        eventType: string,\n        callback: EventListener,\n      ) {\n        target.addEventListener(eventType, callback)\n        listeners.push({ eventType, target, callback })\n\n        return () => {\n          target.removeEventListener(eventType, callback)\n        }\n      },\n      removeAllListeners() {\n        for (const { target, eventType, callback } of listeners) {\n          target.removeEventListener(eventType, callback)\n        }\n        listeners = []\n      },\n      once(eventType) {\n        const bindings: Array<() => void> = []\n\n        return new Promise<\n          ServiceWorkerMessage<\n            typeof eventType,\n            ServiceWorkerIncomingEventsMap[typeof eventType]\n          >\n        >((resolve, reject) => {\n          const handleIncomingMessage = (event: MessageEvent) => {\n            try {\n              const message = JSON.parse(event.data)\n\n              if (message.type === eventType) {\n                resolve(message)\n              }\n            } catch (error) {\n              reject(error)\n            }\n          }\n\n          bindings.push(\n            context.events.addListener(\n              navigator.serviceWorker,\n              'message',\n              handleIncomingMessage,\n            ),\n            context.events.addListener(\n              navigator.serviceWorker,\n              'messageerror',\n              reject,\n            ),\n          )\n        }).finally(() => {\n          bindings.forEach((unbind) => unbind())\n        })\n      },\n    },\n    useFallbackMode:\n      !('serviceWorker' in navigator) || location.protocol === 'file:',\n  }\n\n  const startHandler = context.useFallbackMode\n    ? createFallbackStart(context)\n    : createStartHandler(context)\n  const stopHandler = context.useFallbackMode\n    ? createFallbackStop(context)\n    : createStop(context)\n\n  return {\n    start: prepareStartHandler(startHandler, context),\n    stop() {\n      context.events.removeAllListeners()\n      context.emitter.removeAllListeners()\n      publicEmitter.removeAllListeners()\n      stopHandler()\n    },\n\n    use(...handlers) {\n      requestHandlerUtils.use(context.requestHandlers, ...handlers)\n    },\n\n    restoreHandlers() {\n      requestHandlerUtils.restoreHandlers(context.requestHandlers)\n    },\n\n    resetHandlers(...nextHandlers) {\n      context.requestHandlers = requestHandlerUtils.resetHandlers(\n        requestHandlers,\n        ...nextHandlers,\n      )\n    },\n\n    printHandlers() {\n      context.requestHandlers.forEach((handler) => {\n        const { header, callFrame } = handler.info\n        const pragma = handler.info.hasOwnProperty('operationType')\n          ? '[graphql]'\n          : '[rest]'\n\n        console.groupCollapsed(`${pragma} ${header}`)\n\n        if (callFrame) {\n          console.log(`Declaration: ${callFrame}`)\n        }\n\n        console.log('Handler:', handler)\n\n        if (handler instanceof RestHandler) {\n          console.log(\n            'Match:',\n            `https://mswjs.io/repl?path=${handler.info.path}`,\n          )\n        }\n\n        console.groupEnd()\n      })\n    },\n\n    events: {\n      on(...args) {\n        return publicEmitter.on(...args)\n      },\n      removeListener(...args) {\n        return publicEmitter.removeListener(...args)\n      },\n      removeAllListeners(...args) {\n        return publicEmitter.removeAllListeners(...args)\n      },\n    },\n  }\n}\n","import { until } from '@open-draft/until'\nimport { getWorkerInstance } from './utils/getWorkerInstance'\nimport { enableMocking } from './utils/enableMocking'\nimport { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { createRequestListener } from '../../utils/worker/createRequestListener'\nimport { requestIntegrityCheck } from '../../utils/internal/requestIntegrityCheck'\nimport { deferNetworkRequestsUntil } from '../../utils/deferNetworkRequestsUntil'\nimport { createResponseListener } from '../../utils/worker/createResponseListener'\nimport { validateWorkerScope } from './utils/validateWorkerScope'\nimport { devUtils } from '../../utils/internal/devUtils'\n\nexport const createStartHandler = (\n  context: SetupWorkerInternalContext,\n): StartHandler => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      // Remove all previously existing event listeners.\n      // This way none of the listeners persists between Fast refresh\n      // of the application's code.\n      context.events.removeAllListeners()\n\n      // Handle requests signaled by the worker.\n      context.workerChannel.on(\n        'REQUEST',\n        createRequestListener(context, options),\n      )\n\n      context.workerChannel.on('RESPONSE', createResponseListener(context))\n\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker,\n      )\n\n      const [worker, registration] = instance\n\n      if (!worker) {\n        const missingWorkerMessage = customOptions?.findWorker\n          ? devUtils.formatMessage(\n              `Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n              options.serviceWorker.url,\n            )\n          : devUtils.formatMessage(\n              `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n              options.serviceWorker.url,\n              location.host,\n            )\n\n        throw new Error(missingWorkerMessage)\n      }\n\n      context.worker = worker\n      context.registration = registration\n\n      context.events.addListener(window, 'beforeunload', () => {\n        if (worker.state !== 'redundant') {\n          // Notify the Service Worker that this client has closed.\n          // Internally, it's similar to disabling the mocking, only\n          // client close event has a handler that self-terminates\n          // the Service Worker when there are no open clients.\n          context.workerChannel.send('CLIENT_CLOSED')\n        }\n        // Make sure we're always clearing the interval - there are reports that not doing this can\n        // cause memory leaks in headless browser environments.\n        window.clearInterval(context.keepAliveInterval)\n      })\n\n      // Check if the active Service Worker is the latest published one\n      const [integrityError] = await until(() =>\n        requestIntegrityCheck(context, worker),\n      )\n\n      if (integrityError) {\n        devUtils.error(`\\\nDetected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues\\\n      `)\n      }\n\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.send('KEEPALIVE_REQUEST'),\n        5000,\n      )\n\n      // Warn the user when loading the page that lies outside\n      // of the worker's scope.\n      validateWorkerScope(registration, context.startOptions)\n\n      return registration\n    }\n\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting\n\n        // Wait until the worker is activated.\n        // Assume the worker is already activated if there's no pending registration\n        // (i.e. when reloading the page after a successful activation).\n        if (pendingInstance) {\n          await new Promise<void>((resolve) => {\n            pendingInstance.addEventListener('statechange', () => {\n              if (pendingInstance.state === 'activated') {\n                return resolve()\n              }\n            })\n          })\n        }\n\n        // Print the activation message only after the worker has been activated.\n        await enableMocking(context, options).catch((error) => {\n          throw new Error(`Failed to enable mocking: ${error?.message}`)\n        })\n\n        return registration\n      },\n    )\n\n    // Defer any network requests until the Service Worker instance is ready.\n    // This prevents a race condition between the Service Worker registration\n    // and application's runtime requests (i.e. requests on mount).\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration)\n    }\n\n    return workerRegistration\n  }\n}\n","import { until } from '@open-draft/until'\nimport { getWorkerByRegistration } from './getWorkerByRegistration'\nimport { ServiceWorkerInstanceTuple, FindWorker } from '../../glossary'\nimport { getAbsoluteWorkerUrl } from '../../../utils/url/getAbsoluteWorkerUrl'\nimport { devUtils } from '../../../utils/internal/devUtils'\n\n/**\n * Returns an active Service Worker instance.\n * When not found, registers a new Service Worker.\n */\nexport const getWorkerInstance = async (\n  url: string,\n  options: RegistrationOptions = {},\n  findWorker: FindWorker,\n): Promise<ServiceWorkerInstanceTuple> => {\n  // Resolve the absolute Service Worker URL.\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url)\n\n  const mockRegistrations = await navigator.serviceWorker\n    .getRegistrations()\n    .then((registrations) =>\n      registrations.filter((registration) =>\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n      ),\n    )\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    // Reload the page when it has associated workers, but no active controller.\n    // The absence of a controller can mean either:\n    // - page has no Service Worker associated with it\n    // - page has been hard-reloaded and its workers won't be used until the next reload.\n    // Since we've checked that there are registrations associated with this page,\n    // at this point we are sure it's hard reload that falls into this clause.\n    location.reload()\n  }\n\n  const [existingRegistration] = mockRegistrations\n\n  if (existingRegistration) {\n    // When the Service Worker is registered, update it and return the reference.\n    return existingRegistration.update().then(() => {\n      return [\n        getWorkerByRegistration(\n          existingRegistration,\n          absoluteWorkerUrl,\n          findWorker,\n        ),\n        existingRegistration,\n      ]\n    })\n  }\n\n  // When the Service Worker wasn't found, register it anew and return the reference.\n  const [error, instance] = await until<ServiceWorkerInstanceTuple>(\n    async () => {\n      const registration = await navigator.serviceWorker.register(url, options)\n      return [\n        // Compare existing worker registration by its worker URL,\n        // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n        registration,\n      ]\n    },\n  )\n\n  // Handle Service Worker registration errors.\n  if (error) {\n    const isWorkerMissing = error.message.includes('(404)')\n\n    // Produce a custom error message when given a non-existing Service Worker url.\n    // Suggest developers to check their setup.\n    if (isWorkerMissing) {\n      const scopeUrl = new URL(options?.scope || '/', location.href)\n\n      throw new Error(\n        devUtils.formatMessage(`\\\nFailed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`),\n      )\n    }\n\n    // Fallback error message for any other registration errors.\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to register the Service Worker:\\n\\n%s',\n        error.message,\n      ),\n    )\n  }\n\n  return instance\n}\n","import { FindWorker } from '../../glossary'\n\n/**\n * Attempts to resolve a Service Worker instance from a given registration,\n * regardless of its state (active, installing, waiting).\n */\nexport const getWorkerByRegistration = (\n  registration: ServiceWorkerRegistration,\n  absoluteWorkerUrl: string,\n  findWorker: FindWorker,\n): ServiceWorker | null => {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting,\n  ]\n  const existingStates = allStates.filter(Boolean) as ServiceWorker[]\n  const mockWorker = existingStates.find((worker) => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl)\n  })\n\n  return mockWorker || null\n}\n","/**\n * Returns an absolute Service Worker URL based on the given\n * relative URL (known during the registration).\n */\nexport function getAbsoluteWorkerUrl(relativeUrl: string): string {\n  return new URL(relativeUrl, location.origin).href\n}\n","import { format } from 'outvariant'\n\nconst LIBRARY_PREFIX = '[MSW]'\n\n/**\n * Formats a given message by appending the library's prefix string.\n */\nfunction formatMessage(message: string, ...positionals: any[]): string {\n  const interpolatedMessage = format(message, ...positionals)\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`\n}\n\n/**\n * Prints a library-specific warning.\n */\nfunction warn(message: string, ...positionals: any[]): void {\n  console.warn(formatMessage(message, ...positionals))\n}\n\n/**\n * Prints a library-specific error.\n */\nfunction error(message: string, ...positionals: any[]): void {\n  console.error(formatMessage(message, ...positionals))\n}\n\nexport const devUtils = {\n  formatMessage,\n  warn,\n  error,\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\n\nexport interface PrintStartMessageArgs {\n  quiet?: boolean\n  message?: string\n  workerUrl?: string\n  workerScope?: string\n}\n\n/**\n * Prints a worker activation message in the browser's console.\n */\nexport function printStartMessage(args: PrintStartMessageArgs = {}) {\n  if (args.quiet) {\n    return\n  }\n\n  const message = args.message || 'Mocking enabled.'\n\n  console.groupCollapsed(\n    `%c${devUtils.formatMessage(message)}`,\n    'color:orangered;font-weight:bold;',\n  )\n  console.log(\n    '%cDocumentation: %chttps://mswjs.io/docs',\n    'font-weight:bold',\n    'font-weight:normal',\n  )\n  console.log('Found an issue? https://github.com/mswjs/msw/issues')\n\n  if (args.workerUrl) {\n    console.log('Worker script URL:', args.workerUrl)\n  }\n\n  if (args.workerScope) {\n    console.log('Worker scope:', args.workerScope)\n  }\n\n  console.groupEnd()\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\nimport { StartOptions, SetupWorkerInternalContext } from '../../glossary'\nimport { printStartMessage } from './printStartMessage'\n\n/**\n * Signals the worker to enable the interception of requests.\n */\nexport async function enableMocking(\n  context: SetupWorkerInternalContext,\n  options: StartOptions,\n) {\n  context.workerChannel.send('MOCK_ACTIVATE')\n  await context.events.once('MOCKING_ENABLED')\n\n  // Warn the developer on multiple \"worker.start()\" calls.\n  // While this will not affect the worker in any way,\n  // it likely indicates an issue with the developer's code.\n  if (context.isMockingEnabled) {\n    devUtils.warn(\n      `Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`,\n    )\n    return\n  }\n\n  context.isMockingEnabled = true\n\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: context.registration?.scope,\n    workerUrl: context.worker?.scriptURL,\n  })\n}\n","import {\n  ServiceWorkerFetchEventTypes,\n  ServiceWorkerIncomingEventsMap,\n} from '../setupWorker/glossary'\n\nexport interface ServiceWorkerMessage<\n  EventType extends keyof ServiceWorkerIncomingEventsMap,\n  EventPayload,\n> {\n  type: EventType\n  payload: EventPayload\n}\n\n/**\n * Creates a communication channel between the client\n * and the Service Worker associated with the given event.\n */\nexport const createBroadcastChannel = (event: MessageEvent) => {\n  const port = event.ports[0]\n\n  return {\n    /**\n     * Sends a text message to the connected Service Worker.\n     */\n    send(message: {\n      type: ServiceWorkerFetchEventTypes\n      payload?: Record<string, any> | string\n    }) {\n      if (port) {\n        port.postMessage(message)\n      }\n    },\n  }\n}\n","export class NetworkError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'NetworkError'\n  }\n}\n","import { Headers } from 'headers-polyfill'\nimport { passthrough } from '../../handlers/RequestHandler'\nimport { RestRequest } from '../../handlers/RestHandler'\nimport { ServiceWorkerIncomingRequest } from '../../setupWorker/glossary'\nimport { setRequestCookies } from './setRequestCookies'\nimport { parseBody } from './parseBody'\nimport { pruneGetRequestBody } from './pruneGetRequestBody'\n\n/**\n * Converts a given request received from the Service Worker\n * into a `MockedRequest` instance.\n */\nexport function parseWorkerRequest(\n  rawRequest: ServiceWorkerIncomingRequest,\n): RestRequest {\n  const request: RestRequest = {\n    id: rawRequest.id,\n    cache: rawRequest.cache,\n    credentials: rawRequest.credentials,\n    method: rawRequest.method,\n    url: new URL(rawRequest.url),\n    referrer: rawRequest.referrer,\n    referrerPolicy: rawRequest.referrerPolicy,\n    redirect: rawRequest.redirect,\n    mode: rawRequest.mode,\n    params: {},\n    cookies: {},\n    integrity: rawRequest.integrity,\n    keepalive: rawRequest.keepalive,\n    destination: rawRequest.destination,\n    body: pruneGetRequestBody(rawRequest),\n    bodyUsed: rawRequest.bodyUsed,\n    headers: new Headers(rawRequest.headers),\n    passthrough,\n  }\n\n  // Set document cookies on the request.\n  setRequestCookies(request)\n\n  // Parse the request's body based on the \"Content-Type\" header.\n  request.body = parseBody(request.body, request.headers)\n\n  return request\n}\n","import { Headers } from 'headers-polyfill'\nimport {\n  MaybePromise,\n  MockedResponse,\n  response,\n  ResponseComposition,\n} from '../response'\nimport { getCallFrame } from '../utils/internal/getCallFrame'\nimport { isIterable } from '../utils/internal/isIterable'\nimport { status } from '../context/status'\nimport { set } from '../context/set'\nimport { delay } from '../context/delay'\nimport { fetch } from '../context/fetch'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { SerializedResponse } from '../setupWorker/glossary'\n\nexport type DefaultContext = {\n  status: typeof status\n  set: typeof set\n  delay: typeof delay\n  fetch: typeof fetch\n}\n\nexport const defaultContext: DefaultContext = {\n  status,\n  set,\n  delay,\n  fetch,\n}\n\nexport type DefaultRequestMultipartBody = Record<\n  string,\n  string | File | (string | File)[]\n>\n\nexport type DefaultBodyType =\n  | Record<string, any>\n  | DefaultRequestMultipartBody\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n\nexport interface MockedRequest<Body = DefaultBodyType> {\n  id: string\n  url: URL\n  method: Request['method']\n  headers: Headers\n  cookies: Record<string, string>\n  mode: Request['mode']\n  keepalive: Request['keepalive']\n  cache: Request['cache']\n  destination: Request['destination']\n  integrity: Request['integrity']\n  credentials: Request['credentials']\n  redirect: Request['redirect']\n  referrer: Request['referrer']\n  referrerPolicy: Request['referrerPolicy']\n  body: Body\n  bodyUsed: Request['bodyUsed']\n  passthrough: typeof passthrough\n}\n\nexport interface RequestHandlerDefaultInfo {\n  header: string\n}\n\nexport interface RequestHandlerInternalInfo {\n  callFrame?: string\n}\n\ntype ContextMap = Record<string, (...args: any[]) => any>\n\nexport type ResponseResolverReturnType<ReturnType> =\n  | ReturnType\n  | undefined\n  | void\n\nexport type MaybeAsyncResponseResolverReturnType<ReturnType> = MaybePromise<\n  ResponseResolverReturnType<ReturnType>\n>\n\nexport type AsyncResponseResolverReturnType<ReturnType> =\n  | MaybeAsyncResponseResolverReturnType<ReturnType>\n  | Generator<\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>\n    >\n\nexport type ResponseResolver<\n  RequestType = MockedRequest,\n  ContextType = typeof defaultContext,\n  BodyType = any,\n> = (\n  req: RequestType,\n  res: ResponseComposition<BodyType>,\n  context: ContextType,\n) => AsyncResponseResolverReturnType<MockedResponse<BodyType>>\n\nexport interface RequestHandlerOptions<HandlerInfo> {\n  info: HandlerInfo\n  resolver: ResponseResolver<any, any>\n  ctx?: ContextMap\n}\n\nexport interface RequestHandlerExecutionResult<PublicRequestType> {\n  handler: RequestHandler\n  parsedResult: any\n  request: PublicRequestType\n  response?: MockedResponse\n}\n\nexport abstract class RequestHandler<\n  HandlerInfo extends RequestHandlerDefaultInfo = RequestHandlerDefaultInfo,\n  Request extends MockedRequest = MockedRequest,\n  ParsedResult = any,\n  PublicRequest extends MockedRequest = Request,\n> {\n  public info: HandlerInfo & RequestHandlerInternalInfo\n  public shouldSkip: boolean\n\n  private ctx: ContextMap\n  private resolverGenerator?: Generator<\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>\n  >\n  private resolverGeneratorResult?: MaybeAsyncResponseResolverReturnType<any>\n\n  protected resolver: ResponseResolver<any, any>\n\n  constructor(options: RequestHandlerOptions<HandlerInfo>) {\n    this.shouldSkip = false\n    this.ctx = options.ctx || defaultContext\n    this.resolver = options.resolver\n\n    const callFrame = getCallFrame(new Error())\n\n    this.info = {\n      ...options.info,\n      callFrame,\n    }\n  }\n\n  /**\n   * Determine if the captured request should be mocked.\n   */\n  abstract predicate(\n    request: MockedRequest,\n    parsedResult: ParsedResult,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean\n\n  /**\n   * Print out the successfully handled request.\n   */\n  abstract log(\n    request: Request,\n    response: SerializedResponse<any>,\n    handler: this,\n    parsedResult: ParsedResult,\n  ): void\n\n  /**\n   * Parse the captured request to extract additional information from it.\n   * Parsed result is then exposed to other methods of this request handler.\n   */\n  parse(\n    _request: MockedRequest,\n    _resolutionContext?: ResponseResolutionContext,\n  ): ParsedResult {\n    return null as any\n  }\n\n  /**\n   * Test if this handler matches the given request.\n   */\n  public test(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean {\n    return this.predicate(\n      request,\n      this.parse(request, resolutionContext),\n      resolutionContext,\n    )\n  }\n\n  /**\n   * Derive the publicly exposed request (`req`) instance of the response resolver\n   * from the captured request and its parsed result.\n   */\n  protected getPublicRequest(\n    request: MockedRequest,\n    _parsedResult: ParsedResult,\n  ) {\n    return request as PublicRequest\n  }\n\n  public markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip\n  }\n\n  /**\n   * Execute this request handler and produce a mocked response\n   * using the given resolver function.\n   */\n  public async run(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): Promise<RequestHandlerExecutionResult<PublicRequest> | null> {\n    if (this.shouldSkip) {\n      return null\n    }\n\n    const parsedResult = this.parse(request, resolutionContext)\n    const shouldIntercept = this.predicate(\n      request,\n      parsedResult,\n      resolutionContext,\n    )\n\n    if (!shouldIntercept) {\n      return null\n    }\n\n    const publicRequest = this.getPublicRequest(request, parsedResult)\n\n    // Create a response extraction wrapper around the resolver\n    // since it can be both an async function and a generator.\n    const executeResolver = this.wrapResolver(this.resolver)\n    const mockedResponse = await executeResolver(\n      publicRequest,\n      response,\n      this.ctx,\n    )\n\n    return this.createExecutionResult(\n      parsedResult,\n      publicRequest,\n      mockedResponse,\n    )\n  }\n\n  private wrapResolver(\n    resolver: ResponseResolver<any, any>,\n  ): ResponseResolver<AsyncResponseResolverReturnType<any>, any> {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || (await resolver(req, res, ctx))\n\n      if (isIterable<AsyncResponseResolverReturnType<any>>(result)) {\n        const { value, done } = result[Symbol.iterator]().next()\n        const nextResponse = await value\n\n        // If the generator is done and there is no next value,\n        // return the previous generator's value.\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult\n        }\n\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result\n        }\n\n        this.resolverGeneratorResult = nextResponse\n        return nextResponse\n      }\n\n      return result\n    }\n  }\n\n  private createExecutionResult(\n    parsedResult: ParsedResult,\n    request: PublicRequest,\n    response: any,\n  ): RequestHandlerExecutionResult<PublicRequest> {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response || null,\n    }\n  }\n}\n\n/**\n * Bypass this intercepted request.\n * This will make a call to the actual endpoint requested.\n */\nexport function passthrough(): MockedResponse<null> {\n  // Constructing a dummy \"101 Continue\" mocked response\n  // to keep the return type of the resolver consistent.\n  return {\n    status: 101,\n    statusText: 'Continue',\n    headers: new Headers(),\n    body: null,\n    // Setting \"passthrough\" to true will signal the response pipeline\n    // to perform this intercepted request as-is.\n    passthrough: true,\n    once: false,\n  }\n}\n","import { Headers } from 'headers-polyfill'\nimport { DefaultBodyType } from './handlers/RequestHandler'\nimport { compose } from './utils/internal/compose'\nimport { NetworkError } from './utils/NetworkError'\n\nexport type MaybePromise<ValueType = any> = ValueType | Promise<ValueType>\n\n/**\n * Internal representation of a mocked response instance.\n */\nexport interface MockedResponse<BodyType extends DefaultBodyType = any> {\n  body: BodyType\n  status: number\n  statusText: string\n  headers: Headers\n  once: boolean\n  passthrough: boolean\n  delay?: number\n}\n\nexport type ResponseTransformer<\n  BodyType extends TransformerBodyType = any,\n  TransformerBodyType = any,\n> = (\n  res: MockedResponse<TransformerBodyType>,\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseFunction<BodyType = any> = (\n  ...transformers: ResponseTransformer<BodyType>[]\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseComposition<BodyType = any> = ResponseFunction<BodyType> & {\n  /**\n   * Respond using a given mocked response to the first captured request.\n   * Does not affect any subsequent captured requests.\n   */\n  once: ResponseFunction<BodyType>\n  networkError: (message: string) => void\n}\n\nexport const defaultResponse: Omit<MockedResponse, 'headers'> = {\n  status: 200,\n  statusText: 'OK',\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false,\n}\n\nexport type ResponseCompositionOptions<BodyType> = {\n  defaultTransformers?: ResponseTransformer<BodyType>[]\n  mockedResponseOverrides?: Partial<MockedResponse>\n}\n\nexport const defaultResponseTransformers: ResponseTransformer<any>[] = []\n\nexport function createResponseComposition<BodyType>(\n  responseOverrides?: Partial<MockedResponse<BodyType>>,\n  defaultTransformers: ResponseTransformer<BodyType>[] = defaultResponseTransformers,\n): ResponseFunction {\n  return async (...transformers) => {\n    const initialResponse: MockedResponse = Object.assign(\n      {},\n      defaultResponse,\n      {\n        headers: new Headers({\n          'x-powered-by': 'msw',\n        }),\n      },\n      responseOverrides,\n    )\n\n    const resolvedTransformers = [\n      ...defaultTransformers,\n      ...transformers,\n    ].filter(Boolean)\n\n    const resolvedResponse =\n      resolvedTransformers.length > 0\n        ? compose(...resolvedTransformers)(initialResponse)\n        : initialResponse\n\n    return resolvedResponse\n  }\n}\n\nexport const response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({ once: true }),\n  networkError(message: string) {\n    throw new NetworkError(message)\n  },\n})\n","type ArityOneFunction = (arg: any) => any\n\ntype LengthOfTuple<Tuple extends any[]> = Tuple extends { length: infer L }\n  ? L\n  : never\n\ntype DropFirstInTuple<Tuple extends any[]> = ((...args: Tuple) => any) extends (\n  arg: any,\n  ...rest: infer LastArg\n) => any\n  ? LastArg\n  : Tuple\n\ntype LastInTuple<Tuple extends any[]> = Tuple[LengthOfTuple<\n  DropFirstInTuple<Tuple>\n>]\n\ntype FirstFnParameterType<Functions extends ArityOneFunction[]> = Parameters<\n  LastInTuple<Functions>\n>[any]\n\ntype LastFnParameterType<Functions extends ArityOneFunction[]> = ReturnType<\n  Functions[0]\n>\n\n/**\n * Composes a given list of functions into a new function that\n * executes from right to left.\n */\nexport function compose<\n  Functions extends ArityOneFunction[],\n  LeftReturnType extends FirstFnParameterType<Functions>,\n  RightReturnType extends LastFnParameterType<Functions>,\n>(\n  ...fns: Functions\n): (\n  ...args: [LeftReturnType] extends [never] ? never[] : [LeftReturnType]\n) => RightReturnType {\n  return (...args) => {\n    return fns.reduceRight((leftFn: any, rightFn) => {\n      return leftFn instanceof Promise\n        ? Promise.resolve(leftFn).then(rightFn)\n        : rightFn(leftFn)\n    }, args[0])\n  }\n}\n","// Ignore the source files traces for local testing.\nconst SOURCE_FRAME = /\\/msw\\/src\\/(.+)/\n\nconst BUILD_FRAME =\n  /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/\n\n/**\n * Return the stack trace frame of a function's invocation.\n */\nexport function getCallFrame(error: Error) {\n  // In <IE11, new Error may return an undefined stack\n  const stack = error.stack\n\n  if (!stack) {\n    return\n  }\n\n  const frames: string[] = stack.split('\\n').slice(1)\n\n  // Get the first frame that doesn't reference the library's internal trace.\n  // Assume that frame is the invocation frame.\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame))\n  })\n\n  if (!declarationFrame) {\n    return\n  }\n\n  // Extract file reference from the stack frame.\n  const declarationPath = declarationFrame\n    .replace(/\\s*at [^()]*\\(([^)]+)\\)/, '$1')\n    .replace(/^@/, '')\n  return declarationPath\n}\n","/**\n * Determines if the given function is an iterator.\n */\nexport function isIterable<IteratorType>(\n  fn: any,\n): fn is Generator<IteratorType, IteratorType, IteratorType> {\n  if (!fn) {\n    return false\n  }\n\n  return typeof (fn as Generator<unknown>)[Symbol.iterator] == 'function'\n}\n","import * as cookieUtils from 'cookie'\nimport { store } from '@mswjs/cookies'\nimport { MockedRequest } from '../../handlers/RequestHandler'\nimport { getRequestCookies } from './getRequestCookies'\n\n/**\n * Sets relevant cookies on the request.\n * Request cookies are taken from the following sources:\n * - Immediate (own) request cookies (those in the \"Cookie\" request header);\n * - From the `document.cookie` based on the request's `credentials` value;\n * - From the internal cookie store that persists/hydrates cookies in Node.js\n */\nexport function setRequestCookies(request: MockedRequest): void {\n  // Set mocked request cookies from the `cookie` header of the original request.\n  // No need to take `credentials` into account, because in Node.js requests are intercepted\n  // _after_ they happen. Request issuer should have already taken care of sending relevant cookies.\n  // Unlike browser, where interception is on the worker level, _before_ the request happens.\n  const requestCookiesString = request.headers.get('cookie')\n\n  store.hydrate()\n\n  const cookiesFromStore = Array.from(\n    store.get({ ...request, url: request.url.toString() })?.entries(),\n  ).reduce((cookies, [name, { value }]) => {\n    return Object.assign(cookies, { [name.trim()]: value })\n  }, {})\n\n  const cookiesFromDocument = getRequestCookies(request)\n\n  const forwardedCookies = {\n    ...cookiesFromDocument,\n    ...cookiesFromStore,\n  }\n\n  // Ensure the persisted (document) cookies are propagated to the request.\n  // Propagated the cookies persisted in the Cookuie Store to the request headers.\n  // This forwards relevant request cookies based on the request's credentials.\n  for (const [name, value] of Object.entries(forwardedCookies)) {\n    request.headers.append('cookie', `${name}=${value}`)\n  }\n\n  const ownCookies = requestCookiesString\n    ? cookieUtils.parse(requestCookiesString)\n    : {}\n\n  request.cookies = {\n    ...request.cookies,\n    ...forwardedCookies,\n    ...ownCookies,\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { MockedRequest } from '../../handlers/RequestHandler'\n\nfunction getAllCookies() {\n  return cookieUtils.parse(document.cookie)\n}\n\n/**\n * Returns relevant document cookies based on the request `credentials` option.\n */\nexport function getRequestCookies(request: MockedRequest) {\n  /**\n   * @note No cookies persist on the document in Node.js: no document.\n   */\n  if (typeof document === 'undefined' || typeof location === 'undefined') {\n    return {}\n  }\n\n  switch (request.credentials) {\n    case 'same-origin': {\n      // Return document cookies only when requested a resource\n      // from the same origin as the current document.\n      return location.origin === request.url.origin ? getAllCookies() : {}\n    }\n\n    case 'include': {\n      // Return all document cookies.\n      return getAllCookies()\n    }\n\n    default: {\n      return {}\n    }\n  }\n}\n","import { stringToHeaders } from 'headers-polyfill'\nimport { DefaultRequestMultipartBody } from '../../handlers/RequestHandler'\n\ninterface ParsedContentHeaders {\n  name: string\n  filename?: string\n  contentType: string\n}\n\ninterface ContentDispositionDirective {\n  [key: string]: string | undefined\n  name: string\n  filename?: string\n  'form-data': string\n}\n\nfunction parseContentHeaders(headersString: string): ParsedContentHeaders {\n  const headers = stringToHeaders(headersString)\n  const contentType = headers.get('content-type') || 'text/plain'\n  const disposition = headers.get('content-disposition')\n\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.')\n  }\n\n  const directives = disposition.split(';').reduce((acc, chunk) => {\n    const [name, ...rest] = chunk.trim().split('=')\n    acc[name] = rest.join('=')\n    return acc\n  }, {} as ContentDispositionDirective)\n\n  const name = directives.name?.slice(1, -1)\n  const filename = directives.filename?.slice(1, -1)\n\n  return {\n    name,\n    filename,\n    contentType,\n  }\n}\n\n/**\n * Parses a given string as a multipart/form-data.\n * Does not throw an exception on an invalid multipart string.\n */\nexport function parseMultipartData<T extends DefaultRequestMultipartBody>(\n  data: string,\n  headers?: Headers,\n): T | undefined {\n  const contentType = headers?.get('content-type')\n\n  if (!contentType) {\n    return undefined\n  }\n\n  const [, ...directives] = contentType.split(/; */)\n  const boundary = directives\n    .filter((d) => d.startsWith('boundary='))\n    .map((s) => s.replace(/^boundary=/, ''))[0]\n\n  if (!boundary) {\n    return undefined\n  }\n\n  const boundaryRegExp = new RegExp(`--+${boundary}`)\n  const fields = data\n    .split(boundaryRegExp)\n    .filter((chunk) => chunk.startsWith('\\r\\n') && chunk.endsWith('\\r\\n'))\n    .map((chunk) => chunk.trimStart().replace(/\\r\\n$/, ''))\n\n  if (!fields.length) {\n    return undefined\n  }\n\n  const parsedBody: DefaultRequestMultipartBody = {}\n\n  try {\n    for (const field of fields) {\n      const [contentHeaders, ...rest] = field.split('\\r\\n\\r\\n')\n      const contentBody = rest.join('\\r\\n\\r\\n')\n      const { contentType, filename, name } =\n        parseContentHeaders(contentHeaders)\n\n      const value =\n        filename === undefined\n          ? contentBody\n          : new File([contentBody], filename, { type: contentType })\n\n      const parsedValue = parsedBody[name]\n\n      if (parsedValue === undefined) {\n        parsedBody[name] = value\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value]\n      } else {\n        parsedBody[name] = [parsedValue, value]\n      }\n    }\n\n    return parsedBody as T\n  } catch (error) {\n    return undefined\n  }\n}\n","import { MockedRequest } from '../../handlers/RequestHandler'\nimport { jsonParse } from '../internal/jsonParse'\nimport { parseMultipartData } from '../internal/parseMultipartData'\n\n/**\n * Parses a given request/response body based on the \"Content-Type\" header.\n */\nexport function parseBody(body?: MockedRequest['body'], headers?: Headers) {\n  // Return whatever falsey body value is given.\n  if (!body) {\n    return body\n  }\n\n  const contentType = headers?.get('content-type')?.toLowerCase() || ''\n\n  // If the body has a Multipart Content-Type\n  // parse it into an object.\n  const hasMultipartContent = contentType.startsWith('multipart/form-data')\n  if (hasMultipartContent && typeof body !== 'object') {\n    return parseMultipartData(body.toString(), headers) || body\n  }\n\n  // If the intercepted request's body has a JSON Content-Type\n  // parse it into an object.\n  const hasJsonContent = contentType.includes('json')\n\n  if (hasJsonContent && typeof body !== 'object') {\n    return jsonParse(body.toString()) || body\n  }\n\n  // Otherwise leave as-is.\n  return body\n}\n","/**\n * Performs a case-insensitive comparison of two given strings.\n */\nexport function isStringEqual(actual: string, expected: string): boolean {\n  return actual.toLowerCase() === expected.toLowerCase()\n}\n","import { ServiceWorkerIncomingRequest } from '../../setupWorker/glossary'\nimport { isStringEqual } from '../internal/isStringEqual'\n\ntype Input = Pick<ServiceWorkerIncomingRequest, 'method' | 'body'>\n\n/**\n * Ensures that an empty GET request body is always represented as `undefined`.\n */\nexport function pruneGetRequestBody(\n  request: Input,\n): ServiceWorkerIncomingRequest['body'] {\n  if (\n    request.method &&\n    isStringEqual(request.method, 'GET') &&\n    request.body === ''\n  ) {\n    return undefined\n  }\n\n  return request.body\n}\n","import { until } from '@open-draft/until'\nimport { StrictEventEmitter } from 'strict-event-emitter'\nimport { MockedRequest, RequestHandler } from '../handlers/RequestHandler'\nimport { ServerLifecycleEventsMap } from '../node/glossary'\nimport { MockedResponse } from '../response'\nimport { SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { ResponseLookupResult, getResponse } from './getResponse'\nimport { devUtils } from './internal/devUtils'\nimport { onUnhandledRequest } from './request/onUnhandledRequest'\nimport { readResponseCookies } from './request/readResponseCookies'\n\nexport interface HandleRequestOptions<ResponseType> {\n  /**\n   * Options for the response resolution process.\n   */\n  resolutionContext?: {\n    baseUrl?: string\n  }\n\n  /**\n   * Transforms a `MockedResponse` instance returned from a handler\n   * to a response instance supported by the lower tooling (i.e. interceptors).\n   */\n  transformResponse?(response: MockedResponse<string>): ResponseType\n\n  /**\n   * Invoked whenever a request is performed as-is.\n   */\n  onPassthroughResponse?(request: MockedRequest): void\n\n  /**\n   * Invoked when the mocked response is ready to be sent.\n   */\n  onMockedResponse?(\n    response: ResponseType,\n    handler: RequiredDeep<ResponseLookupResult>,\n  ): void\n\n  /**\n   * Invoked when the mocked response is sent.\n   * Respects the response delay duration.\n   */\n  onMockedResponseSent?(\n    response: ResponseType,\n    handler: RequiredDeep<ResponseLookupResult>,\n  ): void\n}\n\nexport async function handleRequest<\n  ResponseType extends Record<string, any> = MockedResponse<string>,\n>(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  options: RequiredDeep<SharedOptions>,\n  emitter: StrictEventEmitter<ServerLifecycleEventsMap>,\n  handleRequestOptions?: HandleRequestOptions<ResponseType>,\n): Promise<ResponseType | undefined> {\n  emitter.emit('request:start', request)\n\n  // Perform bypassed requests (i.e. issued via \"ctx.fetch\") as-is.\n  if (request.headers.get('x-msw-bypass') === 'true') {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Resolve a mocked response from the list of request handlers.\n  const [lookupError, lookupResult] = await until(() => {\n    return getResponse(\n      request,\n      handlers,\n      handleRequestOptions?.resolutionContext,\n    )\n  })\n\n  if (lookupError) {\n    // Allow developers to react to unhandled exceptions in request handlers.\n    emitter.emit('unhandledException', lookupError, request)\n    throw lookupError\n  }\n\n  const { handler, response } = lookupResult\n\n  // When there's no handler for the request, consider it unhandled.\n  // Allow the developer to react to such cases.\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest)\n    emitter.emit('request:unhandled', request)\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the handled request returned no mocked response, warn the developer,\n  // as it may be an oversight on their part. Perform the request as-is.\n  if (!response) {\n    devUtils.warn(\n      `\\\nExpected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\\\n\\n\n  \\u2022 %s\n    %s\\\n`,\n      response,\n      handler.info.header,\n      handler.info.callFrame,\n    )\n\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the developer explicitly returned \"req.passthrough()\" do not warn them.\n  // Perform the request as-is.\n  if (response.passthrough) {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Store all the received response cookies in the virtual cookie store.\n  readResponseCookies(request, response)\n\n  emitter.emit('request:match', request)\n\n  return new Promise((resolve) => {\n    const requiredLookupResult =\n      lookupResult as RequiredDeep<ResponseLookupResult>\n\n    const transformedResponse =\n      handleRequestOptions?.transformResponse?.(response) ||\n      (response as any as ResponseType)\n\n    handleRequestOptions?.onMockedResponse?.(\n      transformedResponse,\n      requiredLookupResult,\n    )\n\n    setTimeout(() => {\n      handleRequestOptions?.onMockedResponseSent?.(\n        transformedResponse,\n        requiredLookupResult,\n      )\n      emitter.emit('request:end', request)\n\n      resolve(transformedResponse as ResponseType)\n    }, response.delay ?? 0)\n  })\n}\n","import { MockedResponse } from '../response'\nimport {\n  MockedRequest,\n  RequestHandler,\n  RequestHandlerExecutionResult,\n} from '../handlers/RequestHandler'\n\nexport interface ResponseLookupResult {\n  handler?: RequestHandler\n  publicRequest?: any\n  parsedRequest?: any\n  response?: MockedResponse\n}\n\nexport interface ResponseResolutionContext {\n  baseUrl?: string\n}\n\n/**\n * Returns a mocked response for a given request using following request handlers.\n */\nexport const getResponse = async <\n  Request extends MockedRequest,\n  Handler extends RequestHandler[],\n>(\n  request: Request,\n  handlers: Handler,\n  resolutionContext?: ResponseResolutionContext,\n): Promise<ResponseLookupResult> => {\n  const relevantHandlers = handlers.filter((handler) => {\n    return handler.test(request, resolutionContext)\n  })\n\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  const result = await relevantHandlers.reduce<\n    Promise<RequestHandlerExecutionResult<any> | null>\n  >(async (executionResult, handler) => {\n    const previousResults = await executionResult\n\n    if (!!previousResults?.response) {\n      return executionResult\n    }\n\n    const result = await handler.run(request, resolutionContext)\n\n    if (result === null || result.handler.shouldSkip) {\n      return null\n    }\n\n    if (!result.response) {\n      return {\n        request: result.request,\n        handler: result.handler,\n        response: undefined,\n        parsedResult: result.parsedResult,\n      }\n    }\n\n    if (result.response.once) {\n      handler.markAsSkipped(true)\n    }\n\n    return result\n  }, Promise.resolve(null))\n\n  // Although reducing a list of relevant request handlers, it's possible\n  // that in the end there will be no handler associted with the request\n  // (i.e. if relevant handlers are fall-through).\n  if (!result) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response,\n  }\n}\n","import getStringMatchScore from 'js-levenshtein'\nimport {\n  ParsedGraphQLQuery,\n  parseGraphQLRequest,\n} from '../internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from './getPublicUrlFromRequest'\nimport { isStringEqual } from '../internal/isStringEqual'\nimport { RestHandler } from '../../handlers/RestHandler'\nimport { GraphQLHandler } from '../../handlers/GraphQLHandler'\nimport { MockedRequest, RequestHandler } from '../../handlers/RequestHandler'\nimport { tryCatch } from '../internal/tryCatch'\nimport { devUtils } from '../internal/devUtils'\n\nconst MAX_MATCH_SCORE = 3\nconst MAX_SUGGESTION_COUNT = 4\nconst TYPE_MATCH_DELTA = 0.5\n\nexport interface UnhandledRequestPrint {\n  warning(): void\n  error(): void\n}\n\nexport type UnhandledRequestCallback = (\n  request: MockedRequest,\n  print: UnhandledRequestPrint,\n) => void\n\nexport type UnhandledRequestStrategy =\n  | 'bypass'\n  | 'warn'\n  | 'error'\n  | UnhandledRequestCallback\n\ninterface RequestHandlerGroups {\n  rest: RestHandler[]\n  graphql: GraphQLHandler[]\n}\n\nfunction groupHandlersByType(handlers: RequestHandler[]): RequestHandlerGroups {\n  return handlers.reduce<RequestHandlerGroups>(\n    (groups, handler) => {\n      if (handler instanceof RestHandler) {\n        groups.rest.push(handler)\n      }\n\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler)\n      }\n\n      return groups\n    },\n    {\n      rest: [],\n      graphql: [],\n    },\n  )\n}\n\ntype RequestHandlerSuggestion = [number, RequestHandler]\n\ntype ScoreGetterFn<RequestHandlerType extends RequestHandler> = (\n  request: MockedRequest,\n  handler: RequestHandlerType,\n) => number\n\nfunction getRestHandlerScore(): ScoreGetterFn<RestHandler> {\n  return (request, handler) => {\n    const { path, method } = handler.info\n\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity\n    }\n\n    const hasSameMethod = isStringEqual(request.method, method)\n\n    // Always treat a handler with the same method as a more similar one.\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n    const score = getStringMatchScore(requestPublicUrl, path)\n\n    return score - methodScoreDelta\n  }\n}\n\nfunction getGraphQLHandlerScore(\n  parsedQuery: ParsedGraphQLQuery,\n): ScoreGetterFn<GraphQLHandler> {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === 'undefined') {\n      return Infinity\n    }\n\n    const { operationType, operationName } = handler.info\n\n    if (typeof operationName !== 'string') {\n      return Infinity\n    }\n\n    const hasSameOperationType = parsedQuery.operationType === operationType\n    // Always treat a handler with the same operation type as a more similar one.\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0\n    const score = getStringMatchScore(parsedQuery.operationName, operationName)\n\n    return score - operationTypeScoreDelta\n  }\n}\n\nfunction getSuggestedHandler(\n  request: MockedRequest,\n  handlers: RestHandler[] | GraphQLHandler[],\n  getScore: ScoreGetterFn<RestHandler> | ScoreGetterFn<GraphQLHandler>,\n): RequestHandler[] {\n  const suggestedHandlers = (handlers as RequestHandler[])\n    .reduce<RequestHandlerSuggestion[]>((suggestions, handler) => {\n      const score = getScore(request, handler as any)\n      return suggestions.concat([[score, handler]])\n    }, [])\n    .sort(([leftScore], [rightScore]) => leftScore - rightScore)\n    .filter(([score]) => score <= MAX_MATCH_SCORE)\n    .slice(0, MAX_SUGGESTION_COUNT)\n    .map(([, handler]) => handler)\n\n  return suggestedHandlers\n}\n\nfunction getSuggestedHandlersMessage(handlers: RequestHandler[]) {\n  if (handlers.length > 1) {\n    return `\\\nDid you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `   ${handler.info.header}`).join('\\n')}`\n  }\n\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`\n}\n\nexport function onUnhandledRequest(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  strategy: UnhandledRequestStrategy = 'warn',\n): void {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request))\n\n  function generateHandlerSuggestion(): string {\n    /**\n     * @note Ignore exceptions during GraphQL request parsing because at this point\n     * we cannot assume the unhandled request is a valid GraphQL request.\n     * If the GraphQL parsing fails, just don't treat it as a GraphQL request.\n     */\n    const handlerGroups = groupHandlersByType(handlers)\n    const relevantHandlers = parsedGraphQLQuery\n      ? handlerGroups.graphql\n      : handlerGroups.rest\n\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery\n        ? getGraphQLHandlerScore(parsedGraphQLQuery)\n        : getRestHandlerScore(),\n    )\n\n    return suggestedHandlers.length > 0\n      ? getSuggestedHandlersMessage(suggestedHandlers)\n      : ''\n  }\n\n  function generateUnhandledRequestMessage(): string {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const requestHeader = parsedGraphQLQuery\n      ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})`\n      : `${request.method} ${publicUrl}`\n    const handlerSuggestion = generateHandlerSuggestion()\n\n    const messageTemplate = [\n      `captured a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `\\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks\\\n`,\n    ].filter(Boolean)\n    return messageTemplate.join('\\n\\n')\n  }\n\n  function applyStrategy(strategy: UnhandledRequestStrategy) {\n    // Generate handler suggestions only when applying the strategy.\n    // This saves bandwidth for scenarios when developers opt-out\n    // from the default unhandled request handling strategy.\n    const message = generateUnhandledRequestMessage()\n\n    switch (strategy) {\n      case 'error': {\n        // Print a developer-friendly error.\n        devUtils.error('Error: %s', message)\n\n        // Throw an exception to halt request processing and not perform the original request.\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.',\n          ),\n        )\n      }\n\n      case 'warn': {\n        devUtils.warn('Warning: %s', message)\n        break\n      }\n\n      case 'bypass':\n        break\n\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy,\n          ),\n        )\n    }\n  }\n\n  if (typeof strategy === 'function') {\n    strategy(request, {\n      warning: applyStrategy.bind(null, 'warn'),\n      error: applyStrategy.bind(null, 'error'),\n    })\n    return\n  }\n\n  applyStrategy(strategy)\n}\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  OperationTypeNode,\n  parse,\n} from 'graphql'\nimport { GraphQLVariables } from '../../handlers/GraphQLHandler'\nimport { MockedRequest } from '../../handlers/RequestHandler'\nimport { getPublicUrlFromRequest } from '../request/getPublicUrlFromRequest'\nimport { devUtils } from './devUtils'\nimport { jsonParse } from './jsonParse'\n\ninterface GraphQLInput {\n  query: string | null\n  variables?: GraphQLVariables\n}\n\nexport interface ParsedGraphQLQuery {\n  operationType: OperationTypeNode\n  operationName?: string\n}\n\nexport type ParsedGraphQLRequest<\n  VariablesType extends GraphQLVariables = GraphQLVariables,\n> =\n  | (ParsedGraphQLQuery & {\n      variables?: VariablesType\n    })\n  | undefined\n\nexport function parseDocumentNode(node: DocumentNode): ParsedGraphQLQuery {\n  const operationDef = node.definitions.find((def) => {\n    return def.kind === 'OperationDefinition'\n  }) as OperationDefinitionNode\n\n  return {\n    operationType: operationDef?.operation,\n    operationName: operationDef?.name?.value,\n  }\n}\n\nfunction parseQuery(query: string): ParsedGraphQLQuery | Error {\n  try {\n    const ast = parse(query)\n    return parseDocumentNode(ast)\n  } catch (error) {\n    return error as Error\n  }\n}\n\nexport type GraphQLParsedOperationsMap = Record<string, string[]>\nexport type GraphQLMultipartRequestBody = {\n  operations: string\n  map?: string\n} & {\n  [fileName: string]: File\n}\n\nfunction extractMultipartVariables<VariablesType extends GraphQLVariables>(\n  variables: VariablesType,\n  map: GraphQLParsedOperationsMap,\n  files: Record<string, File>,\n) {\n  const operations = { variables }\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`)\n    }\n\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split('.').reverse()\n      const paths = reversedPaths.reverse()\n      let target: Record<string, any> = operations\n\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`)\n        }\n\n        target = target[path]\n      }\n\n      target[lastPath] = files[key]\n    }\n  }\n  return operations.variables\n}\n\nfunction getGraphQLInput(request: MockedRequest<any>): GraphQLInput | null {\n  switch (request.method) {\n    case 'GET': {\n      const query = request.url.searchParams.get('query')\n      const variables = request.url.searchParams.get('variables') || ''\n\n      return {\n        query,\n        variables: jsonParse(variables),\n      }\n    }\n\n    case 'POST': {\n      if (request.body?.query) {\n        const { query, variables } = request.body\n\n        return {\n          query,\n          variables,\n        }\n      }\n\n      // Handle multipart body operations.\n      if (request.body?.operations) {\n        const { operations, map, ...files } =\n          request.body as GraphQLMultipartRequestBody\n        const parsedOperations =\n          jsonParse<{ query?: string; variables?: GraphQLVariables }>(\n            operations,\n          ) || {}\n\n        if (!parsedOperations.query) {\n          return null\n        }\n\n        const parsedMap = jsonParse<GraphQLParsedOperationsMap>(map || '') || {}\n        const variables = parsedOperations.variables\n          ? extractMultipartVariables(\n              parsedOperations.variables,\n              parsedMap,\n              files,\n            )\n          : {}\n\n        return {\n          query: parsedOperations.query,\n          variables,\n        }\n      }\n    }\n\n    default:\n      return null\n  }\n}\n\n/**\n * Determines if a given request can be considered a GraphQL request.\n * Does not parse the query and does not guarantee its validity.\n */\nexport function parseGraphQLRequest(\n  request: MockedRequest<any>,\n): ParsedGraphQLRequest {\n  const input = getGraphQLInput(request)\n\n  if (!input || !input.query) {\n    return undefined\n  }\n\n  const { query, variables } = input\n  const parsedResult = parseQuery(query)\n\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message,\n      ),\n    )\n  }\n\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables,\n  }\n}\n","import { MockedRequest } from '../../handlers/RequestHandler'\n\n/**\n * Returns a relative URL if the given request URL is relative to the current origin.\n * Otherwise returns an absolute URL.\n */\nexport const getPublicUrlFromRequest = (request: MockedRequest) => {\n  return request.referrer.startsWith(request.url.origin)\n    ? request.url.pathname\n    : new URL(\n        request.url.pathname,\n        `${request.url.protocol}//${request.url.host}`,\n      ).href\n}\n","export enum StatusCodeColor {\n  Success = '#69AB32',\n  Warning = '#F0BB4B',\n  Danger = '#E95F5D',\n}\n\n/**\n * Returns a HEX color for a given response status code number.\n */\nexport function getStatusCodeColor(status: number): StatusCodeColor {\n  if (status < 300) {\n    return StatusCodeColor.Success\n  }\n\n  if (status < 400) {\n    return StatusCodeColor.Warning\n  }\n\n  return StatusCodeColor.Danger\n}\n","/**\n * Returns a timestamp string in a \"HH:MM:SS\" format.\n */\nexport function getTimestamp(): string {\n  const now = new Date()\n\n  return [now.getHours(), now.getMinutes(), now.getSeconds()]\n    .map(String)\n    .map((chunk) => chunk.slice(0, 2))\n    .map((chunk) => chunk.padStart(2, '0'))\n    .join(':')\n}\n","import { MockedRequest } from '../../handlers/RequestHandler'\n\n/**\n * Formats a mocked request for introspection in browser's console.\n */\nexport function prepareRequest(request: MockedRequest) {\n  return {\n    ...request,\n    headers: request.headers.all(),\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { SerializedResponse } from '../../setupWorker/glossary'\nimport { parseBody } from '../request/parseBody'\n\n/**\n * Formats a mocked response for introspection in the browser's console.\n */\nexport function prepareResponse(res: SerializedResponse<any>) {\n  const responseHeaders = objectToHeaders(res.headers)\n\n  return {\n    ...res,\n    // Parse a response JSON body for preview in the logs\n    body: parseBody(res.body, responseHeaders),\n  }\n}\n","import { match } from 'path-to-regexp'\nimport { getCleanUrl } from '@mswjs/interceptors/lib/utils/getCleanUrl'\nimport { normalizePath } from './normalizePath'\n\nexport type Path = string | RegExp\nexport type PathParams<KeyType extends keyof any = string> = {\n  [ParamName in KeyType]: string | ReadonlyArray<string>\n}\n\nexport interface Match {\n  matches: boolean\n  params?: PathParams\n}\n\n/**\n * Coerce a path supported by MSW into a path\n * supported by \"path-to-regexp\".\n */\nexport function coercePath(path: string): string {\n  return (\n    path\n      /**\n       * Replace wildcards (\"*\") with unnamed capturing groups\n       * because \"path-to-regexp\" doesn't support wildcards.\n       * Ignore path parameter' modifiers (i.e. \":name*\").\n       */\n      .replace(\n        /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n        (_, parameterName: string | undefined, wildcard: string) => {\n          const expression = '(.*)'\n\n          if (!parameterName) {\n            return expression\n          }\n\n          return parameterName.startsWith(':')\n            ? `${parameterName}${wildcard}`\n            : `${parameterName}${expression}`\n        },\n      )\n      /**\n       * Escape the port so that \"path-to-regexp\" can match\n       * absolute URLs including port numbers.\n       */\n      .replace(/([^\\/])(:)(?=\\d+)/, '$1\\\\$2')\n      /**\n       * Escape the protocol so that \"path-to-regexp\" could match\n       * absolute URL.\n       * @see https://github.com/pillarjs/path-to-regexp/issues/259\n       */\n      .replace(/^([^\\/]+)(:)(?=\\/\\/)/, '$1\\\\$2')\n  )\n}\n\n/**\n * Returns the result of matching given request URL against a mask.\n */\nexport function matchRequestUrl(url: URL, path: Path, baseUrl?: string): Match {\n  const normalizedPath = normalizePath(path, baseUrl)\n  const cleanPath =\n    typeof normalizedPath === 'string'\n      ? coercePath(normalizedPath)\n      : normalizedPath\n\n  const cleanUrl = getCleanUrl(url)\n  const result = match(cleanPath, { decode: decodeURIComponent })(cleanUrl)\n  const params = (result && (result.params as PathParams)) || {}\n\n  return {\n    matches: result !== false,\n    params,\n  }\n}\n","const REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g\n\nexport function getSearchParams(path: string) {\n  return new URL(`/${path}`, 'http://localhost').searchParams\n}\n\n/**\n * Removes query parameters and hashes from a given URL string.\n */\nexport function cleanUrl(path: string): string {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, '')\n}\n","/**\n * Determines if the given URL string is an absolute URL.\n */\nexport function isAbsoluteUrl(url: string): boolean {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url)\n}\n","import { isAbsoluteUrl } from './isAbsoluteUrl'\n\n/**\n * Returns an absolute URL based on the given path.\n */\nexport function getAbsoluteUrl(path: string, baseUrl?: string): string {\n  // already absolute URL\n  if (isAbsoluteUrl(path)) {\n    return path\n  }\n\n  // Ignore path with pattern start with *\n  if (path.startsWith('*')) {\n    return path\n  }\n\n  // Resolve a relative request URL against a given custom \"baseUrl\"\n  // or the document baseURI (in the case of browser/browser-like environments).\n  const origin =\n    baseUrl || (typeof document !== 'undefined' && document.baseURI)\n\n  return origin\n    ? // Encode and decode the path to preserve escaped characters.\n      decodeURI(new URL(encodeURI(path), origin).href)\n    : path\n}\n","import type { Path } from './matchRequestUrl'\nimport { cleanUrl } from '../url/cleanUrl'\nimport { getAbsoluteUrl } from '../url/getAbsoluteUrl'\n\n/**\n * Normalizes a given request handler path:\n * - Preserves RegExp.\n * - Removes query parameters and hashes.\n * - Rebases relative URLs against the \"baseUrl\" or the current location.\n * - Preserves relative URLs in Node.js, unless specified otherwise.\n */\nexport function normalizePath(path: Path, baseUrl?: string): Path {\n  // RegExp paths do not need normalization.\n  if (path instanceof RegExp) {\n    return path\n  }\n\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl)\n\n  return cleanUrl(maybeAbsoluteUrl)\n}\n","import { body, cookie, json, text, xml } from '../context'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { isStringEqual } from '../utils/internal/isStringEqual'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport {\n  Match,\n  matchRequestUrl,\n  Path,\n  PathParams,\n} from '../utils/matching/matchRequestUrl'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { cleanUrl, getSearchParams } from '../utils/url/cleanUrl'\nimport {\n  DefaultBodyType,\n  defaultContext,\n  DefaultContext,\n  MockedRequest,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\n\ntype RestHandlerMethod = string | RegExp\n\nexport interface RestHandlerInfo extends RequestHandlerDefaultInfo {\n  method: RestHandlerMethod\n  path: Path\n}\n\nexport enum RESTMethods {\n  HEAD = 'HEAD',\n  GET = 'GET',\n  POST = 'POST',\n  PUT = 'PUT',\n  PATCH = 'PATCH',\n  OPTIONS = 'OPTIONS',\n  DELETE = 'DELETE',\n}\n\n// Declaring a context interface infers\n// JSDoc description of the referenced utils.\nexport type RestContext = DefaultContext & {\n  cookie: typeof cookie\n  text: typeof text\n  body: typeof body\n  json: typeof json\n  xml: typeof xml\n}\n\nexport const restContext: RestContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml,\n}\n\nexport type RequestQuery = {\n  [queryName: string]: string\n}\n\nexport interface RestRequest<\n  BodyType extends DefaultBodyType = DefaultBodyType,\n  ParamsType extends PathParams = PathParams,\n> extends MockedRequest<BodyType> {\n  params: ParamsType\n}\n\nexport type ParsedRestRequest = Match\n\n/**\n * Request handler for REST API requests.\n * Provides request matching based on method and URL.\n */\nexport class RestHandler<\n  RequestType extends MockedRequest<DefaultBodyType> = MockedRequest<DefaultBodyType>,\n> extends RequestHandler<\n  RestHandlerInfo,\n  RequestType,\n  ParsedRestRequest,\n  RestRequest<\n    RequestType extends MockedRequest<infer RequestBodyType>\n      ? RequestBodyType\n      : any,\n    PathParams\n  >\n> {\n  constructor(\n    method: RestHandlerMethod,\n    path: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method,\n      },\n      ctx: restContext,\n      resolver,\n    })\n\n    this.checkRedundantQueryParameters()\n  }\n\n  private checkRedundantQueryParameters() {\n    const { method, path } = this.info\n\n    if (path instanceof RegExp) {\n      return\n    }\n\n    const url = cleanUrl(path)\n\n    // Bypass request handler URLs that have no redundant characters.\n    if (url === path) {\n      return\n    }\n\n    const searchParams = getSearchParams(path)\n    const queryParams: string[] = []\n\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName)\n    })\n\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`,\n    )\n  }\n\n  parse(request: RequestType, resolutionContext?: ResponseResolutionContext) {\n    return matchRequestUrl(\n      request.url,\n      this.info.path,\n      resolutionContext?.baseUrl,\n    )\n  }\n\n  protected getPublicRequest(\n    request: RequestType,\n    parsedResult: ParsedRestRequest,\n  ): RestRequest<any, PathParams> {\n    return {\n      ...request,\n      params: parsedResult.params || {},\n    }\n  }\n\n  predicate(request: RequestType, parsedResult: ParsedRestRequest) {\n    const matchesMethod =\n      this.info.method instanceof RegExp\n        ? this.info.method.test(request.method)\n        : isStringEqual(this.info.method, request.method)\n\n    return matchesMethod && parsedResult.matches\n  }\n\n  log(request: RequestType, response: SerializedResponse) {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s %s (%c%s%c)'),\n      getTimestamp(),\n      request.method,\n      publicUrl,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request', loggedRequest)\n    console.log('Handler:', {\n      mask: this.info.path,\n      resolver: this.resolver,\n    })\n    console.log('Response', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { invariant } from 'outvariant'\nimport { ResponseTransformer } from '../response'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\ntype ForbiddenFieldNames = '' | 'data' | 'errors' | 'extensions'\n\n/**\n * Set a custom field on the GraphQL mocked response.\n * @example res(ctx.fields('customField', value))\n * @see {@link https://mswjs.io/docs/api/context/field}\n */\nexport const field = <FieldNameType extends string, FieldValueType>(\n  fieldName: FieldNameType extends ForbiddenFieldNames ? never : FieldNameType,\n  fieldValue: FieldValueType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    validateFieldName(fieldName)\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n\nfunction validateFieldName(fieldName: string) {\n  invariant(\n    fieldName.trim() !== '',\n    devUtils.formatMessage(\n      'Failed to set a custom field on a GraphQL response: field name cannot be empty.',\n    ),\n  )\n\n  invariant(\n    fieldName !== 'data',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'errors',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'extensions',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?',\n      fieldName,\n    ),\n  )\n}\n","export function tryCatch<Fn extends (...args: any[]) => any>(\n  fn: Fn,\n  onException?: (error: Error) => void,\n): ReturnType<Fn> | undefined {\n  try {\n    const result = fn()\n    return result\n  } catch (error) {\n    onException?.(error as Error)\n  }\n}\n","import { DocumentNode, OperationTypeNode } from 'graphql'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { data } from '../context/data'\nimport { extensions } from '../context/extensions'\nimport { errors } from '../context/errors'\nimport { field } from '../context/field'\nimport { GraphQLPayloadContext } from '../typeUtils'\nimport { cookie } from '../context/cookie'\nimport {\n  defaultContext,\n  DefaultContext,\n  MockedRequest,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport { matchRequestUrl, Path } from '../utils/matching/matchRequestUrl'\nimport {\n  ParsedGraphQLRequest,\n  GraphQLMultipartRequestBody,\n  parseGraphQLRequest,\n  parseDocumentNode,\n} from '../utils/internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { tryCatch } from '../utils/internal/tryCatch'\nimport { devUtils } from '../utils/internal/devUtils'\n\nexport type ExpectedOperationTypeNode = OperationTypeNode | 'all'\nexport type GraphQLHandlerNameSelector = DocumentNode | RegExp | string\n\n// GraphQL related context should contain utility functions\n// useful for GraphQL. Functions like `xml()` bear no value\n// in the GraphQL universe.\nexport type GraphQLContext<QueryType extends Record<string, unknown>> =\n  DefaultContext & {\n    data: GraphQLPayloadContext<QueryType>\n    extensions: GraphQLPayloadContext<QueryType>\n    errors: typeof errors\n    cookie: typeof cookie\n    field: typeof field\n  }\n\nexport const graphqlContext: GraphQLContext<any> = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field,\n}\n\nexport type GraphQLVariables = Record<string, any>\n\nexport interface GraphQLHandlerInfo extends RequestHandlerDefaultInfo {\n  operationType: ExpectedOperationTypeNode\n  operationName: GraphQLHandlerNameSelector\n}\n\nexport type GraphQLRequestBody<VariablesType extends GraphQLVariables> =\n  | GraphQLJsonRequestBody<VariablesType>\n  | GraphQLMultipartRequestBody\n  | Record<string, any>\n  | undefined\n\nexport interface GraphQLJsonRequestBody<Variables extends GraphQLVariables> {\n  query: string\n  variables?: Variables\n}\n\nexport interface GraphQLRequest<Variables extends GraphQLVariables>\n  extends MockedRequest<GraphQLRequestBody<Variables>> {\n  variables: Variables\n}\n\nexport function isDocumentNode(\n  value: DocumentNode | any,\n): value is DocumentNode {\n  if (value == null) {\n    return false\n  }\n\n  return typeof value === 'object' && 'kind' in value && 'definitions' in value\n}\n\nexport class GraphQLHandler<\n  Request extends GraphQLRequest<any> = GraphQLRequest<any>,\n> extends RequestHandler<\n  GraphQLHandlerInfo,\n  Request,\n  ParsedGraphQLRequest | null,\n  GraphQLRequest<any>\n> {\n  private endpoint: Path\n\n  constructor(\n    operationType: ExpectedOperationTypeNode,\n    operationName: GraphQLHandlerNameSelector,\n    endpoint: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    let resolvedOperationName = operationName\n\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName)\n\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`,\n        )\n      }\n\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`,\n        )\n      }\n\n      resolvedOperationName = parsedNode.operationName\n    }\n\n    const header =\n      operationType === 'all'\n        ? `${operationType} (origin: ${endpoint.toString()})`\n        : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`\n\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName,\n      },\n      ctx: graphqlContext,\n      resolver,\n    })\n\n    this.endpoint = endpoint\n  }\n\n  parse(request: MockedRequest) {\n    return tryCatch(\n      () => parseGraphQLRequest(request),\n      (error) => console.error(error.message),\n    )\n  }\n\n  protected getPublicRequest(\n    request: Request,\n    parsedResult: ParsedGraphQLRequest,\n  ): GraphQLRequest<any> {\n    return {\n      ...request,\n      variables: parsedResult?.variables || {},\n    }\n  }\n\n  predicate(request: MockedRequest, parsedResult: ParsedGraphQLRequest) {\n    if (!parsedResult) {\n      return false\n    }\n\n    if (!parsedResult.operationName && this.info.operationType !== 'all') {\n      const publicUrl = getPublicUrlFromRequest(request)\n      devUtils.warn(`\\\nFailed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation\\\n      `)\n      return false\n    }\n\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint)\n    const hasMatchingOperationType =\n      this.info.operationType === 'all' ||\n      parsedResult.operationType === this.info.operationType\n\n    const hasMatchingOperationName =\n      this.info.operationName instanceof RegExp\n        ? this.info.operationName.test(parsedResult.operationName || '')\n        : parsedResult.operationName === this.info.operationName\n\n    return (\n      hasMatchingUrl.matches &&\n      hasMatchingOperationType &&\n      hasMatchingOperationName\n    )\n  }\n\n  log(\n    request: Request,\n    response: SerializedResponse,\n    handler: this,\n    parsedRequest: ParsedGraphQLRequest,\n  ) {\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n    const requestInfo = parsedRequest?.operationName\n      ? `${parsedRequest?.operationType} ${parsedRequest?.operationName}`\n      : `anonymous ${parsedRequest?.operationType}`\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s (%c%s%c)'),\n      getTimestamp(),\n      `${requestInfo}`,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request:', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response:', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { store } from '@mswjs/cookies'\nimport { MockedResponse } from '../../response'\nimport { MockedRequest } from '../../handlers/RequestHandler'\n\nexport function readResponseCookies(\n  request: MockedRequest,\n  response: MockedResponse,\n) {\n  store.add({ ...request, url: request.url.toString() }, response)\n  store.persist()\n}\n","import {\n  StartOptions,\n  SerializedResponse,\n  SetupWorkerInternalContext,\n  ServiceWorkerIncomingEventsMap,\n} from '../../setupWorker/glossary'\nimport {\n  ServiceWorkerMessage,\n  createBroadcastChannel,\n} from '../createBroadcastChannel'\nimport { NetworkError } from '../NetworkError'\nimport { parseWorkerRequest } from '../request/parseWorkerRequest'\nimport { handleRequest } from '../handleRequest'\nimport { RequestHandler } from '../../handlers/RequestHandler'\nimport { RequiredDeep } from '../../typeUtils'\nimport { MockedResponse } from '../../response'\n\nexport const createRequestListener = (\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n) => {\n  return async (\n    event: MessageEvent,\n    message: ServiceWorkerMessage<\n      'REQUEST',\n      ServiceWorkerIncomingEventsMap['REQUEST']\n    >,\n  ) => {\n    const channel = createBroadcastChannel(event)\n\n    try {\n      const request = parseWorkerRequest(message.payload)\n      await handleRequest<SerializedResponse>(\n        request,\n        context.requestHandlers,\n        options,\n        context.emitter,\n        {\n          transformResponse,\n          onPassthroughResponse() {\n            return channel.send({\n              type: 'MOCK_NOT_FOUND',\n            })\n          },\n          onMockedResponse(response) {\n            channel.send({\n              type: 'MOCK_SUCCESS',\n              payload: response,\n            })\n          },\n          onMockedResponseSent(\n            response,\n            { handler, publicRequest, parsedRequest },\n          ) {\n            if (options.quiet) {\n              return\n            }\n\n            handler.log(\n              publicRequest,\n              response,\n              handler as RequestHandler,\n              parsedRequest,\n            )\n          },\n        },\n      )\n    } catch (error) {\n      if (error instanceof NetworkError) {\n        // Treat emulated network error differently,\n        // as it is an intended exception in a request handler.\n        return channel.send({\n          type: 'NETWORK_ERROR',\n          payload: {\n            name: error.name,\n            message: error.message,\n          },\n        })\n      }\n\n      if (error instanceof Error) {\n        // Treat all the other exceptions in a request handler\n        // as unintended, alerting that there is a problem needs fixing.\n        channel.send({\n          type: 'INTERNAL_ERROR',\n          payload: {\n            status: 500,\n            body: JSON.stringify({\n              errorType: error.constructor.name,\n              message: error.message,\n              location: error.stack,\n            }),\n          },\n        })\n      }\n    }\n  }\n}\n\nfunction transformResponse(\n  response: MockedResponse<string>,\n): SerializedResponse<string> {\n  return {\n    status: response.status,\n    statusText: response.statusText,\n    headers: response.headers.all(),\n    body: response.body,\n    delay: response.delay,\n  }\n}\n","import { SetupWorkerInternalContext } from '../../setupWorker/glossary'\n\nexport async function requestIntegrityCheck(\n  context: SetupWorkerInternalContext,\n  serviceWorker: ServiceWorker,\n): Promise<ServiceWorker> {\n  // Signal Service Worker to report back its integrity\n  context.workerChannel.send('INTEGRITY_CHECK_REQUEST')\n\n  const { payload: actualChecksum } = await context.events.once(\n    'INTEGRITY_CHECK_RESPONSE',\n  )\n\n  // Compare the response from the Service Worker and the\n  // global variable set during the build.\n  if (actualChecksum !== SERVICE_WORKER_CHECKSUM) {\n    throw new Error(\n      `Currently active Service Worker (${actualChecksum}) is behind the latest published one (${SERVICE_WORKER_CHECKSUM}).`,\n    )\n  }\n\n  return serviceWorker\n}\n","import { until } from '@open-draft/until'\n\n/**\n * Intercepts and defers any requests on the page\n * until the Service Worker instance is ready.\n * Must only be used in a browser.\n */\nexport function deferNetworkRequestsUntil(predicatePromise: Promise<any>) {\n  // Defer any `XMLHttpRequest` requests until the Service Worker is ready.\n  const originalXhrSend = window.XMLHttpRequest.prototype.send\n  window.XMLHttpRequest.prototype.send = function (\n    ...args: Parameters<XMLHttpRequest['send']>\n  ) {\n    // Keep this function synchronous to comply with `XMLHttpRequest.prototype.send`,\n    // because that method is always synchronous.\n    until(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend\n      this.send(...args)\n    })\n  }\n\n  // Defer any `fetch` requests until the Service Worker is ready.\n  const originalFetch = window.fetch\n  window.fetch = async (...args) => {\n    await until(() => predicatePromise)\n    window.fetch = originalFetch\n    return window.fetch(...args)\n  }\n}\n","import {\n  ServiceWorkerIncomingEventsMap,\n  SetupWorkerInternalContext,\n} from '../../setupWorker/glossary'\nimport { ServiceWorkerMessage } from '../createBroadcastChannel'\n\nexport function createResponseListener(context: SetupWorkerInternalContext) {\n  return (\n    _: MessageEvent,\n    message: ServiceWorkerMessage<\n      'RESPONSE',\n      ServiceWorkerIncomingEventsMap['RESPONSE']\n    >,\n  ) => {\n    const { payload: responseJson } = message\n\n    /**\n     * CORS requests with `mode: \"no-cors\"` result in \"opaque\" responses.\n     * That kind of responses cannot be manipulated in JavaScript due\n     * to the security considerations.\n     * @see https://fetch.spec.whatwg.org/#concept-filtered-response-opaque\n     * @see https://github.com/mswjs/msw/issues/529\n     */\n    if (responseJson.type?.includes('opaque')) {\n      return\n    }\n\n    const response = new Response(responseJson.body || null, responseJson)\n    const isMockedResponse = response.headers.get('x-powered-by') === 'msw'\n\n    if (isMockedResponse) {\n      context.emitter.emit('response:mocked', response, responseJson.requestId)\n    } else {\n      context.emitter.emit('response:bypass', response, responseJson.requestId)\n    }\n  }\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\nimport { StartOptions } from '../../glossary'\n\nexport function validateWorkerScope(\n  registration: ServiceWorkerRegistration,\n  options?: StartOptions,\n): void {\n  if (!options?.quiet && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\n      `\\\nCannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.\\\n`,\n    )\n  }\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\n\nexport function printStopMessage(args: { quiet?: boolean } = {}): void {\n  if (args.quiet) {\n    return\n  }\n\n  console.log(\n    `%c${devUtils.formatMessage('Mocking disabled.')}`,\n    'color:orangered;font-weight:bold;',\n  )\n}\n","import { devUtils } from '../../utils/internal/devUtils'\nimport { SetupWorkerInternalContext, StopHandler } from '../glossary'\nimport { printStopMessage } from './utils/printStopMessage'\n\nexport const createStop = (\n  context: SetupWorkerInternalContext,\n): StopHandler => {\n  return function stop() {\n    // Warn developers calling \"worker.stop()\" more times than necessary.\n    // This likely indicates a mistake in their code.\n    if (!context.isMockingEnabled) {\n      devUtils.warn(\n        'Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.',\n      )\n      return\n    }\n\n    /**\n     * Signal the Service Worker to disable mocking for this client.\n     * Use this an an explicit way to stop the mocking, while preserving\n     * the worker-client relation. Does not affect the worker's lifecycle.\n     */\n    context.workerChannel.send('MOCK_DEACTIVATE')\n    context.isMockingEnabled = false\n    window.clearInterval(context.keepAliveInterval)\n\n    printStopMessage({ quiet: context.startOptions?.quiet })\n  }\n}\n","import { RequestHandler } from '../../handlers/RequestHandler'\n\nexport function use(\n  currentHandlers: RequestHandler[],\n  ...handlers: RequestHandler[]\n): void {\n  currentHandlers.unshift(...handlers)\n}\n\nexport function restoreHandlers(handlers: RequestHandler[]): void {\n  handlers.forEach((handler) => {\n    handler.markAsSkipped(false)\n  })\n}\n\nexport function resetHandlers(\n  initialHandlers: RequestHandler[],\n  ...nextHandlers: RequestHandler[]\n) {\n  return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers]\n}\n","import { RequiredDeep } from '../../../typeUtils'\nimport { mergeRight } from '../../../utils/internal/mergeRight'\nimport {\n  SetupWorkerApi,\n  SetupWorkerInternalContext,\n  StartHandler,\n  StartOptions,\n} from '../../glossary'\n\nexport const DEFAULT_START_OPTIONS: RequiredDeep<StartOptions> = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null as any,\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'warn',\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl\n  },\n}\n\n/**\n * Returns resolved worker start options, merging the default options\n * with the given custom options.\n */\nexport function resolveStartOptions(\n  initialOptions?: StartOptions,\n): RequiredDeep<StartOptions> {\n  return mergeRight(\n    DEFAULT_START_OPTIONS,\n    initialOptions || {},\n  ) as RequiredDeep<StartOptions>\n}\n\nexport function prepareStartHandler(\n  handler: StartHandler,\n  context: SetupWorkerInternalContext,\n): SetupWorkerApi['start'] {\n  return (initialOptions) => {\n    context.startOptions = resolveStartOptions(initialOptions)\n    return handler(context.startOptions, initialOptions || {})\n  }\n}\n","import {\n  Interceptor,\n  BatchInterceptor,\n  HttpRequestEventMap,\n} from '@mswjs/interceptors'\nimport { FetchInterceptor } from '@mswjs/interceptors/lib/interceptors/fetch'\nimport { XMLHttpRequestInterceptor } from '@mswjs/interceptors/lib/interceptors/XMLHttpRequest'\nimport type { RequestHandler } from '../../handlers/RequestHandler'\nimport {\n  SerializedResponse,\n  SetupWorkerInternalContext,\n  StartOptions,\n} from '../../setupWorker/glossary'\nimport type { RequiredDeep } from '../../typeUtils'\nimport { handleRequest } from '../handleRequest'\nimport { parseIsomorphicRequest } from '../request/parseIsomorphicRequest'\n\nexport function createFallbackRequestListener(\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n): Interceptor<HttpRequestEventMap> {\n  const interceptor = new BatchInterceptor({\n    name: 'fallback',\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()],\n  })\n\n  interceptor.on('request', async (request) => {\n    const mockedRequest = parseIsomorphicRequest(request)\n\n    const response = await handleRequest<SerializedResponse>(\n      mockedRequest,\n      context.requestHandlers,\n      options,\n      context.emitter,\n      {\n        transformResponse(response) {\n          return {\n            status: response.status,\n            statusText: response.statusText,\n            headers: response.headers.all(),\n            body: response.body,\n            delay: response.delay,\n          }\n        },\n        onMockedResponseSent(\n          response,\n          { handler, publicRequest, parsedRequest },\n        ) {\n          if (!options.quiet) {\n            handler.log(\n              publicRequest,\n              response,\n              handler as RequestHandler,\n              parsedRequest,\n            )\n          }\n        },\n      },\n    )\n\n    if (response) {\n      request.respondWith(response)\n    }\n  })\n\n  interceptor.apply()\n\n  return interceptor\n}\n","import type { IsomorphicRequest } from '@mswjs/interceptors'\nimport { MockedRequest, passthrough } from '../../handlers/RequestHandler'\nimport { parseBody } from './parseBody'\nimport { setRequestCookies } from './setRequestCookies'\n\n/**\n * Converts a given isomorphic request to a `MockedRequest` instance.\n */\nexport function parseIsomorphicRequest(\n  request: IsomorphicRequest,\n): MockedRequest {\n  const mockedRequest: MockedRequest = {\n    id: request.id,\n    url: request.url,\n    method: request.method,\n    body: parseBody(request.body, request.headers),\n    credentials: request.credentials || 'same-origin',\n    headers: request.headers,\n    cookies: {},\n    redirect: 'manual',\n    referrer: '',\n    keepalive: false,\n    cache: 'default',\n    mode: 'cors',\n    referrerPolicy: 'no-referrer',\n    integrity: '',\n    destination: 'document',\n    bodyUsed: false,\n    passthrough,\n  }\n\n  // Attach all the cookies from the virtual cookie store.\n  setRequestCookies(mockedRequest)\n\n  return mockedRequest\n}\n","import { createFallbackRequestListener } from '../../utils/worker/createFallbackRequestListener'\nimport { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { printStartMessage } from './utils/printStartMessage'\n\nexport function createFallbackStart(\n  context: SetupWorkerInternalContext,\n): StartHandler {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(\n      context,\n      options,\n    )\n\n    printStartMessage({\n      message: 'Mocking enabled (fallback mode).',\n      quiet: options.quiet,\n    })\n\n    return undefined\n  }\n}\n","import { SetupWorkerInternalContext, StopHandler } from '../glossary'\nimport { printStopMessage } from './utils/printStopMessage'\n\nexport function createFallbackStop(\n  context: SetupWorkerInternalContext,\n): StopHandler {\n  return function stop() {\n    context.fallbackInterceptor?.dispose()\n    printStopMessage({ quiet: context.startOptions?.quiet })\n  }\n}\n","import { EventEmitter } from 'stream'\n\n/**\n * Pipes all emitted events from one emitter to another.\n */\nexport function pipeEvents(\n  source: EventEmitter,\n  destination: EventEmitter,\n): void {\n  const rawEmit = source.emit\n\n  // @ts-ignore\n  if (rawEmit._isPiped) {\n    return\n  }\n\n  source.emit = function (event, ...data) {\n    destination.emit(event, ...data)\n    return rawEmit.call(this, event, ...data)\n  }\n\n  // @ts-ignore\n  source.emit._isPiped = true\n}\n","import { DefaultBodyType, ResponseResolver } from './handlers/RequestHandler'\nimport {\n  RESTMethods,\n  RestContext,\n  RestHandler,\n  RestRequest,\n} from './handlers/RestHandler'\nimport { Path, PathParams } from './utils/matching/matchRequestUrl'\n\nfunction createRestHandler<Method extends RESTMethods | RegExp>(\n  method: Method,\n) {\n  return <\n    RequestBodyType extends DefaultBodyType = DefaultBodyType,\n    Params extends PathParams<keyof Params> = PathParams,\n    ResponseBody extends DefaultBodyType = DefaultBodyType,\n  >(\n    path: Path,\n    resolver: ResponseResolver<\n      RestRequest<\n        Method extends RESTMethods.HEAD | RESTMethods.GET\n          ? never\n          : RequestBodyType,\n        Params\n      >,\n      RestContext,\n      ResponseBody\n    >,\n  ) => {\n    return new RestHandler(method, path, resolver)\n  }\n}\n\nexport const rest = {\n  all: createRestHandler(/.+/),\n  head: createRestHandler(RESTMethods.HEAD),\n  get: createRestHandler(RESTMethods.GET),\n  post: createRestHandler(RESTMethods.POST),\n  put: createRestHandler(RESTMethods.PUT),\n  delete: createRestHandler(RESTMethods.DELETE),\n  patch: createRestHandler(RESTMethods.PATCH),\n  options: createRestHandler(RESTMethods.OPTIONS),\n}\n","import { DocumentNode, OperationTypeNode } from 'graphql'\nimport { ResponseResolver } from './handlers/RequestHandler'\nimport {\n  GraphQLHandler,\n  GraphQLContext,\n  GraphQLRequest,\n  GraphQLVariables,\n  ExpectedOperationTypeNode,\n  GraphQLHandlerNameSelector,\n} from './handlers/GraphQLHandler'\nimport { Path } from './utils/matching/matchRequestUrl'\n\nexport interface TypedDocumentNode<\n  Result = { [key: string]: any },\n  Variables = { [key: string]: any },\n> extends DocumentNode {\n  __apiType?: (variables: Variables) => Result\n  __resultType?: Result\n  __variablesType?: Variables\n}\n\nfunction createScopedGraphQLHandler(\n  operationType: ExpectedOperationTypeNode,\n  url: Path,\n) {\n  return <\n    Query extends Record<string, any>,\n    Variables extends GraphQLVariables = GraphQLVariables,\n  >(\n    operationName:\n      | GraphQLHandlerNameSelector\n      | DocumentNode\n      | TypedDocumentNode<Query, Variables>,\n    resolver: ResponseResolver<\n      GraphQLRequest<Variables>,\n      GraphQLContext<Query>\n    >,\n  ) => {\n    return new GraphQLHandler<GraphQLRequest<Variables>>(\n      operationType,\n      operationName,\n      url,\n      resolver,\n    )\n  }\n}\n\nfunction createGraphQLOperationHandler(url: Path) {\n  return <\n    Query extends Record<string, any>,\n    Variables extends GraphQLVariables = GraphQLVariables,\n  >(\n    resolver: ResponseResolver<\n      GraphQLRequest<Variables>,\n      GraphQLContext<Query>\n    >,\n  ) => {\n    return new GraphQLHandler<GraphQLRequest<Variables>>(\n      'all',\n      new RegExp('.*'),\n      url,\n      resolver,\n    )\n  }\n}\n\nconst standardGraphQLHandlers = {\n  /**\n   * Captures any GraphQL operation, regardless of its name, under the current scope.\n   * @example\n   * graphql.operation((req, res, ctx) => {\n   *   return res(ctx.data({ name: 'John' }))\n   * })\n   * @see {@link https://mswjs.io/docs/api/graphql/operation `graphql.operation()`}\n   */\n  operation: createGraphQLOperationHandler('*'),\n\n  /**\n   * Captures a GraphQL query by a given name.\n   * @example\n   * graphql.query('GetUser', (req, res, ctx) => {\n   *   return res(ctx.data({ user: { name: 'John' } }))\n   * })\n   * @see {@link https://mswjs.io/docs/api/graphql/query `graphql.query()`}\n   */\n  query: createScopedGraphQLHandler(OperationTypeNode.QUERY, '*'),\n\n  /**\n   * Captures a GraphQL mutation by a given name.\n   * @example\n   * graphql.mutation('SavePost', (req, res, ctx) => {\n   *   return res(ctx.data({ post: { id: 'abc-123' } }))\n   * })\n   * @see {@link https://mswjs.io/docs/api/graphql/mutation `graphql.mutation()`}\n   */\n  mutation: createScopedGraphQLHandler(OperationTypeNode.MUTATION, '*'),\n}\n\nfunction createGraphQLLink(url: Path): typeof standardGraphQLHandlers {\n  return {\n    operation: createGraphQLOperationHandler(url),\n    query: createScopedGraphQLHandler(OperationTypeNode.QUERY, url),\n    mutation: createScopedGraphQLHandler(OperationTypeNode.MUTATION, url),\n  }\n}\n\nexport const graphql = {\n  ...standardGraphQLHandlers,\n  link: createGraphQLLink,\n}\n"]},"metadata":{},"sourceType":"script"}