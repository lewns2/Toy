{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Interceptor = exports.InterceptorReadyState = exports.deleteGlobalSymbol = exports.getGlobalSymbol = void 0;\n\nvar debug_1 = require(\"debug\");\n\nvar AsyncEventEmitter_1 = require(\"./utils/AsyncEventEmitter\");\n\nvar nextTick_1 = require(\"./utils/nextTick\");\n\nfunction getGlobalSymbol(symbol) {\n  return (// @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  );\n}\n\nexports.getGlobalSymbol = getGlobalSymbol;\n\nfunction setGlobalSymbol(symbol, value) {\n  // @ts-ignore\n  globalThis[symbol] = value;\n}\n\nfunction deleteGlobalSymbol(symbol) {\n  // @ts-ignore\n  delete globalThis[symbol];\n}\n\nexports.deleteGlobalSymbol = deleteGlobalSymbol;\nvar InterceptorReadyState;\n\n(function (InterceptorReadyState) {\n  InterceptorReadyState[\"IDLE\"] = \"IDLE\";\n  InterceptorReadyState[\"APPLYING\"] = \"APPLYING\";\n  InterceptorReadyState[\"APPLIED\"] = \"APPLIED\";\n  InterceptorReadyState[\"DISPOSING\"] = \"DISPOSING\";\n  InterceptorReadyState[\"DISPOSED\"] = \"DISPOSED\";\n})(InterceptorReadyState = exports.InterceptorReadyState || (exports.InterceptorReadyState = {}));\n\nvar Interceptor =\n/** @class */\nfunction () {\n  function Interceptor(symbol) {\n    this.symbol = symbol;\n    this.readyState = InterceptorReadyState.IDLE;\n    this.emitter = new AsyncEventEmitter_1.AsyncEventEmitter();\n    this.subscriptions = [];\n    this.log = debug_1.debug(symbol.description); // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n\n    this.emitter.setMaxListeners(0);\n    this.log('constructing the interceptor...');\n  }\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n\n\n  Interceptor.prototype.checkEnvironment = function () {\n    return true;\n  };\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n\n\n  Interceptor.prototype.apply = function () {\n    var _this = this;\n\n    var log = this.log.extend('apply');\n    log('applying the interceptor...');\n\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      log('intercepted already applied!');\n      return;\n    }\n\n    var shouldApply = this.checkEnvironment();\n\n    if (!shouldApply) {\n      log('the interceptor cannot be applied in this environment!');\n      return;\n    }\n\n    this.readyState = InterceptorReadyState.APPLYING; // Always activate the emitter when applying the interceptor.\n    // This will ensure the interceptor can process events after it's\n    // been disposed and re-applied again (it may be a singleton).\n\n    this.emitter.activate();\n    log('activated the emiter!', this.emitter.readyState); // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n\n    var runningInstance = this.getInstance();\n\n    if (runningInstance) {\n      log('found a running instance, reusing...'); // Proxy any listeners you set on this instance to the running instance.\n\n      this.on = function (event, listener) {\n        log('proxying the \"%s\" listener', event); // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n\n        runningInstance.emitter.addListener(event, listener); // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n\n        _this.subscriptions.push(function () {\n          runningInstance.emitter.removeListener(event, listener);\n          log('removed proxied \"%s\" listener!', event);\n        });\n      };\n\n      nextTick_1.nextTick(function () {\n        _this.readyState = InterceptorReadyState.APPLIED;\n      });\n      return;\n    }\n\n    log('no running instance found, setting up a new instance...'); // Setup the interceptor.\n\n    this.setup(); // Store the newly applied interceptor instance globally.\n\n    this.setInstance();\n    nextTick_1.nextTick(function () {\n      _this.readyState = InterceptorReadyState.APPLIED;\n    });\n  };\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n\n\n  Interceptor.prototype.setup = function () {};\n  /**\n   * Listen to the interceptor's public events.\n   */\n\n\n  Interceptor.prototype.on = function (event, listener) {\n    var log = this.log.extend('on');\n\n    if (this.readyState === InterceptorReadyState.DISPOSING || this.readyState === InterceptorReadyState.DISPOSED) {\n      log('cannot listen to events, already disposed!');\n      return;\n    }\n\n    log('adding \"%s\" event listener:', event, listener.name);\n    this.emitter.on(event, listener);\n  };\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n\n\n  Interceptor.prototype.dispose = function () {\n    var e_1, _a;\n\n    var _this = this;\n\n    var log = this.log.extend('dispose');\n\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      log('cannot dispose, already disposed!');\n      return;\n    }\n\n    log('disposing the interceptor...');\n    this.readyState = InterceptorReadyState.DISPOSING;\n\n    if (!this.getInstance()) {\n      log('no interceptors running, skipping dispose...');\n      return;\n    } // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n\n\n    this.clearInstance();\n    log('global symbol deleted:', getGlobalSymbol(this.symbol));\n\n    if (this.subscriptions.length > 0) {\n      log('disposing of %d subscriptions...', this.subscriptions.length);\n\n      try {\n        for (var _b = __values(this.subscriptions), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var dispose = _c.value;\n          dispose();\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      this.subscriptions = [];\n      log('disposed of all subscriptions!', this.subscriptions.length);\n    }\n\n    this.emitter.deactivate();\n    log('destroyed the listener!');\n    nextTick_1.nextTick(function () {\n      _this.readyState = InterceptorReadyState.DISPOSED;\n    });\n  };\n\n  Interceptor.prototype.getInstance = function () {\n    var _a;\n\n    var instance = getGlobalSymbol(this.symbol);\n    this.log('retrieved global instance:', (_a = instance === null || instance === void 0 ? void 0 : instance.constructor) === null || _a === void 0 ? void 0 : _a.name);\n    return instance;\n  };\n\n  Interceptor.prototype.setInstance = function () {\n    setGlobalSymbol(this.symbol, this);\n    this.log('set global instance!', this.symbol.description);\n  };\n\n  Interceptor.prototype.clearInstance = function () {\n    deleteGlobalSymbol(this.symbol);\n    this.log('cleared global instance!', this.symbol.description);\n  };\n\n  return Interceptor;\n}();\n\nexports.Interceptor = Interceptor;","map":{"version":3,"mappings":"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","names":["getGlobalSymbol","symbol","globalThis","undefined","exports","setGlobalSymbol","value","deleteGlobalSymbol","InterceptorReadyState","readyState","IDLE","emitter","AsyncEventEmitter_1","subscriptions","log","debug_1","description","setMaxListeners","Interceptor","extend","APPLIED","shouldApply","checkEnvironment","APPLYING","activate","runningInstance","getInstance","on","event","listener","addListener","_this","push","removeListener","nextTick_1","setup","setInstance","DISPOSING","DISPOSED","name","clearInstance","length","_c","dispose","deactivate","instance","constructor","_a"],"sources":["/Users/donghyun/Desktop/lewns2/node_modules/@mswjs/interceptors/src/Interceptor.ts"],"sourcesContent":["import { Debugger, debug } from 'debug'\nimport { AsyncEventEmitter } from './utils/AsyncEventEmitter'\nimport { nextTick } from './utils/nextTick'\n\nexport type InterceptorEventMap = Record<string, (...args: any[]) => void>\nexport type InterceptorSubscription = () => void\n\nexport function getGlobalSymbol<V>(symbol: Symbol): V | undefined {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  )\n}\n\nfunction setGlobalSymbol(symbol: Symbol, value: any): void {\n  // @ts-ignore\n  globalThis[symbol] = value\n}\n\nexport function deleteGlobalSymbol(symbol: Symbol): void {\n  // @ts-ignore\n  delete globalThis[symbol]\n}\n\nexport enum InterceptorReadyState {\n  IDLE = 'IDLE',\n  APPLYING = 'APPLYING',\n  APPLIED = 'APPLIED',\n  DISPOSING = 'DISPOSING',\n  DISPOSED = 'DISPOSED',\n}\n\nexport type ExtractEventNames<EventMap extends Record<string, any>> =\n  EventMap extends Record<infer EventName, any> ? EventName : never\n\nexport class Interceptor<EventMap extends InterceptorEventMap> {\n  protected emitter: AsyncEventEmitter<EventMap>\n  protected subscriptions: InterceptorSubscription[]\n  protected log: Debugger\n\n  public readyState: InterceptorReadyState\n\n  constructor(private readonly symbol: Symbol) {\n    this.readyState = InterceptorReadyState.IDLE\n\n    this.emitter = new AsyncEventEmitter()\n    this.subscriptions = []\n    this.log = debug(symbol.description!)\n\n    // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n    this.emitter.setMaxListeners(0)\n\n    this.log('constructing the interceptor...')\n  }\n\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  protected checkEnvironment(): boolean {\n    return true\n  }\n\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  public apply(): void {\n    const log = this.log.extend('apply')\n    log('applying the interceptor...')\n\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      log('intercepted already applied!')\n      return\n    }\n\n    const shouldApply = this.checkEnvironment()\n\n    if (!shouldApply) {\n      log('the interceptor cannot be applied in this environment!')\n      return\n    }\n\n    this.readyState = InterceptorReadyState.APPLYING\n\n    // Always activate the emitter when applying the interceptor.\n    // This will ensure the interceptor can process events after it's\n    // been disposed and re-applied again (it may be a singleton).\n    this.emitter.activate()\n    log('activated the emiter!', this.emitter.readyState)\n\n    // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n    const runningInstance = this.getInstance()\n\n    if (runningInstance) {\n      log('found a running instance, reusing...')\n\n      // Proxy any listeners you set on this instance to the running instance.\n      this.on = (event, listener) => {\n        log('proxying the \"%s\" listener', event)\n\n        // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n        runningInstance.emitter.addListener(event, listener)\n\n        // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener)\n          log('removed proxied \"%s\" listener!', event)\n        })\n      }\n\n      nextTick(() => {\n        this.readyState = InterceptorReadyState.APPLIED\n      })\n\n      return\n    }\n\n    log('no running instance found, setting up a new instance...')\n\n    // Setup the interceptor.\n    this.setup()\n\n    // Store the newly applied interceptor instance globally.\n    this.setInstance()\n\n    nextTick(() => {\n      this.readyState = InterceptorReadyState.APPLIED\n    })\n  }\n\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  protected setup(): void {}\n\n  /**\n   * Listen to the interceptor's public events.\n   */\n  public on<Event extends ExtractEventNames<EventMap>>(\n    event: Event,\n    listener: EventMap[Event]\n  ): void {\n    const log = this.log.extend('on')\n\n    if (\n      this.readyState === InterceptorReadyState.DISPOSING ||\n      this.readyState === InterceptorReadyState.DISPOSED\n    ) {\n      log('cannot listen to events, already disposed!')\n      return\n    }\n\n    log('adding \"%s\" event listener:', event, listener.name)\n\n    this.emitter.on(event, listener)\n  }\n\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  public dispose(): void {\n    const log = this.log.extend('dispose')\n\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      log('cannot dispose, already disposed!')\n      return\n    }\n\n    log('disposing the interceptor...')\n    this.readyState = InterceptorReadyState.DISPOSING\n\n    if (!this.getInstance()) {\n      log('no interceptors running, skipping dispose...')\n      return\n    }\n\n    // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n    this.clearInstance()\n\n    log('global symbol deleted:', getGlobalSymbol(this.symbol))\n\n    if (this.subscriptions.length > 0) {\n      log('disposing of %d subscriptions...', this.subscriptions.length)\n\n      for (const dispose of this.subscriptions) {\n        dispose()\n      }\n\n      this.subscriptions = []\n\n      log('disposed of all subscriptions!', this.subscriptions.length)\n    }\n\n    this.emitter.deactivate()\n    log('destroyed the listener!')\n\n    nextTick(() => {\n      this.readyState = InterceptorReadyState.DISPOSED\n    })\n  }\n\n  private getInstance(): this | undefined {\n    const instance = getGlobalSymbol<this>(this.symbol)\n    this.log('retrieved global instance:', instance?.constructor?.name)\n    return instance\n  }\n\n  private setInstance(): void {\n    setGlobalSymbol(this.symbol, this)\n    this.log('set global instance!', this.symbol.description)\n  }\n\n  private clearInstance(): void {\n    deleteGlobalSymbol(this.symbol)\n    this.log('cleared global instance!', this.symbol.description)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}